{
  "MixingScheme": {
    "type": "integer",
    "default": "broyden",
    "section": "SCF::Mixing",
    "description": "The scheme used to produce, at each iteration in the self-consistent cycle that attempts to solve the Kohn-Sham equations, the input density from the value of the input and output densities of previous iterations.",
    "options": [
      {
        "name": "linear",
        "value": "0"
      },
      {
        "name": "broyden",
        "value": "2"
      },
      {
        "name": "diis",
        "value": "9"
      },
      {
        "name": "bowler_gillan",
        "value": "1"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/scf/mixing/mixingscheme/"
  },
  "MixingPreconditioner": {
    "type": "logical",
    "default": "false",
    "section": "SCF::Mixing",
    "description": "(Experimental) If set to yes, Octopus will use a preconditioner for the mixing operator. This preconditioner is disabled for systems with dimension other than 3.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/scf/mixing/mixingpreconditioner/"
  },
  "Mixing": {
    "type": "float",
    "default": "0.3",
    "section": "SCF::Mixing",
    "description": "The linear, Broyden and DIIS scheme depend on a \"mixing parameter\", set by this variable. Must be 0 < <tt>Mixing</tt> <= 1.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/scf/mixing/mixing/"
  },
  "MixingResidual": {
    "type": "float",
    "default": "0.05",
    "section": "SCF::Mixing",
    "description": "In the DIIS mixing it is benefitial to include a bit of residual into the mixing. This parameter controls this amount.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/scf/mixing/mixingresidual/"
  },
  "MixNumberSteps": {
    "type": "integer",
    "default": "4",
    "section": "SCF::Mixing",
    "description": "In the Broyden and Bowler_Gillan schemes, the new input density or potential is constructed from the values of the densities/potentials of a given number of previous iterations. This number is set by this variable. Must be greater than 1.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/scf/mixing/mixnumbersteps/"
  },
  "MixingRestart": {
    "type": "integer",
    "default": "20",
    "section": "SCF::Mixing",
    "description": "In the Broyden and Bowler_Gillan schemes, the mixing is restarted after the number of iterations given by this variable. Set this to zero to disable restarting the mixing.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/scf/mixing/mixingrestart/"
  },
  "MixInterval": {
    "type": "integer",
    "default": "1",
    "section": "SCF::Mixing",
    "description": "When this variable is set to a value different than 1 (the default) a combined mixing scheme will be used, with MixInterval - 1 steps of linear mixing followed by 1 step of the selected mixing. For the moment this variable only works with DIIS mixing.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/scf/mixing/mixinterval/"
  },
  "MaximumIter": {
    "type": "integer",
    "default": "200",
    "section": "SCF::Convergence",
    "description": "Maximum number of SCF iterations. The code will stop even if convergence has not been achieved. -1 means unlimited. 0 means just do LCAO (or read from restart), compute the eigenvalues and energy, and stop, without updating the wavefunctions or density. If convergence criteria are set, the SCF loop will only stop once the criteria are fulfilled for two consecutive iterations. Note that this variable is also used in the section Calculation Modes::Unoccupied States, where it denotes the maximum number of calls of the eigensolver. In this context, the default value is 50.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/scf/convergence/maximumiter/"
  },
  "ConvEigenError": {
    "type": "logical",
    "default": "false",
    "section": "SCF::Convergence",
    "description": "If true, the calculation will not be considered converged unless all states have individual errors less than <tt>EigensolverTolerance</tt>. If this criterion is used, the SCF loop will only stop once it is fulfilled for two consecutive iterations.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/scf/convergence/conveigenerror/"
  },
  "MixField": {
    "type": "integer",
    "default": "",
    "section": "SCF::Mixing",
    "description": "Selects what should be mixed during the SCF cycle.  Note that currently the exact-exchange part of hybrid functionals is not mixed at all, which would require wavefunction-mixing, not yet implemented. This may lead to instabilities in the SCF cycle, so starting from a converged LDA/GGA calculation is recommended for hybrid functionals. The default depends on the <tt>TheoryLevel</tt> and the exchange-correlation potential used.",
    "options": [
      {
        "name": "none",
        "value": "0"
      },
      {
        "name": "potential",
        "value": "1"
      },
      {
        "name": "density",
        "value": "2"
      },
      {
        "name": "states",
        "value": "3"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/scf/mixing/mixfield/"
  },
  "SCFinLCAO": {
    "type": "logical",
    "default": "no",
    "section": "SCF",
    "description": "Performs the SCF cycle with the calculation restricted to the LCAO subspace. This may be useful for systems with convergence problems (first do a calculation within the LCAO subspace, then restart from that point for an unrestricted calculation).",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/scf/scfinlcao/"
  },
  "SCFCalculateForces": {
    "type": "logical",
    "default": "",
    "section": "SCF",
    "description": "This variable controls whether the forces on the ions are calculated at the end of a self-consistent iteration. The default is yes, unless the system only has user-defined species.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/scf/scfcalculateforces/"
  },
  "SCFCalculateStress": {
    "type": "logical",
    "default": "",
    "section": "SCF",
    "description": "This variable controls whether the stress on the lattice is calculated at the end of a self-consistent iteration. The default is no.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/scf/scfcalculatestress/"
  },
  "SCFCalculateDipole": {
    "type": "logical",
    "default": "",
    "section": "SCF",
    "description": "This variable controls whether the dipole is calculated at the end of a self-consistent iteration. For finite systems the default is yes. For periodic systems the default is no, unless an electric field is being applied in a periodic direction. The single-point Berry`s phase approximation is used for periodic directions. Ref: E Yaschenko, L Fu, L Resca, and R Resta, <i>Phys. Rev. B</i> <b>58</b>, 1222-1229 (1998).",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/scf/scfcalculatedipole/"
  },
  "SCFCalculatePartialCharges": {
    "type": "logical",
    "default": "no",
    "section": "SCF",
    "description": "(Experimental) This variable controls whether partial charges are calculated at the end of a self-consistent iteration.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/scf/scfcalculatepartialcharges/"
  },
  "LocalMagneticMomentsSphereRadius": {
    "type": "float",
    "default": "",
    "section": "Output",
    "description": "The local magnetic moments are calculated by integrating the magnetization density in spheres centered around each atom. This variable controls the radius of the spheres. The default is half the minimum distance between two atoms in the input coordinates, or 100 a.u. if there is only one atom (for isolated systems).",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/output/localmagneticmomentssphereradius/"
  },
  "UnoccShowOccStates": {
    "type": "logical",
    "default": "false",
    "section": "Calculation Modes::Unoccupied States",
    "description": "If true, the convergence for the occupied states will be shown too in the output. This is useful for testing, or if the occupied states fail to converge. It will be enabled automatically if only occupied states are being calculated.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/unoccupied states/unoccshowoccstates/"
  },
  "UnoccUseTD": {
    "type": "logical",
    "default": "no",
    "section": "Calculation Modes::Unoccupied States",
    "description": "If true, Octopus will use the density and states from the restart/td folder to compute the bandstructure, instead of the restart/gs ones.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/unoccupied states/unoccusetd/"
  },
  "RDMTolerance": {
    "type": "float",
    "default": "1e-7 Ha",
    "section": "SCF::RDMFT",
    "description": "Convergence criterion for stopping the occupation numbers minimization. Minimization is stopped when all derivatives of the energy wrt. each occupation number are smaller than this criterion. The bisection for finding the correct mu that is needed for the occupation number minimization also stops according to this criterion.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/scf/rdmft/rdmtolerance/"
  },
  "RDMToleranceFO": {
    "type": "float",
    "default": "1e-4 Ha",
    "section": "SCF::RDMFT",
    "description": "Convergence criterion for stopping the diagonalization of the Fock matrix in the Piris method. Orbital minimization is stopped when all off-diagonal ellements of the Fock matrix are smaller than this criterion.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/scf/rdmft/rdmtolerancefo/"
  },
  "RDMConvEner": {
    "type": "float",
    "default": "1e-6 Ha",
    "section": "SCF::RDMFT",
    "description": "Convergence criterion for stopping the overall minimization of the energy with respect to occupation numbers and the orbitals. The minimization of the energy stops when the total energy difference between two subsequent minimizations of the energy with respect to the occupation numbers and the orbitals is smaller than this criterion. It is also used to exit the orbital minimization.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/scf/rdmft/rdmconvener/"
  },
  "RDMBasis": {
    "type": "logical",
    "default": "yes",
    "section": "SCF::RDMFT",
    "description": "If true, all the energy terms and corresponding derivatives involved in RDMFT will not be calculated on the grid but on the basis of the initial orbitals",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/scf/rdmft/rdmbasis/"
  },
  "RDMHartreeFock": {
    "type": "logical",
    "default": "no",
    "section": "SCF::RDMFT",
    "description": "If true, the code simulates a HF calculation, by omitting the occ.num. optimization can be used for test reasons",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/scf/rdmft/rdmhartreefock/"
  },
  "LCAOStart": {
    "type": "integer",
    "default": "",
    "section": "SCF::LCAO",
    "description": "Before starting a SCF calculation, <tt>Octopus</tt> can perform a linear combination of atomic orbitals (LCAO) calculation. These can provide <tt>Octopus</tt> with a good set of initial wavefunctions and with a new guess for the density. (Up to the current version, only a minimal basis set is used.) The default is <tt>lcao_states</tt> if at least one species representing an atom is present. The default is <tt>lcao_none</tt> if all species are <tt>species_user_defined</tt>, <tt>species_charge_density</tt>, <tt>species_from_file</tt>, or <tt>species_jellium_slab</tt>. The initial guess densities for LCAO are taken from the atomic orbitals for pseudopotential species; from the natural charge density for <tt>species_charge_density</tt>, <tt>species_point</tt>, <tt>species_jellium</tt>, and <tt>species_jellium_slab</tt>; or uniform for <tt>species_full_delta</tt>, <tt>species_full_gaussian</tt>, <tt>species_user_defined</tt>, or <tt>species_from_file</tt>. Pseudopotential species use the pseudo-wavefunctions as orbitals, full-potential atomic species (<tt>species_full_delta</tt> and <tt>species_full_gaussian</tt>) use hydrogenic wavefunctions, and others use harmonic-oscillator wavefunctions. Note: Some pseudopotential files (CPI, FHI for example) do not contain full information about the orbitals. In this case, Octopus generates the starting density from the normalized square root of the local potential. If no orbitals are available at all from the pseudopotential files, Octopus will not be able to perform an LCAO and the initial states will be randomized.",
    "options": [
      {
        "name": "lcao_none",
        "value": "0"
      },
      {
        "name": "lcao_states",
        "value": "2"
      },
      {
        "name": "lcao_full",
        "value": "3"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/scf/lcao/lcaostart/"
  },
  "LCAOAlternative": {
    "type": "logical",
    "default": "false",
    "section": "SCF::LCAO",
    "description": "If this variable is set, the LCAO procedure will use an alternative (and experimental) implementation. It is faster for large systems and parallel in states. It is not working for spinors, however.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/scf/lcao/lcaoalternative/"
  },
  "LCAOComplexYlms": {
    "type": "logical",
    "default": "false",
    "section": "SCF::LCAO",
    "description": "If set to true, and using complex states, complex spherical harmonics will be used, <i>i.e.</i> with <math>e^{\\pm i m \\phi}</math>. If false, real spherical harmonics with <math>\\sin(m \\phi)</math> or <math>\\cos(m \\phi)</math> are used. This variable will make it more likely to get states that are eigenvectors of the <math>L_z</math> operator, with a definite angular momentum.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/scf/lcao/lcaocomplexylms/"
  },
  "LCAOSaveMemory": {
    "type": "logical",
    "default": "false",
    "section": "SCF::LCAO",
    "description": "If set to true, the LCAO will allocate extra memory needed in single precision instead of double precision.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/scf/lcao/lcaosavememory/"
  },
  "LCAOScaleFactor": {
    "type": "float",
    "default": "1.0",
    "section": "SCF::LCAO",
    "description": "The coordinates of the atomic orbitals used by the LCAO procedure will be rescaled by the value of this variable. 1.0 means no rescaling.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/scf/lcao/lcaoscalefactor/"
  },
  "LCAOMaximumOrbitalRadius": {
    "type": "float",
    "default": "20.0 a.u.",
    "section": "SCF::LCAO",
    "description": "The LCAO procedure will ignore orbitals that have an extent greater that this value.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/scf/lcao/lcaomaximumorbitalradius/"
  },
  "LCAODimension": {
    "type": "integer",
    "default": "",
    "section": "SCF::LCAO",
    "description": "(Only applies if <tt>LCAOAlternative = no</tt>.) Before starting the SCF cycle, an initial LCAO calculation can be performed in order to obtain reasonable initial guesses for spin-orbitals and densities. For this purpose, the code calculates a number of atomic orbitals. The number available for a species described by a pseudopotential is all the orbitals up the maximum angular momentum in the pseudopotential, minus any orbitals that are found to be unbound. For non-pseudopotential species, the number is equal to twice the valence charge. The default dimension for the LCAO basis set will be the sum of all these numbers, or twice the number of required orbitals for the full calculation, whichever is less. This dimension however can be changed by making use of this variable. Note that <tt>LCAODimension</tt> cannot be smaller than the number of orbitals needed in the full calculation -- if <tt>LCAODimension</tt> is smaller, it will be silently increased to meet this requirement. In the same way, if <tt>LCAODimension</tt> is larger than the available number of atomic orbitals, it will be reduced. If you want to use the largest possible number, set <tt>LCAODimension</tt> to a negative number.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/scf/lcao/lcaodimension/"
  },
  "LCAOKeepOrbitals": {
    "type": "logical",
    "default": "yes",
    "section": "SCF::LCAO",
    "description": "Only applies if <tt>LCAOAlternative = true</tt>. If set to yes (the default) Octopus keeps atomic orbitals in memory during the LCAO procedure. If set to no, the orbitals are generated each time that they are needed, increasing computational time but saving memory. When set to yes, Octopus prints the amount of memory per node that is required to store the orbitals.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/scf/lcao/lcaokeeporbitals/"
  },
  "LCAOExtraOrbitals": {
    "type": "logical",
    "default": "false",
    "section": "SCF::LCAO",
    "description": "Only applies if <tt>LCAOAlternative = true</tt>, and all species are pseudopotentials. (experimental) If this variable is set to yes, the LCAO procedure will add an extra set of numerical orbitals (by using the derivative of the radial part of the original orbitals). Note that this corresponds roughly to adding orbitals with higher principal quantum numbers, but the same angular momentum. This option may cause problems for unoccupied states since you may miss some lower-lying states which correspond to higher angular momenta instead of higher principal quantum number.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/scf/lcao/lcaoextraorbitals/"
  },
  "LCAODiagTol": {
    "type": "float",
    "default": "1e-10",
    "section": "SCF::LCAO",
    "description": "Only applies if <tt>LCAOAlternative = true</tt>. The tolerance for the diagonalization of the LCAO Hamiltonian.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/scf/lcao/lcaodiagtol/"
  },
  "GuessMagnetDensity": {
    "type": "integer",
    "default": "ferromagnetic",
    "section": "SCF::LCAO",
    "description": "The guess density for the SCF cycle is just the sum of all the atomic densities. When performing spin-polarized or non-collinear-spin calculations this option sets the guess magnetization density. For anti-ferromagnetic configurations, the <tt>user_defined</tt> option should be used. Note that if the <tt>paramagnetic</tt> option is used, the final ground state will also be paramagnetic, but the same is not true for the other options.",
    "options": [
      {
        "name": "paramagnetic",
        "value": "1"
      },
      {
        "name": "ferromagnetic",
        "value": "2"
      },
      {
        "name": "random",
        "value": "3"
      },
      {
        "name": "user_defined",
        "value": "77"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/scf/lcao/guessmagnetdensity/"
  },
  "AtomsMagnetDirection": {
    "type": "block",
    "default": "",
    "section": "SCF::LCAO",
    "description": "This option is only used when <tt>GuessMagnetDensity</tt> is set to <tt>user_defined</tt>. It provides a direction for the magnetization vector of each atom when building the guess density. In order to do that, the user should specify the coordinates of a vector that has the desired direction and norm.  Note that it is necessary to maintain the ordering in which the species were defined in the coordinates specifications. For spin-polarized calculations, the vectors should have only one component; for non-collinear-spin calculations, they should have three components. If the norm of the vector is greater than the number of valence electrons in the atom, it will be rescaled to this number, which is the maximum possible magnetization.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/scf/lcao/atomsmagnetdirection/"
  },
  "ConvEnergy": {
    "type": "float",
    "default": "0.0",
    "section": "SCF::Convergence",
    "description": "Stop the SCF when the magnitude of change in energy during at one SCF iteration is smaller than this value. A zero value (the default) means do not use this criterion. If this criterion is used, the SCF loop will only stop once it is fulfilled for two consecutive iterations.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/scf/convergence/convenergy/"
  },
  "ConvAbsDens": {
    "type": "float",
    "default": "0.0",
    "section": "SCF::Convergence",
    "description": "Absolute convergence of the density: <math>\\varepsilon = \\int {\\rm d}^3r \\left| \\rho^{out}(\\bf r) -\\rho^{inp}(\\bf r) \\right|</math>. A zero value (the default) means do not use this criterion. If this criterion is used, the SCF loop will only stop once it is fulfilled for two consecutive iterations.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/scf/convergence/convabsdens/"
  },
  "ConvRelDens": {
    "type": "float",
    "default": "1e-6",
    "section": "SCF::Convergence",
    "description": "Relative convergence of the density: <math>\\varepsilon = \\frac{1}{N} \\mathrm{ConvAbsDens}</math>. <i>N</i> is the total number of electrons in the problem.  A zero value means do not use this criterion. If you reduce this value, you should also reduce <tt>EigensolverTolerance</tt> to a value of roughly 1/10 of <tt>ConvRelDens</tt> to avoid convergence problems. If this criterion is used, the SCF loop will only stop once it is fulfilled for two consecutive iterations.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/scf/convergence/convreldens/"
  },
  "ConvAbsEv": {
    "type": "float",
    "default": "0.0",
    "section": "SCF::Convergence",
    "description": "Absolute convergence of the sum of the eigenvalues: <math> \\varepsilon = \\left| \\sum_{j=1}^{N_{occ}} \\varepsilon_j^{out} - \\sum_{j=1}^{N_{occ}} \\varepsilon_j^{inp} \\right| </math> A zero value (the default) means do not use this criterion. If this criterion is used, the SCF loop will only stop once it is fulfilled for two consecutive iterations.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/scf/convergence/convabsev/"
  },
  "ConvRelEv": {
    "type": "float",
    "default": "0.0",
    "section": "SCF::Convergence",
    "description": "Relative convergence of the sum of the eigenvalues: <math>\\varepsilon = \\frac{ \\left| \\sum_{j=1}^{N_{occ}} ( \\varepsilon_j^{out} -  \\varepsilon_j^{inp} ) \\right|} {\\left| \\sum_{j=1}^{N_{occ}} \\varepsilon_j^{out} \\right|} </math> A zero value (the default) means do not use this criterion. If this criterion is used, the SCF loop will only stop once it is fulfilled for two consecutive iterations.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/scf/convergence/convrelev/"
  },
  "OCTLocalTarget": {
    "type": "string",
    "default": "",
    "section": "Calculation Modes::Optimal Control",
    "description": "If <tt>OCTTargetOperator = oct_tg_local</tt>, then one must supply a function that defines the target. This should be done by defining it through a string, using the variable <tt>OCTLocalTarget</tt>.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/optimal control/octlocaltarget/"
  },
  "OCTTargetTransformStates": {
    "type": "block",
    "default": "no",
    "section": "Calculation Modes::Optimal Control",
    "description": "If <tt>OCTTargetOperator = oct_tg_gstransformation</tt>, you must specify a <tt>OCTTargetTransformStates</tt> block, in order to specify which linear combination of the states present in <tt>restart/gs</tt> is used to create the target state. The syntax is the same as the <tt>TransformStates</tt> block.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/optimal control/octtargettransformstates/"
  },
  "OCTScheme": {
    "type": "integer",
    "default": "oct_zbr98",
    "section": "Calculation Modes::Optimal Control",
    "description": "Optimal Control Theory can be performed with <tt>Octopus</tt> with a variety of different algorithms. Not all of them can be used with any choice of target or control function representation. For example, some algorithms cannot be used if <tt>OCTControlRepresentation = control_function_real_time</tt> (<tt>OCTScheme</tt> > <tt>oct_straight_iteration</tt>), and others cannot be used if <tt>OCTControlRepresentation = control_function_parametrized</tt> (<tt>OCTScheme</tt>  <  <tt>oct_straight_iteration</tt>).",
    "options": [
      {
        "name": "oct_zbr98",
        "value": "1"
      },
      {
        "name": "oct_zr98",
        "value": "2"
      },
      {
        "name": "oct_wg05",
        "value": "3"
      },
      {
        "name": "oct_mt03",
        "value": "4"
      },
      {
        "name": "oct_krotov",
        "value": "5"
      },
      {
        "name": "oct_straight_iteration",
        "value": "6"
      },
      {
        "name": "oct_cg",
        "value": "7"
      },
      {
        "name": "oct_bfgs",
        "value": "8"
      },
      {
        "name": "oct_direct",
        "value": "9"
      },
      {
        "name": "oct_nlopt_bobyqa",
        "value": "11"
      },
      {
        "name": "oct_nlopt_lbfgs",
        "value": "12"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/optimal control/octscheme/"
  },
  "OCTEta": {
    "type": "float",
    "default": "1.0",
    "section": "Calculation Modes::Optimal Control",
    "description": "If <tt>OCTScheme = oct_mt03</tt>, then you can supply the \"eta\" and \"delta\" parameters described in [Y. Maday and G. Turinici, <i>J. Chem. Phys.</i> <b>118</b>, 8191 (2003)], using the <tt>OCTEta</tt> and <tt>OCTDelta</tt> variables.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/optimal control/octeta/"
  },
  "OCTDelta": {
    "type": "float",
    "default": "0.0",
    "section": "Calculation Modes::Optimal Control",
    "description": "If <tt>OCTScheme = oct_mt03</tt>, then you can supply the \"eta\" and \"delta\" parameters described in [Y. Maday and G. Turinici, <i>J. Chem. Phys.</i> <b>118</b>, 8191 (2003)], using the <tt>OCTEta</tt> and <tt>OCTDelta</tt> variables.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/optimal control/octdelta/"
  },
  "OCTDoubleCheck": {
    "type": "logical",
    "default": "true",
    "section": "Calculation Modes::Optimal Control",
    "description": "In order to make sure that the optimized field indeed does its job, the code may run a normal propagation after the optimization using the optimized field.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/optimal control/octdoublecheck/"
  },
  "OCTCheckGradient": {
    "type": "float",
    "default": "0.0",
    "section": "Calculation Modes::Optimal Control",
    "description": "When doing QOCT with the conjugate-gradient optimization scheme, the gradient is computed thanks to a forward-backwards propagation. For debugging purposes, this gradient can be compared with the value obtained \"numerically\" (<i>i.e.</i> by doing successive forward propagations with control fields separated by small finite differences). In order to activate this feature, set <tt>OCTCheckGradient</tt> to some non-zero value, which will be the finite difference used to numerically compute the gradient.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/optimal control/octcheckgradient/"
  },
  "OCTDirectStep": {
    "type": "float",
    "default": "0.25",
    "section": "Calculation Modes::Optimal Control",
    "description": "If you choose <tt>OCTScheme = oct_direct</tt> or <tt>OCTScheme = oct_nlopt_bobyqa</tt>, the algorithms necessitate an initial \"step\" to perform the direct search for the optimal value. The precise meaning of this \"step\" differs.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/optimal control/octdirectstep/"
  },
  "OCTNumberCheckPoints": {
    "type": "integer",
    "default": "0",
    "section": "Calculation Modes::Optimal Control",
    "description": "During an OCT propagation, the code may write the wavefunctions at some time steps (the \"check points\"). When the inverse backward or forward propagation is performed in a following step, the wavefunction should reverse its path (almost) exactly. This can be checked to make sure that it is the case -- otherwise one should try reducing the time-step, or altering in some other way the variables that control the propagation. If the backward (or forward) propagation is not retracing the steps of the previous forward (or backward) propagation, the code will write a warning.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/optimal control/octnumbercheckpoints/"
  },
  "OCTRandomInitialGuess": {
    "type": "logical",
    "default": "false",
    "section": "Calculation Modes::Optimal Control",
    "description": "The initial field to start the optimization search is usually given in the <tt>inp</tt> file, through a <tt>TDExternalFields</tt> block. However, you can start from a random guess if you set this variable to true. Note, however, that this is only valid for the \"direct\" optimization schemes; moreover you still need to provide a <tt>TDExternalFields</tt> block.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/optimal control/octrandominitialguess/"
  },
  "OCTClassicalTarget": {
    "type": "block",
    "default": "",
    "section": "Calculation Modes::Optimal Control",
    "description": "If <tt>OCTTargetOperator = oct_tg_classical</tt>, the you must supply this block. It should contain a string (e.g. \"(q[1,1]-q[1,2])*p[2,1]\") with a mathematical expression in terms of two arrays, q and p, that represent the position and momenta of the classical variables. The first index runs through the various classical particles, and the second index runs through the spatial dimensions. In principle, the block only contains one entry (string). However, if the expression is very long, you can split it into various lines (one column each) that will be concatenated. The QOCT algorithm will attempt to maximize this expression, at the end of the propagation.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/optimal control/octclassicaltarget/"
  },
  "OCTMomentumDerivatives": {
    "type": "block",
    "default": "",
    "section": "Calculation Modes::Optimal Control",
    "description": "This block should contain the derivatives of the expression given in <tt>OCTClassicalTarget</tt> with respect to the p array components. Each line corresponds to a different classical particle, whereas the columns correspond to each spatial dimension: the (i,j) block component corresponds with the derivative wrt p[i,j].",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/optimal control/octmomentumderivatives/"
  },
  "OCTPositionDerivatives": {
    "type": "block",
    "default": "",
    "section": "Calculation Modes::Optimal Control",
    "description": "This block should contain the derivatives of the expression given in <tt>OCTClassicalTarget</tt> with respect to the q array components. Each line corresponds to a different classical particle, whereas the columns correspond to each spatial dimension: the (i,j) block component corresponds with the derivative wrt q[i,j].",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/optimal control/octpositionderivatives/"
  },
  "OCTExcludedStates": {
    "type": "string",
    "default": "",
    "section": "Calculation Modes::Optimal Control",
    "description": "If the target is the exclusion of several targets, (\"OCTTargetOperator = oct_exclude_states\") then you must declare which states are to be excluded, by setting the OCTExcludedStates variable. It must be a string in \"list\" format: \"1-8\", or \"2,3,4-9\", for example. Be careful to include in this list only states that have been calculated in a previous \"gs\" or \"unocc\" calculation, or otherwise the error will be silently ignored.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/optimal control/octexcludedstates/"
  },
  "OCTInitialState": {
    "type": "integer",
    "default": "oct_is_groundstate",
    "section": "Calculation Modes::Optimal Control",
    "description": "Describes the initial state of the quantum system. Possible arguments are:",
    "options": [
      {
        "name": "oct_is_groundstate",
        "value": "1"
      },
      {
        "name": "oct_is_excited",
        "value": "2"
      },
      {
        "name": "oct_is_gstransformation",
        "value": "3"
      },
      {
        "name": "oct_is_userdefined",
        "value": "4"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/optimal control/octinitialstate/"
  },
  "OCTInitialTransformStates": {
    "type": "block",
    "default": "",
    "section": "Calculation Modes::Optimal Control",
    "description": "If <tt>OCTInitialState = oct_is_gstransformation</tt>, you must specify an <tt>OCTInitialTransformStates</tt> block, in order to specify which linear combination of the states present in <tt>restart/gs</tt> is used to create the initial state. The syntax is the same as the <tt>TransformStates</tt> block.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/optimal control/octinitialtransformstates/"
  },
  "OCTInitialUserdefined": {
    "type": "block",
    "default": "",
    "section": "Calculation Modes::Optimal Control",
    "description": "Define an initial state. Syntax follows the one of the <tt>UserDefinedStates</tt> block. Example: <tt>%OCTInitialUserdefined <br>&nbsp;&nbsp; 1 | 1 | 1 |  \"exp(-r^2)*exp(-i*0.2*x)\" <br>%</tt>",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/optimal control/octinitialuserdefined/"
  },
  "OCTTargetOperator": {
    "type": "integer",
    "default": "oct_tg_gstransformation",
    "section": "Calculation Modes::Optimal Control",
    "description": "The variable <tt>OCTTargetOperator</tt> prescribes which kind of target functional is to be used.",
    "options": [
      {
        "name": "oct_tg_groundstate",
        "value": "1"
      },
      {
        "name": "oct_tg_excited",
        "value": "2"
      },
      {
        "name": "oct_tg_gstransformation",
        "value": "3"
      },
      {
        "name": "oct_tg_userdefined",
        "value": "4"
      },
      {
        "name": "oct_tg_jdensity",
        "value": "5"
      },
      {
        "name": "oct_tg_local",
        "value": "6"
      },
      {
        "name": "oct_tg_td_local",
        "value": "7"
      },
      {
        "name": "oct_tg_exclude_state",
        "value": "8"
      },
      {
        "name": "oct_tg_hhg",
        "value": "9"
      },
      {
        "name": "oct_tg_velocity",
        "value": "10"
      },
      {
        "name": "oct_tg_hhgnew",
        "value": "12"
      },
      {
        "name": "oct_tg_classical",
        "value": "13"
      },
      {
        "name": "oct_tg_spin",
        "value": "14"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/optimal control/octtargetoperator/"
  },
  "OCTTargetSpin": {
    "type": "block",
    "default": "",
    "section": "Calculation Modes::Optimal Control",
    "description": "(Experimental) Specify the targeted spin as a 3-component vector. It will be normalized.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/optimal control/octtargetspin/"
  },
  "OCTVelocityTarget": {
    "type": "block",
    "default": "",
    "section": "Calculation Modes::Optimal Control",
    "description": "If <tt>OCTTargetOperator = oct_tg_velocity</tt>, then one must supply the target to optimize in terms of the ionic velocities. This is done by supplying a string through the block <tt>OCTVelocityTarget</tt>. Each velocity component is supplied by <tt>\"v[n_atom,vec_comp]\"</tt>, where <tt>n_atom</tt> is the atom number, corresponding to the <tt>Coordinates</tt> block, and <tt>vec_comp</tt> is the corresponding vector component of the velocity. The target string can be supplied by using several lines in this block. As an example, the following target can be used to maximize the velocity difference between atom 1 and 2 (in a 3D system): <tt>%OCTVelocityTarget <br> \"(v[1,1]-v[2,1])^2 + (v[1,2]-v[2,2])^2 + \" <br> \"(v[1,3]-v[2,3])^2\" <br>%</tt>",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/optimal control/octvelocitytarget/"
  },
  "OCTVelocityDerivatives": {
    "type": "block",
    "default": "",
    "section": "Calculation Modes::Optimal Control",
    "description": "If <tt>OCTTargetOperator = oct_tg_velocity</tt>, and <tt>OCTScheme = oct_cg</tt> or <tt>OCTScheme = oct_bfgs</tt> then you must supply the target in terms of the ionic velocities AND the derivatives of the target with respect to the ionic velocity components. The derivatives are supplied via strings through the block <tt>OCTVelocityDerivatives</tt>. Each velocity component is supplied by <tt>\"v[n_atom,vec_comp]\"</tt>, while <tt>n_atom</tt> is the atom number, corresponding to the <tt>Coordinates</tt> block, and <tt>vec_comp</tt> is the corresponding vector component of the velocity. The first line of the <tt>OCTVelocityDerivatives</tt> block contains the derivatives with respect to <tt>v[1,*]</tt>, the second with respect to <tt>v[2,*]</tt> and so on. The first column contains all derivatives with respect <tt>v[*,1]</tt>, the second with respect to <tt>v[*,2]</tt> and the third w.r.t. <tt>v[*,3]</tt>. As an example, we show the <tt>OCTVelocityDerivatives</tt> block corresponding to the target shown in the <tt>OCTVelocityTarget</tt> help section: <tt>%OCTVelocityDerivatives <br> \" 2*(v[1,1]-v[2,1])\" | \" 2*(v[1,2]-v[2,2])\" | \" 2*(v[1,3]-v[2,3])\" <br> \"-2*(v[1,1]-v[2,1])\" | \"-2*(v[1,2]-v[2,2])\" | \"-2*(v[1,3]-v[2,3])\" <br>%</tt>",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/optimal control/octvelocityderivatives/"
  },
  "OCTTargetUserdefined": {
    "type": "block",
    "default": "",
    "section": "Calculation Modes::Optimal Control",
    "description": "Define a target state. Syntax follows the one of the <tt>UserDefinedStates</tt> block. Example: <tt>%OCTTargetUserdefined <br>&nbsp;&nbsp; 1 | 1 | 1 |  \"exp(-r^2)*exp(-i*0.2*x)\" <br>%</tt>",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/optimal control/octtargetuserdefined/"
  },
  "OCTEps": {
    "type": "float",
    "default": "1.0e-6",
    "section": "Calculation Modes::Optimal Control",
    "description": "Define the convergence threshold. It computes the difference between the \"input\" field in the iterative procedure, and the \"output\" field. If this difference is less than <tt>OCTEps</tt> the iteration is stopped. This difference is defined as: <math> D[\\varepsilon^{in},\\varepsilon^{out}] = \\int_0^T dt \\left| \\varepsilon^{in}(t)-\\varepsilon^{out}(t)\\right|^2 </math> (If there are several control fields, this difference is defined as the sum over all the individual differences.) Whenever this condition is satisfied, it means that we have reached a solution point of the QOCT equations, <i>i.e.</i> a critical point of the QOCT functional (not necessarily a maximum, and not necessarily the global maximum).",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/optimal control/octeps/"
  },
  "OCTMaxIter": {
    "type": "integer",
    "default": "10",
    "section": "Calculation Modes::Optimal Control",
    "description": "The maximum number of iterations. Typical values range from 10-100.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/optimal control/octmaxiter/"
  },
  "OCTDumpIntermediate": {
    "type": "logical",
    "default": "true",
    "section": "Calculation Modes::Optimal Control",
    "description": "Writes to disk the laser pulse data during the OCT algorithm at intermediate steps. These are files called <tt>opt_control/laser.xxxx</tt>, where <tt>xxxx</tt> is the iteration number.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/optimal control/octdumpintermediate/"
  },
  "OCTTdTarget": {
    "type": "block",
    "default": "",
    "section": "Calculation Modes::Optimal Control",
    "description": "(Experimental) If <tt>OCTTargetOperator = oct_tg_td_local</tt>, then you must supply a OCTTdTarget block. The block should only contain one element, a string cotaining the definition of the time-dependent local target, <i>i.e.</i> a function of x,y,z and t that is to be maximized along the evolution.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/optimal control/octtdtarget/"
  },
  "OCTFilter": {
    "type": "block",
    "default": "",
    "section": "Calculation Modes::Optimal Control",
    "description": "The block <tt>OCTFilter</tt> describes the type and shape of the filter function that are applied to the optimized laser field in each iteration. The filter forces the laser field to obtain the given form in frequency space. Each line of the block describes a filter; this way you can actually have more than one filter function (<i>e.g.</i> a filter in time and two in frequency space). The filters are applied in the given order, <i>i.e.</i>, first the filter specified by the first line is applied, then second line. The syntax of each line is, then: <tt>%OCTFilter <br>&nbsp;&nbsp;domain | function <br>%</tt> Possible arguments for domain are: (i) <tt>frequency_filter</tt>: Specifies a spectral filter. (ii) <tt>time_filter</tt>: DISABLED IN THIS VERSION. Example: <tt>%OCTFilter <br>&nbsp;&nbsp;time | \"exp(-80*( w + 0.1567 )^2  ) + exp(-80*( w - 0.1567 )^2  )\" <br>%</tt> Be careful that also the negative-frequency component is filtered since the resulting field has to be real-valued.",
    "options": [
      {
        "name": "frequency_filter",
        "value": "1"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/optimal control/octfilter/"
  },
  "OCTTargetDensity": {
    "type": "string",
    "default": "",
    "section": "Calculation Modes::Optimal Control",
    "description": "If <tt>OCTTargetOperator = oct_tg_density</tt>, then one must supply the target density that should be searched for. This one can do by supplying a string through the variable <tt>OCTTargetDensity</tt>. Alternately, give the special string <tt>\"OCTTargetDensityFromState\"</tt> to specify the expression via the block <tt>OCTTargetDensityFromState</tt>.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/optimal control/octtargetdensity/"
  },
  "OCTTargetDensityFromState": {
    "type": "block",
    "default": "no",
    "section": "Calculation Modes::Optimal Control",
    "description": "If <tt>OCTTargetOperator = oct_tg_density</tt>, and <tt>OCTTargetDensity = \"OCTTargetDensityFromState\"</tt>, you must specify a <tt>OCTTargetDensityState</tt> block, in order to specify which linear combination of the states present in <tt>restart/gs</tt> is used to create the target density. The syntax is the same as the <tt>TransformStates</tt> block.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/optimal control/octtargetdensityfromstate/"
  },
  "OCTCurrentFunctional": {
    "type": "integer",
    "default": "oct_no_curr",
    "section": "Calculation Modes::Optimal Control",
    "description": "(Experimental) The variable <tt>OCTCurrentFunctional</tt> describes which kind of current target functional <math>J1_c[j]</math> is to be used.",
    "options": [
      {
        "name": "oct_no_curr",
        "value": "0"
      },
      {
        "name": "oct_curr_square",
        "value": "1"
      },
      {
        "name": "oct_max_curr_ring",
        "value": "2"
      },
      {
        "name": "oct_curr_square_td",
        "value": "3"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/optimal control/octcurrentfunctional/"
  },
  "OCTCurrentWeight": {
    "type": "float",
    "default": "0.0",
    "section": "Calculation Modes::Optimal Control",
    "description": "In the case of simultaneous optimization of density <math>n</math> and current <math>j</math>, one can tune the importance of the current functional <math>J1_c[j]</math>, as the respective functionals might not provide results on the same scale of magnitude. <math>J1[n,j]= J1_d[n]+ {\\tt OCTCurrentWeight}\\ J1_c[j]</math>. Be aware that its sign is crucial for the chosen <tt>OCTCurrentFunctional</tt> as explained there.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/optimal control/octcurrentweight/"
  },
  "OCTStartIterCurrTg": {
    "type": "integer",
    "default": "0",
    "section": "Calculation Modes::Optimal Control",
    "description": "Allows for a time-dependent target for the current without defining it for the total time-interval of the simulation. Thus it can be switched on at the iteration desired, <tt>OCTStartIterCurrTg</tt> >= 0 and  <tt>OCTStartIterCurrTg</tt>  <  <tt>TDMaximumIter</tt>. Tip: If you would like to specify a real time for switching the functional on rather than the number of steps, just use something like: <tt>OCTStartIterCurrTg</tt> = 100.0 / <tt>TDTimeStep</tt>.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/optimal control/octstartitercurrtg/"
  },
  "OCTSpatialCurrWeight": {
    "type": "block",
    "default": "",
    "section": "Calculation Modes::Optimal Control",
    "description": "Can be seen as a position-dependent <tt>OCTCurrentWeight</tt>. Consequently, it weights contribution of current <math>j</math> to its functional <math>J1_c[j]</math> according to the position in space. For example, <tt>oct_curr_square</tt> thus becomes <math>J1_c[j] = {\\tt OCTCurrentWeight} \\int{\\left| j(r) \\right|^2 {\\tt OCTSpatialCurrWeight}(r) dr}</math>. It is defined as <tt>OCTSpatialCurrWeight</tt><math>(r) = g(x) g(y) g(z)</math>, where <math>g(x) = \\sum_{i} 1/(1+e^{-{\\tt fact} (x-{\\tt startpoint}_i)}) - 1/(1+e^{-{\\tt fact} (x-{\\tt endpoint}_i)})</math>. If not specified, <math>g(x) = 1</math>. Each <math>g(x)</math> is represented by one line of the block that has the following form <tt>%OCTSpatialCurrWeight <br>&nbsp;&nbsp;  dimension  |  fact |  startpoint_1  | endpoint_1  | startpoint_2 | endpoint_2 |... <br>%</tt> There are no restrictions on the number of lines, nor on the number of pairs of start- and endpoints. Attention: <tt>startpoint</tt> and <tt>endpoint</tt> have to be supplied pairwise with <tt>startpoint  <  endpoint</tt>. <tt>dimension > 0</tt> is integer, <tt>fact</tt> is float.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/optimal control/octspatialcurrweight/"
  },
  "OCTControlFunctionRepresentation": {
    "type": "integer",
    "default": "control_fourier_series_h",
    "section": "Calculation Modes::Optimal Control",
    "description": "If <tt>OCTControlRepresentation = control_function_parametrized</tt>, one must specify the kind of parameters that determine the control function. If <tt>OCTControlRepresentation = control_function_real_time</tt>, then this variable is ignored, and the control function is handled directly in real time.",
    "options": [
      {
        "name": "control_fourier_series_h",
        "value": "3"
      },
      {
        "name": "control_zero_fourier_series_h",
        "value": "4"
      },
      {
        "name": "control_fourier_series",
        "value": "5"
      },
      {
        "name": "control_zero_fourier_series",
        "value": "6"
      },
      {
        "name": "control_rt",
        "value": "7"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/optimal control/octcontrolfunctionrepresentation/"
  },
  "OCTControlFunctionOmegaMax": {
    "type": "float",
    "default": "-1.0",
    "section": "Calculation Modes::Optimal Control",
    "description": "The Fourier series that can be used to represent the control functions must be truncated; the truncation is given by a cut-off frequency which is determined by this variable.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/optimal control/octcontrolfunctionomegamax/"
  },
  "OCTFixFluenceTo": {
    "type": "float",
    "default": "0.0",
    "section": "Calculation Modes::Optimal Control",
    "description": "The algorithm tries to obtain the specified fluence for the laser field. This works only in conjunction with either the WG05 or the straight iteration scheme. If this variable is not present in the input file, by default the code will not attempt a fixed-fluence QOCT run. The same holds if the value given to this variable is exactly zero. If this variable is given a negative value, then the target fluence will be that of the initial laser pulse given as guess in the input file. Note, however, that first the code applies the envelope provided by the <tt>OCTLaserEnvelope</tt> input option, and afterwards it calculates the fluence.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/optimal control/octfixfluenceto/"
  },
  "OCTFixInitialFluence": {
    "type": "logical",
    "default": "yes",
    "section": "Calculation Modes::Optimal Control",
    "description": "By default, when asking for a fixed-fluence optimization (<tt>OCTFixFluenceTo = whatever</tt>), the initial laser guess provided in the input file is scaled to match this fluence. However, you can force the program to use that initial laser as the initial guess, no matter the fluence, by setting <tt>OCTFixInitialFluence = no</tt>.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/optimal control/octfixinitialfluence/"
  },
  "OCTControlFunctionType": {
    "type": "integer",
    "default": "controlfunction_mode_epsilon",
    "section": "Calculation Modes::Optimal Control",
    "description": "The control function may fully determine the time-dependent form of the external field, or only the envelope function of this external field, or its phase. Or, we may have two different control functions, one of them providing the phase and the other one, the envelope. Note that, if <tt>OCTControlRepresentation = control_function_real_time</tt>, then the control function must <b>always</b> determine the full external field (THIS NEEDS TO BE FIXED).",
    "options": [
      {
        "name": "controlfunction_mode_epsilon",
        "value": "1"
      },
      {
        "name": "controlfunction_mode_f",
        "value": "2"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/optimal control/octcontrolfunctiontype/"
  },
  "OCTPenalty": {
    "type": "float",
    "default": "1.0",
    "section": "Calculation Modes::Optimal Control",
    "description": "The variable specifies the value of the penalty factor for the integrated field strength (fluence). Large value = small fluence. A transient shape can be specified using the block <tt>OCTLaserEnvelope</tt>. In this case <tt>OCTPenalty</tt> is multiplied with time-dependent function. The value depends on the coupling between the states. A good start might be a value from 0.1 (strong fields) to 10 (weak fields). Note that if there are several control functions, one can specify this variable as a one-line code, each column being the penalty factor for each of the control functions. Make sure that the number of columns is equal to the number of control functions. If it is not a block, all control functions will have the same penalty factor. All penalty factors must be positive.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/optimal control/octpenalty/"
  },
  "OCTLaserEnvelope": {
    "type": "block",
    "default": "",
    "section": "Calculation Modes::Optimal Control",
    "description": "Often a pre-defined time-dependent envelope on the control function is desired. This can be achieved by making the penalty factor time-dependent. Here, you may specify the required time-dependent envelope. It is possible to choose different envelopes for different control functions. There should be one line for each control function. Each line should have only one element: a string with the name of a time-dependent function, that should be correspondingly defined in a <tt>TDFunctions</tt> block.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/optimal control/octlaserenvelope/"
  },
  "OCTOptimizeHarmonicSpectrum": {
    "type": "block",
    "default": "no",
    "section": "Calculation Modes::Optimal Control",
    "description": "(Experimental) If <tt>OCTTargetOperator = oct_tg_hhg</tt>, the target is the harmonic emission spectrum. In that case, you must supply an <tt>OCTOptimizeHarmonicSpectrum</tt> block in the <tt>inp</tt> file. The target is given, in general, by: <math>J_1 = \\int_0^\\infty d\\omega \\alpha(\\omega) H(\\omega)</math>, where <math>H(\\omega)</math> is the harmonic spectrum generated by the system, and <math>\\alpha(\\omega)</math> is some function that determines what exactly we want to optimize. The role of the <tt>OCTOptimizeHarmonicSpectrum</tt> block is to determine this <math>\\alpha(\\omega)</math> function. Currently, this function is defined as: <math>\\alpha(\\omega) = \\sum_{L=1}^{M} \\frac{\\alpha_L}{a_L} \\sqcap( (\\omega - L\\omega_0)/a_L )</math>, where <math>\\omega_0</math> is the carrier frequency. <math>M</math> is the number of columns in the <tt>OCTOptimizeHarmonicSpectrum</tt> block. The values of <i>L</i> will be listed in the first row of this block; <math>\\alpha_L</math> in the second row, and <math>a_L</math> in the third. Example: <tt>%OCTOptimizeHarmonicSpectrum <br>&nbsp;&nbsp;  7    |  9    | 11 <br>&nbsp;&nbsp; -1    |  1    | -1 <br>&nbsp;&nbsp;  0.01 |  0.01 |  0.01 <br>%</tt>",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/optimal control/octoptimizeharmonicspectrum/"
  },
  "OCTHarmonicWeight": {
    "type": "string",
    "default": "\"1\"",
    "section": "Calculation Modes::Optimal Control",
    "description": "(Experimental) If <tt>OCTTargetOperator = oct_tg_plateau</tt>, then the function to optimize is the integral of the harmonic spectrum <math>H(\\omega)</math>, weighted with a function <math>f(\\omega)</math> that is defined as a string here. For example, if you set <tt>OCTHarmonicWeight  = \"step(w-1)\"</tt>, the function to optimize is the integral of <math>step(\\omega-1)*H(\\omega)</math>, <i>i.e.</i> <math>\\int_1^{\\infty} H \\left( \\omega \\right) d\\omega</math>. In practice, it is better if you also set an upper limit, <i>e.g.</i> <math>f(\\omega) = step(\\omega-1) step(2-\\omega)</math>.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/optimal control/octharmonicweight/"
  },
  "MeshIndexType": {
    "type": "integer",
    "default": "idx_cubic",
    "section": "Mesh",
    "description": "Determine index type. Must be the same for restarting a calculation.",
    "options": [
      {
        "name": "idx_cubic",
        "value": "1"
      },
      {
        "name": "idx_hilbert",
        "value": "2"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/mesh/meshindextype/"
  },
  "MeshPartitionVirtualSize": {
    "type": "integer",
    "default": "mesh mpi_grp size",
    "section": "Execution::Parallelization",
    "description": "Gives the possibility to change the partition nodes. Afterward, it crashes.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/parallelization/meshpartitionvirtualsize/"
  },
  "MeshUseTopology": {
    "type": "logical",
    "default": "false",
    "section": "Execution::Parallelization",
    "description": "(experimental) If enabled, <tt>Octopus</tt> will use an MPI virtual topology to map the processors. This can improve performance for certain interconnection systems.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/parallelization/meshusetopology/"
  },
  "PartitionPrint": {
    "type": "logical",
    "default": "true",
    "section": "Execution::Parallelization",
    "description": "(experimental) If disabled, <tt>Octopus</tt> will not compute nor print the partition information, such as local points, no. of neighbours, ghost points and boundary points.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/parallelization/partitionprint/"
  },
  "MeshOrder": {
    "type": "integer",
    "default": "",
    "section": "Execution::Optimization",
    "description": "This variable controls how the grid points are mapped to a linear array for global arrays. For runs that are parallel in domains, the local mesh order may be different (see <tt>MeshLocalOrder</tt>). The default is blocks when serial in domains and cube when parallel in domains with the local mesh order set to blocks.",
    "options": [
      {
        "name": "order_blocks",
        "value": "1"
      },
      {
        "name": "order_original",
        "value": "2"
      },
      {
        "name": "order_cube",
        "value": "3"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/optimization/meshorder/"
  },
  "MeshBlockDirection": {
    "type": "integer",
    "default": "",
    "section": "Execution::Optimization",
    "description": "Determines the direction in which the dimensions are chosen to compute the blocked index for sorting the mesh points (see MeshBlockSize). The default is increase_with_dimensions, corresponding to xyz ordering in 3D.",
    "options": [
      {
        "name": "increase_with_dimension",
        "value": "1"
      },
      {
        "name": "decrease_with_dimension",
        "value": "2"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/optimization/meshblockdirection/"
  },
  "MeshBlockSize": {
    "type": "block",
    "default": "",
    "section": "Execution::Optimization",
    "description": "To improve memory-access locality when calculating derivatives, <tt>Octopus</tt> arranges mesh points in blocks. This variable controls the size of this blocks in the different directions. The default is selected according to the value of the <tt>StatesBlockSize</tt> variable. (This variable only affects the performance of <tt>Octopus</tt> and not the results.)",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/optimization/meshblocksize/"
  },
  "Volume": {
    "type": "block",
    "default": "",
    "section": "Utilities::",
    "description": "Describes a volume in space defined through the addition and substraction of spheres. The first field is always \"+\" (include points inside the volume) or \"-\" (exclude points inside the volume)",
    "options": [
      {
        "name": "vol_sphere",
        "value": "10001"
      },
      {
        "name": "vol_slab",
        "value": "10002"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities//volume/"
  },
  "DerivativesStencil": {
    "type": "integer",
    "default": "stencil_star",
    "section": "Mesh::Derivatives",
    "description": "Decides what kind of stencil is used, <i>i.e.</i> which points, around each point in the mesh, are the neighboring points used in the expression of the differential operator. If curvilinear coordinates are to be used, then only the <tt>stencil_starplus</tt> or the <tt>stencil_cube</tt> may be used. We only recommend the <tt>stencil_starplus</tt>, since the cube typically needs far too much memory.",
    "options": [
      {
        "name": "stencil_star",
        "value": "1"
      },
      {
        "name": "stencil_variational",
        "value": "2"
      },
      {
        "name": "stencil_cube",
        "value": "3"
      },
      {
        "name": "stencil_starplus",
        "value": "4"
      },
      {
        "name": "stencil_stargeneral",
        "value": "5"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/mesh/derivatives/derivativesstencil/"
  },
  "DerivativesOrder": {
    "type": "integer",
    "default": "4",
    "section": "Mesh::Derivatives",
    "description": "This variable gives the discretization order for the approximation of the differential operators. This means, basically, that <tt>DerivativesOrder</tt> points are used in each positive/negative spatial direction, <i>e.g.</i> <tt>DerivativesOrder = 1</tt> would give the well-known three-point formula in 1D. The number of points actually used for the Laplacian depends on the stencil used. Let <math>O</math> = <tt>DerivativesOrder</tt>, and <math>d</math> = <tt>Dimensions</tt>. <ul> <li> <tt>stencil_star</tt>: <math>2 O d + 1</math> <li> <tt>stencil_cube</tt>: <math>(2 O + 1)^d</math> <li> <tt>stencil_starplus</tt>: <math>2 O d + 1 + n</math> with <i>n</i> being 8 in 2D and 24 in 3D. </ul>",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/mesh/derivatives/derivativesorder/"
  },
  "ParallelizationOfDerivatives": {
    "type": "integer",
    "default": "non_blocking",
    "section": "Execution::Parallelization",
    "description": "This option selects how the communication of mesh boundaries is performed.",
    "options": [
      {
        "name": "blocking",
        "value": "1"
      },
      {
        "name": "non_blocking",
        "value": "2"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/parallelization/parallelizationofderivatives/"
  },
  "MultigridLevels": {
    "type": "integer",
    "default": "max_levels",
    "section": "Mesh",
    "description": "Number of levels in the grid hierarchy used for multigrid. Positive numbers indicate an absolute number of levels, negative numbers are subtracted from the maximum number of levels possible.",
    "options": [
      {
        "name": "max_levels",
        "value": "0"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/mesh/multigridlevels/"
  },
  "MultigridDerivativesOrder": {
    "type": "integer",
    "default": "1",
    "section": "Mesh::Derivatives",
    "description": "This variable gives the discretization order for the approximation of the differential operators on the different levels of the multigrid. For more details, see the variable DerivativesOrder.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/mesh/derivatives/multigridderivativesorder/"
  },
  "CurvGygiA": {
    "type": "float",
    "default": "0.5",
    "section": "Mesh::Curvilinear::Gygi",
    "description": "The grid spacing is reduced locally around each atom, and the reduction is given by 1/(1+<i>A</i>), where <i>A</i> is specified by this variable. So, if <i>A</i>=1/2 (the default), the grid spacing is reduced to two thirds = 1/(1+1/2). [This is the <math>A_{\\alpha}</math> variable in Eq. 2 of F. Gygi and G. Galli, <i>Phys. Rev. B</i> <b>52</b>, R2229 (1995)]. It must be larger than zero.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/mesh/curvilinear/gygi/curvgygia/"
  },
  "CurvGygiAlpha": {
    "type": "float",
    "default": "2.0 a.u.",
    "section": "Mesh::Curvilinear::Gygi",
    "description": "This number determines the region over which the grid is enhanced (range of enhancement of the resolution). That is, the grid is enhanced on a sphere around each atom, whose radius is given by this variable. [This is the <math>a_{\\alpha}</math> variable in Eq. 2 of F. Gygi and G. Galli, <i>Phys. Rev. B</i> <b>52</b>, R2229 (1995)]. It must be larger than zero.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/mesh/curvilinear/gygi/curvgygialpha/"
  },
  "CurvGygiBeta": {
    "type": "float",
    "default": "4.0 a.u.",
    "section": "Mesh::Curvilinear::Gygi",
    "description": "This number determines the distance over which Euclidean coordinates are recovered. [This is the <math>b_{\\alpha}</math> variable in Eq. 2 of F. Gygi and G. Galli, <i>Phys. Rev. B</i> <b>52</b>, R2229 (1995)]. It must be larger than zero.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/mesh/curvilinear/gygi/curvgygibeta/"
  },
  "RestartOptions": {
    "type": "block",
    "default": "",
    "section": "Execution::IO",
    "description": "<tt>Octopus</tt> usually stores binary information, such as the wavefunctions, to be used in subsequent calculations. The most common example is the ground-state states that are used to start a time-dependent calculation. This variable allows to control where this information is written to or read from. The format of this block is the following: for each line, the first column indicates the type of data, the second column indicates the path to the directory that should be used to read and write that restart information, and the third column, which is optional, allows one to set some flags to modify the way how the data is read or written. For example, if you are running a time-dependent calculation, you can indicate where <tt>Octopus</tt> can find the ground-state information in the following way: <tt>%RestartOptions <br>&nbsp;&nbsp;restart_gs | \"gs_restart\" <br>&nbsp;&nbsp;restart_td | \"td_restart\" <br>%</tt> The second line of the above example also tells <tt>Octopus</tt> that the time-dependent restart data should be read from and written to the \"td_restart\" directory. In case you want to change the path of all the restart directories, you can use the <tt>restart_all</tt> option. When using the <tt>restart_all</tt> option, it is still possible to have a different restart directory for specific data types. For example, when including the following block in your input file: <tt>%RestartOptions <br>&nbsp;&nbsp;restart_all | \"my_restart\" <br>&nbsp;&nbsp;restart_td&nbsp;  | \"td_restart\" <br>%</tt> the time-dependent restart information will be stored in the \"td_restart\" directory, while all the remaining restart information will be stored in the \"my_restart\" directory. By default, the name of the \"restart_all\" directory is set to \"restart\". Some <tt>CalculationMode</tt>s also take into account specific flags set in the third column of the <tt>RestartOptions</tt> block. These are used to determine if some specific part of the restart data is to be taken into account or not when reading the restart information. For example, when restarting a ground-state calculation, one can set the <tt>restart_rho</tt> flags, so that the density used is not built from the saved wavefunctions, but is instead read from the restart directory. In this case, the block should look like this: <tt>%RestartOptions <br>&nbsp;&nbsp;restart_gs | \"restart\" | restart_rho <br>%</tt> A list of available flags is given below, but note that the code might ignore some of them, which will happen if they are not available for that particular calculation, or might assume some of them always present, which will happen in case they are mandatory. Finally, note that all the restart information of a given data type is always stored in a subdirectory of the specified path. The name of this subdirectory is fixed and cannot be changed. For example, ground-state information will always be stored in a subdirectory named \"gs\". This makes it safe in most situations to use the same path for all the data types. The name of these subdirectories is indicated in the description of the data types below. Currently, the available restart data types and flags are the following:",
    "options": [
      {
        "name": "restart_all",
        "value": "0"
      },
      {
        "name": "restart_gs",
        "value": "1"
      },
      {
        "name": "restart_unocc",
        "value": "2"
      },
      {
        "name": "restart_td",
        "value": "3"
      },
      {
        "name": "restart_em_resp",
        "value": "4"
      },
      {
        "name": "restart_em_resp_fd",
        "value": "5"
      },
      {
        "name": "restart_kdotp",
        "value": "6"
      },
      {
        "name": "restart_vib_modes",
        "value": "7"
      },
      {
        "name": "restart_vdw",
        "value": "8"
      },
      {
        "name": "restart_casida",
        "value": "9"
      },
      {
        "name": "restart_oct",
        "value": "10"
      },
      {
        "name": "restart_partition",
        "value": "11"
      },
      {
        "name": "restart_proj",
        "value": "12"
      },
      {
        "name": "restart_states",
        "value": "1"
      },
      {
        "name": "restart_rho",
        "value": "2"
      },
      {
        "name": "restart_vhxc",
        "value": "4"
      },
      {
        "name": "restart_mix",
        "value": "8"
      },
      {
        "name": "restart_skip",
        "value": "16"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/io/restartoptions/"
  },
  "RestartWrite": {
    "type": "logical",
    "default": "true",
    "section": "Execution::IO",
    "description": "If this variable is set to no, restart information is not written. Note that some run modes will ignore this option and write some restart information anyway.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/io/restartwrite/"
  },
  "Spacing": {
    "type": "float",
    "default": "",
    "section": "Mesh",
    "description": "The spacing between the points in the mesh. This controls the quality of the discretization: smaller spacing gives more precise results but increased computational cost. When using curvilinear coordinates, this is a canonical spacing that will be changed locally by the transformation. In periodic directions, your spacing may be slightly different than what you request here, since the box size must be an integer multiple of the spacing. The default value is defined by the species if only default pseudopotentials are used or by the image resolution if <tt>BoxShape = box_image</tt>. Otherwise, there is no default. It is possible to have a different spacing in each one of the Cartesian directions if we define <tt>Spacing</tt> as block of the form <tt>%Spacing <br>&nbsp;&nbsp;spacing_x | spacing_y | spacing_z <br>%</tt>",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/mesh/spacing/"
  },
  "PeriodicBoundaryMask": {
    "type": "block",
    "default": "",
    "section": "Mesh",
    "description": "(Experimental) Defines a mask for which periodic boundaries are replaced by zero boundary conditions.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/mesh/periodicboundarymask/"
  },
  "CurvMethod": {
    "type": "integer",
    "default": "curv_uniform",
    "section": "Mesh::Curvilinear",
    "description": "The relevant functions in octopus are represented on a mesh in real space. This mesh may be an evenly spaced regular rectangular grid (standard mode), or else an adaptive or curvilinear grid. We have implemented three kinds of adaptive meshes, although only one is currently working, the one invented by F. Gygi (<tt>curv_gygi</tt>). The code will stop if any of the other two is invoked. All are experimental with domain parallelization.",
    "options": [
      {
        "name": "curv_affine",
        "value": "1"
      },
      {
        "name": "curv_gygi",
        "value": "2"
      },
      {
        "name": "curv_briggs",
        "value": "3"
      },
      {
        "name": "curv_modine",
        "value": "4"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/mesh/curvilinear/curvmethod/"
  },
  "OperateDouble": {
    "type": "integer",
    "default": "optimized",
    "section": "Execution::Optimization",
    "description": "This variable selects the subroutine used to apply non-local operators over the grid for real functions.",
    "options": [
      {
        "name": "fortran",
        "value": "0"
      },
      {
        "name": "optimized",
        "value": "1"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/optimization/operatedouble/"
  },
  "OperateComplex": {
    "type": "integer",
    "default": "optimized",
    "section": "Execution::Optimization",
    "description": "This variable selects the subroutine used to apply non-local operators over the grid for complex functions.",
    "options": [
      {
        "name": "fortran",
        "value": "0"
      },
      {
        "name": "optimized",
        "value": "1"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/optimization/operatecomplex/"
  },
  "OperateAccel": {
    "type": "integer",
    "default": "map",
    "section": "Execution::Optimization",
    "description": "This variable selects the subroutine used to apply non-local operators over the grid when an accelerator device is used.",
    "options": [
      {
        "name": "invmap",
        "value": "1"
      },
      {
        "name": "map",
        "value": "2"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/optimization/operateaccel/"
  },
  "NLOperatorCompactBoundaries": {
    "type": "logical",
    "default": "no",
    "section": "Execution::Optimization",
    "description": "(Experimental) When set to yes, for finite systems Octopus will map boundary points for finite-differences operators to a few memory locations. This increases performance, however it is experimental and has not been thoroughly tested.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/optimization/nloperatorcompactboundaries/"
  },
  "Output": {
    "type": "block",
    "default": "none",
    "section": "Output",
    "description": "Specifies what to print. Each output must be in a separate row. Optionally individual output formats and output intervals can be defined for each row or they can be read separately from <tt>OutputFormat</tt> and <tt>OutputInterval</tt> variables in the input file. The output files are written at the end of the run into the output directory for the relevant kind of run (<i>e.g.</i> <tt>static</tt> for <tt>CalculationMode = gs</tt>). Time-dependent simulations print only per iteration, including always the last. The frequency of output per iteration (available for <tt>CalculationMode</tt> = <tt>gs</tt>, <tt>unocc</tt>,  <tt>td</tt>, and <tt>opt_control</tt>) is set by <tt>OutputInterval</tt> and the directory is set by <tt>OutputIterDir</tt>. For linear-response run modes, the derivatives of many quantities can be printed, as listed in the options below. Indices in the filename are labelled as follows: <tt>sp</tt> = spin (or spinor component), <tt>k</tt> = <i>k</i>-point, <tt>st</tt> = state/band. There is no tag for directions, given as a letter. The perturbation direction is always the last direction for linear-response quantities, and a following +/- indicates the sign of the frequency. Example (minimal): <br><br><tt>%Output <br>&nbsp;&nbsp;density <br>&nbsp;&nbsp;potential <br>%<br></tt> Example (with OutputFormat): <br><br><tt>%Output <br>&nbsp;&nbsp;density   | cube + axis_z <br>&nbsp;&nbsp;potential | cube <br>%<br></tt> Example (with OutputFormat, incomplete): <br><br><tt>%Output <br>&nbsp;&nbsp;density   | cube + axis_z <br>&nbsp;&nbsp;potential <br>%<br></tt> Example (tagged): <br><br><tt>%Output <br>&nbsp;&nbsp;density   | \"output_format\" | cube + axis_z | \"output_interval\" | 50 <br>&nbsp;&nbsp;potential | \"output_format\" | cube          | \"output_interval\" | 20 <br>%<br></tt> Example (tagged, incomplete): <br><br><tt>%Output <br>&nbsp;&nbsp;density   | \"output_format\"   | cube + axis_z <br>&nbsp;&nbsp;potential | \"output_interval\" | 20 <br>%<br></tt> Missing information for the incomplete blocks will be parsed form the out-of-block definitions. It is also possible to mix the order of columns in the tagged format. See <tt>OutputFormat</tt>, and <tt>OutputInterval</tt>.",
    "options": [
      {
        "name": "potential",
        "value": "1"
      },
      {
        "name": "density",
        "value": "2"
      },
      {
        "name": "wfs",
        "value": "3"
      },
      {
        "name": "wfs_sqmod",
        "value": "4"
      },
      {
        "name": "geometry",
        "value": "5"
      },
      {
        "name": "current",
        "value": "6"
      },
      {
        "name": "ELF",
        "value": "7"
      },
      {
        "name": "ELF_basins",
        "value": "8"
      },
      {
        "name": "Bader",
        "value": "9"
      },
      {
        "name": "el_pressure",
        "value": "10"
      },
      {
        "name": "matrix_elements",
        "value": "11"
      },
      {
        "name": "pol_density",
        "value": "12"
      },
      {
        "name": "mesh_r",
        "value": "13"
      },
      {
        "name": "kinetic_energy_density",
        "value": "14"
      },
      {
        "name": "dos",
        "value": "15"
      },
      {
        "name": "tpa",
        "value": "16"
      },
      {
        "name": "forces",
        "value": "17"
      },
      {
        "name": "wfs_fourier",
        "value": "18"
      },
      {
        "name": "xc_density",
        "value": "19"
      },
      {
        "name": "PES_wfs",
        "value": "20"
      },
      {
        "name": "PES_density",
        "value": "21"
      },
      {
        "name": "PES",
        "value": "22"
      },
      {
        "name": "BerkeleyGW",
        "value": "23"
      },
      {
        "name": "delta_perturbation",
        "value": "24"
      },
      {
        "name": "external_td_potential",
        "value": "25"
      },
      {
        "name": "mmb_wfs",
        "value": "26"
      },
      {
        "name": "mmb_den",
        "value": "27"
      },
      {
        "name": "potential_gradient",
        "value": "28"
      },
      {
        "name": "energy_density",
        "value": "29"
      },
      {
        "name": "heat_current",
        "value": "30"
      },
      {
        "name": "photon_correlator",
        "value": "31"
      },
      {
        "name": "J_flow",
        "value": "32"
      },
      {
        "name": "current_kpt",
        "value": "33"
      },
      {
        "name": "density_kpt",
        "value": "34"
      },
      {
        "name": "occ_matrices",
        "value": "35"
      },
      {
        "name": "effectiveU",
        "value": "36"
      },
      {
        "name": "magnetization",
        "value": "37"
      },
      {
        "name": "local_orbitals",
        "value": "38"
      },
      {
        "name": "kanamoriU",
        "value": "39"
      },
      {
        "name": "xc_torque",
        "value": "40"
      },
      {
        "name": "eigenval_kpt",
        "value": "41"
      },
      {
        "name": "stress",
        "value": "42"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/output/output/"
  },
  "OutputFormat": {
    "type": "flag",
    "default": "0",
    "section": "Output",
    "description": "Describes the format of the output files. This variable can also be defined inside the <tt>Output</tt> block. See <tt>Output</tt>. Example: <tt>axis_x + plane_x + dx</tt>",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/output/outputformat/"
  },
  "OutputInterval": {
    "type": "integer",
    "default": "50",
    "section": "Output",
    "description": "The output requested by variable <tt>Output</tt> is written to the directory <tt>OutputIterDir</tt> when the iteration number is a multiple of the <tt>OutputInterval</tt> variable. Subdirectories are named Y.X, where Y is <tt>td</tt>, <tt>scf</tt>, or <tt>unocc</tt>, and X is the iteration number. To use the working directory, specify <tt>\".\"</tt> (Output of restart files is instead controlled by <tt>RestartWriteInterval</tt>.) Must be >= 0. If it is 0, then no output is written. For <tt>gs</tt> and <tt>unocc</tt> calculations, <tt>OutputDuringSCF</tt> must be set too for this output to be produced. This variable can also be defined inside the <tt>Output</tt> block. See <tt>Output</tt>.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/output/outputinterval/"
  },
  "MeshLocalOrder": {
    "type": "integer",
    "default": "blocks",
    "section": "Execution::Optimization",
    "description": "This variable controls how the grid points are mapped to a linear array. This influences the performance of the code.",
    "options": [
      {
        "name": "order_blocks",
        "value": "1"
      },
      {
        "name": "order_cube",
        "value": "3"
      },
      {
        "name": "order_global",
        "value": "4"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/optimization/meshlocalorder/"
  },
  "MeshLocalBlockDirection": {
    "type": "integer",
    "default": "",
    "section": "Execution::Optimization",
    "description": "Determines the direction in which the dimensions are chosen to compute the blocked index for sorting the mesh points (see MeshLocalBlockSize). The default is increase_with_dimensions, corresponding to xyz ordering in 3D.",
    "options": [
      {
        "name": "increase_with_dimension",
        "value": "1"
      },
      {
        "name": "decrease_with_dimension",
        "value": "2"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/optimization/meshlocalblockdirection/"
  },
  "MeshLocalBlockSize": {
    "type": "block",
    "default": "",
    "section": "Execution::Optimization",
    "description": "To improve memory-access locality when calculating derivatives, <tt>Octopus</tt> arranges mesh points in blocks. This variable controls the size of this blocks in the different directions. The default is selected according to the value of the <tt>StatesBlockSize</tt> variable. (This variable only affects the performance of <tt>Octopus</tt> and not the results.)",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/optimization/meshlocalblocksize/"
  },
  "SpiralBoundaryCondition": {
    "type": "logical",
    "default": "no",
    "section": "Mesh",
    "description": "(Experimental) If set to yes, Octopus will apply spin-spiral boundary conditions. The momentum of the spin spiral is defined by the variable <tt>TDMomentumTransfer</tt>",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/mesh/spiralboundarycondition/"
  },
  "CurvModineXBar": {
    "type": "float",
    "default": "1/3",
    "section": "Mesh::Curvilinear::Modine",
    "description": "Size of central flat region (in units of <tt>Lsize</tt>). Must be between 0 and 1. See N. A. Modine, G. Zumbach, and E. Kaxiras, <i>Phys. Rev. B</i> <b>55</b>, 10289-10301 (1997).",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/mesh/curvilinear/modine/curvmodinexbar/"
  },
  "CurvModineJBar": {
    "type": "float",
    "default": "1/2",
    "section": "Mesh::Curvilinear::Modine",
    "description": "Increase in density of points is inverse of this parameter. See N. A. Modine, G. Zumbach, and E. Kaxiras, <i>Phys. Rev. B</i> <b>55</b>, 10289-10301 (1997).",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/mesh/curvilinear/modine/curvmodinejbar/"
  },
  "CurvModineJlocal": {
    "type": "float",
    "default": "0.25",
    "section": "Mesh::Curvilinear::Modine",
    "description": "Local refinement around the atoms. Must be between 0 and 1. See N. A. Modine, G. Zumbach, and E. Kaxiras, <i>Phys. Rev. B</i> <b>55</b>, 10289-10301 (1997).",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/mesh/curvilinear/modine/curvmodinejlocal/"
  },
  "CurvModineJrange": {
    "type": "float",
    "default": "2 b",
    "section": "Mesh::Curvilinear::Modine",
    "description": "Local refinement range (a length). See N. A. Modine, G. Zumbach, and E. Kaxiras, <i>Phys. Rev. B</i> <b>55</b>, 10289-10301 (1997).",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/mesh/curvilinear/modine/curvmodinejrange/"
  },
  "MeshPartitionPackage": {
    "type": "integer",
    "default": "",
    "section": "Execution::Parallelization",
    "description": "Decides which library to use to perform the mesh partition. By default ParMETIS is used when available, otherwise METIS is used.",
    "options": [
      {
        "name": "metis",
        "value": "1"
      },
      {
        "name": "parmetis",
        "value": "2"
      },
      {
        "name": "part_hilbert",
        "value": "3"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/parallelization/meshpartitionpackage/"
  },
  "MeshPartitionStencil": {
    "type": "integer",
    "default": "stencil_star",
    "section": "Execution::Parallelization",
    "description": "To partition the mesh, it is necessary to calculate the connection graph connecting the points. This variable selects which stencil is used to do this.",
    "options": [
      {
        "name": "stencil_star",
        "value": "1"
      },
      {
        "name": "laplacian",
        "value": "2"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/parallelization/meshpartitionstencil/"
  },
  "MeshPartition": {
    "type": "integer",
    "default": "",
    "section": "Execution::Parallelization",
    "description": "When using METIS to perform the mesh partitioning, decides which algorithm is used. By default, <tt>graph</tt> partitioning is used for 8 or more partitions, and <tt>rcb</tt> for fewer.",
    "options": [
      {
        "name": "rcb",
        "value": "1"
      },
      {
        "name": "graph",
        "value": "2"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/parallelization/meshpartition/"
  },
  "Dimensions": {
    "type": "integer",
    "default": "3",
    "section": "System",
    "description": "<tt>Octopus</tt> can run in 1, 2 or 3 dimensions, depending on the value of this variable (or more, if configured with <tt>--with-max-dim=4</tt> or higher). Note that not all input variables may be available in all cases.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/system/dimensions/"
  },
  "PeriodicDimensions": {
    "type": "integer",
    "default": "0",
    "section": "System",
    "description": "Define how many directions are to be considered periodic. It has to be a number between zero and <tt>Dimensions</tt>.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/system/periodicdimensions/"
  },
  "Debug": {
    "type": "flag",
    "default": "no",
    "section": "Execution::Debug",
    "description": "This variable controls the amount of debugging information generated by Octopus. You can use include more than one option with the + operator.",
    "options": [
      {
        "name": "no",
        "value": "0"
      },
      {
        "name": "info",
        "value": "1"
      },
      {
        "name": "trace",
        "value": "2"
      },
      {
        "name": "trace_term",
        "value": "4"
      },
      {
        "name": "trace_file",
        "value": "8"
      },
      {
        "name": "extra_checks",
        "value": "16"
      },
      {
        "name": "interaction_graph",
        "value": "32"
      },
      {
        "name": "interaction_graph_full",
        "value": "64"
      },
      {
        "name": "propagation_graph",
        "value": "128"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/debug/debug/"
  },
  "MPIDebugHook": {
    "type": "logical",
    "default": "no",
    "section": "Execution::Debug",
    "description": "When debugging the code in parallel it is usually difficult to find the origin of race conditions that appear in MPI communications. This variable introduces a facility to control separate MPI processes. If set to yes, all nodes will start up, but will get trapped in an endless loop. In every cycle of the loop each node is sleeping for one second and is then checking if a file with the name <tt>node_hook.xxx</tt> (where <tt>xxx</tt> denotes the node number) exists. A given node can only be released from the loop if the corresponding file is created. This allows to selectively run, <i>e.g.</i>, a compute node first followed by the master node. Or, by reversing the file creation of the node hooks, to run the master first followed by a compute node.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/debug/mpidebughook/"
  },
  "Units": {
    "type": "virtual",
    "default": "atomic",
    "section": "Execution::Units",
    "description": "(Virtual) These are the units that can be used in the input file.",
    "options": [
      {
        "name": "angstrom",
        "value": "1"
      },
      {
        "name": "pm",
        "value": "0"
      },
      {
        "name": "picometer",
        "value": "0"
      },
      {
        "name": "nm",
        "value": "18"
      },
      {
        "name": "nanometer",
        "value": "18"
      },
      {
        "name": "ry",
        "value": "0"
      },
      {
        "name": "rydberg",
        "value": "0"
      },
      {
        "name": "ev",
        "value": "0"
      },
      {
        "name": "electronvolt",
        "value": "0"
      },
      {
        "name": "invcm",
        "value": "4"
      },
      {
        "name": "kelvin",
        "value": "3"
      },
      {
        "name": "kjoule_mol",
        "value": "0"
      },
      {
        "name": "kcal_mol",
        "value": "0"
      },
      {
        "name": "as",
        "value": "0"
      },
      {
        "name": "attosecond",
        "value": "0"
      },
      {
        "name": "fs",
        "value": "41"
      },
      {
        "name": "femtosecond",
        "value": "41"
      },
      {
        "name": "ps",
        "value": "41341"
      },
      {
        "name": "picosecond",
        "value": "41341"
      },
      {
        "name": "c",
        "value": "137"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/units/units/"
  },
  "UnitsOutput": {
    "type": "integer",
    "default": "atomic",
    "section": "Execution::Units",
    "description": "This variable selects the units that Octopus use for output. Atomic units seem to be the preferred system in the atomic and molecular physics community. Internally, the code works in atomic units. However, for output, some people like to use a system based on electron-Volts (eV) for energies and Angstroms (&Aring;) for length. Normally time units are derived from energy and length units, so it is measured in <math>\\hbar</math>/Hartree or <math>\\hbar</math>/eV. Warning 1: All files read on input will also be treated using these units, including XYZ geometry files. Warning 2: Some values are treated in their most common units, for example atomic masses (a.m.u.), electron effective masses (electron mass), vibrational frequencies (cm<sup>-1</sup>) or temperatures (Kelvin). The unit of charge is always the electronic charge <i>e</i>.",
    "options": [
      {
        "name": "atomic",
        "value": "0"
      },
      {
        "name": "ev_angstrom",
        "value": "1"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/units/unitsoutput/"
  },
  "UnitsXYZFiles": {
    "type": "integer",
    "default": "angstrom_units",
    "section": "Execution::Units",
    "description": "This variable selects in which units I/O of XYZ files should be performed.",
    "options": [
      {
        "name": "bohr_units",
        "value": "0"
      },
      {
        "name": "angstrom_units",
        "value": "1"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/units/unitsxyzfiles/"
  },
  "ReorderRanks": {
    "type": "logical",
    "default": "no",
    "section": "Execution::Parallelization",
    "description": "This variable controls whether the ranks are reorganized to have a more compact distribution with respect to domain parallelization which needs to communicate most often. Depending on the system, this can improve communication speeds.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/parallelization/reorderranks/"
  },
  "ParDomains": {
    "type": "integer",
    "default": "auto",
    "section": "Execution::Parallelization",
    "description": "This variable controls the number of processors used for the parallelization in domains. The special value <tt>auto</tt>, the default, lets Octopus decide how many processors will be assigned for this strategy. To disable parallelization in domains, you can use <tt>ParDomains = no</tt> (or set the number of processors to 1). The total number of processors required is the multiplication of the processors assigned to each parallelization strategy.",
    "options": [
      {
        "name": "no",
        "value": "0"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/parallelization/pardomains/"
  },
  "ParStates": {
    "type": "integer",
    "default": "",
    "section": "Execution::Parallelization",
    "description": "This variable controls the number of processors used for the parallelization in states. The special value <tt>auto</tt> lets Octopus decide how many processors will be assigned for this strategy. To disable parallelization in states, you can use <tt>ParStates = no</tt> (or set the number of processors to 1). The default value depends on the <tt>CalculationMode</tt>. For <tt>CalculationMode = td</tt> the default is <tt>auto</tt>, while for for other modes the default is <tt>no</tt>. The total number of processors required is the multiplication of the processors assigned to each parallelization strategy.",
    "options": [
      {
        "name": "no",
        "value": "0"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/parallelization/parstates/"
  },
  "ParKPoints": {
    "type": "integer",
    "default": "auto",
    "section": "Execution::Parallelization",
    "description": "This variable controls the number of processors used for the parallelization in K-Points and/or spin. The special value <tt>auto</tt> lets Octopus decide how many processors will be assigned for this strategy. To disable parallelization in KPoints, you can use <tt>ParKPoints = no</tt> (or set the number of processors to 1). The total number of processors required is the multiplication of the processors assigned to each parallelization strategy.",
    "options": [
      {
        "name": "no",
        "value": "0"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/parallelization/parkpoints/"
  },
  "ParOther": {
    "type": "integer",
    "default": "auto",
    "section": "Execution::Parallelization",
    "description": "This variable controls the number of processors used for the 'other' parallelization mode, that is CalculatioMode dependent. For <tt>CalculationMode = casida</tt>, it means parallelization in electron-hole pairs. The special value <tt>auto</tt>, the default, lets Octopus decide how many processors will be assigned for this strategy. To disable parallelization in Other, you can use <tt>ParOther = no</tt> (or set the number of processors to 1). The total number of processors required is the multiplication of the processors assigned to each parallelization strategy.",
    "options": [
      {
        "name": "no",
        "value": "0"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/parallelization/parother/"
  },
  "ParallelizationNumberSlaves": {
    "type": "integer",
    "default": "0",
    "section": "Execution::Parallelization",
    "description": "Slaves are nodes used for task parallelization. The number of such nodes is given by this variable multiplied by the number of domains used in domain parallelization.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/parallelization/parallelizationnumberslaves/"
  },
  "DisableAccel": {
    "type": "logical",
    "default": "yes",
    "section": "Execution::Accel",
    "description": "If Octopus was compiled with OpenCL or CUDA support, it will try to initialize and use an accelerator device. By setting this variable to <tt>yes</tt> you force Octopus not to use an accelerator even it is available.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/accel/disableaccel/"
  },
  "AccelPlatform": {
    "type": "integer",
    "default": "0",
    "section": "Execution::Accel",
    "description": "This variable selects the OpenCL platform that Octopus will use. You can give an explicit platform number or use one of the options that select a particular vendor implementation. Platform 0 is used by default. This variable has no effect for CUDA.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/accel/accelplatform/"
  },
  "AccelDevice": {
    "type": "integer",
    "default": "gpu",
    "section": "Execution::Accel",
    "description": "This variable selects the OpenCL or CUDA accelerator device that Octopus will use. You can specify one of the options below or a numerical id to select a specific device. Values >= 0 select the device to be used. In case of MPI enabled runs devices are distributed in a round robin fashion, starting at this value.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/accel/acceldevice/"
  },
  "AccelBenchmark": {
    "type": "logical",
    "default": "no",
    "section": "Execution::Accel",
    "description": "If this variable is set to yes, Octopus will run some routines to benchmark the performance of the accelerator device.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/accel/accelbenchmark/"
  },
  "CudaAwareMPI": {
    "type": "logical",
    "default": "",
    "section": "Execution::Accel",
    "description": "If Octopus was compiled with CUDA support and MPI support and if the MPI implementation is CUDA-aware (i.e., it supports communication using device pointers), this switch can be set to true to use the CUDA-aware MPI features. The advantage of this approach is that it can do, e.g., peer-to-peer copies between devices without going through the host memory. The default is false, except when the configure switch --enable-cudampi is set, in which case this variable is set to true.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/accel/cudaawarempi/"
  },
  "AllowCPUonly": {
    "type": "logical",
    "default": "",
    "section": "Execution::Accel",
    "description": "In order to prevent waste of resources, the code will normally stop when the GPU is disabled due to incomplete implementations or incompatibilities. AllowCPUonly = yes overrides this and allows the code execution also in these cases.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/accel/allowcpuonly/"
  },
  "InitializeGPUBuffers": {
    "type": "logical",
    "default": "",
    "section": "Execution::Accel",
    "description": "Initialize new GPU buffers to zero on creation (use only for debugging, as it has a performance impact!).",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/accel/initializegpubuffers/"
  },
  "LatticeParameters": {
    "type": "block",
    "default": "",
    "section": "Mesh::Simulation Box",
    "description": "The lattice parameters (a, b, c). This variable is mandatory for periodic systems and is ignored otherwise. When PeriodicDimensions = 3, a second optional line can be used to define the angles between the lattice vectors. If the angles are not provided, then the variable LatticeVectors must be set. The number of parameters specified in the block must be at least equal to the number of periodic dimensions, but it is not mandatory to specify parameters for the non-periodic dimensions (in that case they are set to 1).",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/mesh/simulation box/latticeparameters/"
  },
  "LatticeVectors": {
    "type": "block",
    "default": "simple cubic",
    "section": "Mesh::Simulation Box",
    "description": "Primitive lattice vectors. Vectors are stored in rows. Default: <br><br><tt>%LatticeVectors <br>&nbsp;&nbsp;1.0 | 0.0 | 0.0 <br>&nbsp;&nbsp;0.0 | 1.0 | 0.0 <br>&nbsp;&nbsp;0.0 | 0.0 | 1.0 <br>%<br></tt>",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/mesh/simulation box/latticevectors/"
  },
  "stdout": {
    "type": "string",
    "default": "\"-\"",
    "section": "Execution::IO",
    "description": "The standard output by default goes to, well, to standard output. This can be changed by setting this variable: if you give it a name (other than \"-\") the output stream is printed in that file instead.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/io/stdout/"
  },
  "stderr": {
    "type": "string",
    "default": "\"-\"",
    "section": "Execution::IO",
    "description": "The standard error by default goes to, well, to standard error. This can be changed by setting this variable: if you give it a name (other than \"-\") the output stream is printed in that file instead.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/io/stderr/"
  },
  "WorkDir": {
    "type": "string",
    "default": "\".\"",
    "section": "Execution::IO",
    "description": "By default, all files are written and read from the working directory, <i>i.e.</i> the directory from which the executable was launched. This behavior can be changed by setting this variable. If you set <tt>WorkDir</tt> to a name other than \".\", the following directories are written and read in that directory: <ul> <li>\"casida/\"</li> <li>\"em_resp_fd/\"</li> <li>\"em_resp/\"</li> <li>\"geom/\"</li> <li>\"kdotp/\"</li> <li>\"local.general\"</li> <li>\"pcm/\"</li> <li>\"profiling/\"</li> <li>\"restart/\"</li> <li>\"static/\"</li> <li>\"td.general/\"</li> <li>\"vdw/\"</li> <li>\"vib_modes/\"</li> </ul> Furthermore, some of the debug information (see <tt>Debug</tt>) is also written to <tt>WorkDir</tt> and the non-absolute paths defined in <tt>OutputIterDir</tt> are relative to <tt>WorkDir</tt>.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/io/workdir/"
  },
  "Walltime": {
    "type": "float",
    "default": "0",
    "section": "Execution::IO",
    "description": "Time in minutes before which the restart file will be written. This is to make sure that at least one restart file can be written before the code might be killed to to exceeding the given CPU time. If a finite time (in minutes) is specified, the code will write the restart file when the next iteration (plus the RestartWriteTime) would exceed the given time. A value less than 1 second (1/60 minutes) will disable the timer.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/io/walltime/"
  },
  "RestartWriteTime": {
    "type": "float",
    "default": "5",
    "section": "Execution::IO",
    "description": "The RestartWriteTime (in minutes) will be subtracted from the WallTime to allow time for writing the restart file. In huge calculations, this value should be increased.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/io/restartwritetime/"
  },
  "RestartWallTimePeriod": {
    "type": "float",
    "default": "120",
    "section": "Execution::IO",
    "description": "Period Time (in minutes) at which the restart file will be written. If a finite time (in minutes) is specified, the code will write the restart file every period.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/io/restartwalltimeperiod/"
  },
  "ProfilingMode": {
    "type": "integer",
    "default": "no",
    "section": "Execution::Optimization",
    "description": "Use this variable to run <tt>Octopus</tt> in profiling mode. In this mode <tt>Octopus</tt> records the time spent in certain areas of the code and the number of times this code is executed. These numbers are written in <tt>./profiling.NNN/profiling.nnn</tt> with <tt>nnn</tt> being the node number (<tt>000</tt> in serial) and <tt>NNN</tt> the number of processors. This is mainly for development purposes. Note, however, that <tt>Octopus</tt> should be compiled with <tt>--disable-debug</tt> to do proper profiling. Warning: you may encounter strange results with OpenMP.",
    "options": [
      {
        "name": "no",
        "value": "0"
      },
      {
        "name": "prof_time",
        "value": "1"
      },
      {
        "name": "prof_memory",
        "value": "2"
      },
      {
        "name": "prof_memory_full",
        "value": "4"
      },
      {
        "name": "likwid",
        "value": "8"
      },
      {
        "name": "prof_io",
        "value": "16"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/optimization/profilingmode/"
  },
  "ProfilingAllNodes": {
    "type": "logical",
    "default": "no",
    "section": "Execution::Optimization",
    "description": "This variable controls whether all nodes print the time profiling output. If set to no, the default, only the root node will write the profile. If set to yes, all nodes will print it.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/optimization/profilingallnodes/"
  },
  "MemoryLimit": {
    "type": "integer",
    "default": "-1",
    "section": "Execution::Optimization",
    "description": "If positive, <tt>Octopus</tt> will stop if more memory than <tt>MemoryLimit</tt> is requested (in kb). Note that this variable only works when <tt>ProfilingMode = prof_memory(_full)</tt>.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/optimization/memorylimit/"
  },
  "ProfilingOutputYAML": {
    "type": "logical",
    "default": "no",
    "section": "Execution::Optimization",
    "description": "This variable controls whether the profiling output is additionally written to a YAML file.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/optimization/profilingoutputyaml/"
  },
  "ProfilingOutputTree": {
    "type": "logical",
    "default": "yes",
    "section": "Execution::Optimization",
    "description": "This variable controls whether the profiling output is additionally written as a tree.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/optimization/profilingoutputtree/"
  },
  "ExperimentalFeatures": {
    "type": "logical",
    "default": "no",
    "section": "Execution::Debug",
    "description": "If true, allows the use of certain parts of the code that are still under development and are not suitable for production runs. This should not be used unless you know what you are doing. See details on <a href=http://octopus-code.org/experimental_features>wiki page</a>.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/debug/experimentalfeatures/"
  },
  "DebugTrapSignals": {
    "type": "logical",
    "default": "yes",
    "section": "Execution::Debug",
    "description": "If true, trap signals to handle them in octopus itself and print a custom backtrace. If false, do not trap signals; then, core dumps can be produced or gdb can be used to stop at the point a signal was produced (e.g. a segmentation fault).",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/debug/debugtrapsignals/"
  },
  "SpeciesProjectorSphereThreshold": {
    "type": "float",
    "default": "0.001",
    "section": "System::Species",
    "description": "The pseudopotentials may be composed of a local part, and a linear combination of nonlocal operators. These nonlocal projectors have \"projector\" form, <math> \\left| v \\right> \\left< v \\right| </math> (or, more generally speaking, <math> \\left| u \\right> \\left< v \\right| </math>). These projectors are localized in real space -- that is, the function <math>v</math> has a finite support around the nucleus. This region where the projectors are localized should be small or else the computation time required to operate with them will be very large. In practice, this localization is fixed by requiring the definition of the projectors to be contained in a sphere of a certain radius. This radius is computed by making sure that the absolute value of the projector functions, at points outside the localization sphere, is below a certain threshold. This threshold is set by <tt>SpeciesProjectorSphereThreshold</tt>.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/system/species/speciesprojectorspherethreshold/"
  },
  "AllElectronType": {
    "type": "integer",
    "default": "no",
    "section": "System::Species",
    "description": "Selects the type of all-electron species that applies by default to all atoms. This is not compatible with <tt>PseudopotentialSet</tt>, but it is compatible with the <tt>Species</tt> block.",
    "options": [
      {
        "name": "no",
        "value": "0"
      },
      {
        "name": "full_delta",
        "value": "1"
      },
      {
        "name": "full_gaussian",
        "value": "2"
      },
      {
        "name": "full_anc",
        "value": "3"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/system/species/allelectrontype/"
  },
  "AllElectronSigma": {
    "type": "integer",
    "default": "value for the parameter <tt>gaussian_width</tt>. This is useful",
    "section": "System::Species",
    "description": "for specifying multiple atoms without specifying the species block. The default value is taken from the recommendation in <i>Phys. Rev. B</i> <b>55</b>, 10289 (1997).",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/system/species/allelectronsigma/"
  },
  "AllElectronANCParam": {
    "type": "integer",
    "default": "values for the parameter <tt>anc_a</tt>. This is usefull",
    "section": "System::Species",
    "description": "for specifying multiple atoms without specifying the species block.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/system/species/allelectronancparam/"
  },
  "PseudopotentialSet": {
    "type": "integer",
    "default": "standard",
    "section": "System::Species",
    "description": "Selects the set of pseudopotentials used by default for species not defined in the <tt>Species</tt> block. These sets of pseudopotentials come from different sources. Octopus developers have not validated them. We include them with the code for convenience of the users, but you are expected to check the quality and suitability of the pseudopotential for your application.",
    "options": [
      {
        "name": "none",
        "value": "0"
      },
      {
        "name": "standard",
        "value": "1"
      },
      {
        "name": "sg15",
        "value": "2"
      },
      {
        "name": "hgh_lda",
        "value": "3"
      },
      {
        "name": "hgh_lda_sc",
        "value": "31"
      },
      {
        "name": "hscv_lda",
        "value": "4"
      },
      {
        "name": "hscv_pbe",
        "value": "5"
      },
      {
        "name": "pseudodojo_pbe",
        "value": "100"
      },
      {
        "name": "pseudodojo_lda",
        "value": "103"
      },
      {
        "name": "pseudodojo_pbesol",
        "value": "105"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/system/species/pseudopotentialset/"
  },
  "Species": {
    "type": "block",
    "default": "",
    "section": "System::Species",
    "description": "A species is by definition either an \"ion\" (nucleus + core electrons) described through a pseudopotential, or a model potential. Note that some sets of pseudopotentials are distributed with the code. To use these pseudopotentials, you do not need to define them explicitly in the <tt>Species</tt> block, as default parameters are provided. You can select the set for default pseudopotentials using the <tt>PseudopotentialSet</tt> variable. Additional pseudopotentials can be downloaded from the <a href='http://octopus-code.org/wiki/Pseudopotentials'> octopus homepage</a> or from other sources. Supported norm-conserving pseudopotential formats are detected by the file extension: UPF (<tt>.upf</tt>), PSF (SIESTA, <tt>.psf</tt>), FHI (ABINIT 6, <tt>.fhi</tt>), CPI (Fritz-Haber, <tt>.cpi</tt>), QSO (quantum-simulation.org, for Qbox, <tt>.xml</tt>), HGH (Hartwigsen-Goedecker-Hutter, <tt>.hgh</tt>). PSPIO format can also be used via <tt>species_pspio</tt> if that library is linked. Note: pseudopotentials may only be used in 3D. The format of this block is the following: The first field is a string that defines the name of the species. The second field defines the type of species (the valid options are detailed below). Then a list of parameters follows. The parameters are specified by a first field with the parameter name and the field that follows with the value of the parameter. Some parameters are specific to a certain species while others are accepted by all species. These are <tt>mass</tt>, <tt>max_spacing</tt>, and <tt>min_radius</tt>. These are examples of possible species: <tt>%Species <br>&nbsp;&nbsp;'O'       | species_pseudo         | file | 'O.psf' | lmax |  1 | lloc | 1 <br>&nbsp;&nbsp;'H'       | species_pseudo         | file | '../H.hgh' <br>&nbsp;&nbsp;'Xe'      | species_pseudo         | set | pseudojo_pbe_stringent <br>&nbsp;&nbsp;'C'       | species_pseudo         | file | \"carbon.xml\" <br>&nbsp;&nbsp;'jlm'     | species_jellium        | jellium_radius | 5.0 <br>&nbsp;&nbsp;'rho'     | species_charge_density | density_formula | \"exp(-r/a)\" | mass | 17.0 | valence | 6 <br>&nbsp;&nbsp;'udf'     | species_user_defined   | potential_formula | \"1/2*r^2\" | valence | 8 <br>&nbsp;&nbsp;'He_all'  | species_full_delta <br>&nbsp;&nbsp;'H_all'   | species_full_gaussian  |  gaussian_width |  0.2 <br>&nbsp;&nbsp;'Li1D'    | species_soft_coulomb   |  softening | 1.5 | valence | 3 <br>&nbsp;&nbsp;'H_all'   | species_full_anc       |  anc_a | 4 <br>%</tt>",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/system/species/species/"
  },
  "DensitytoCalc": {
    "type": "block",
    "default": "",
    "section": "States::ModelMB",
    "description": "Choice of which particle density (event. matrices) will be calculated and output, in the modelmb particles scheme. <tt>%DensitytoCalc <br>&nbsp;&nbsp; \"proton\"   | 1 | 10 <br>&nbsp;&nbsp; \"electron\" | 2 | 15 <br>%</tt> would ask octopus to calculate the density matrix corresponding to the 1st particle (whose coordinates correspond to dimensions 1 to ndim_modelmb), which is an proton, then that corresponding to the 2nd particle (electron with dimensions ndim_modelmb+1 to 2*ndim_modelmb), printing 10 natural orbitals for the first and 15 for the second. <tt>%DensitytoCalc <br>&nbsp;&nbsp; \"proton\"   | 1 | -1 <br>&nbsp;&nbsp; \"electron\" | 2 | -1 <br>%</tt> would ask octopus to print out just the densities for particles 1 and 2 without any density matrix output.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/states/modelmb/densitytocalc/"
  },
  "SpinComponents": {
    "type": "integer",
    "default": "unpolarized",
    "section": "States",
    "description": "The calculations may be done in three different ways: spin-restricted (TD)DFT (<i>i.e.</i>, doubly occupied \"closed shells\"), spin-unrestricted or \"spin-polarized\" (TD)DFT (<i>i.e.</i> we have two electronic systems, one with spin up and one with spin down), or making use of two-component spinors.",
    "options": [
      {
        "name": "unpolarized",
        "value": "1"
      },
      {
        "name": "polarized",
        "value": "2"
      },
      {
        "name": "spin_polarized",
        "value": "2"
      },
      {
        "name": "non_collinear",
        "value": "3"
      },
      {
        "name": "spinors",
        "value": "3"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/states/spincomponents/"
  },
  "ExcessCharge": {
    "type": "float",
    "default": "0.0",
    "section": "States",
    "description": "The net charge of the system. A negative value means that we are adding electrons, while a positive value means we are taking electrons from the system.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/states/excesscharge/"
  },
  "TotalStates": {
    "type": "integer",
    "default": "0",
    "section": "States",
    "description": "This variable sets the total number of states that Octopus will use. This is normally not necessary since by default Octopus sets the number of states to the minimum necessary to hold the electrons present in the system. (This default behavior is obtained by setting <tt>TotalStates</tt> to 0). If you want to add some unoccupied states, probably it is more convenient to use the variable <tt>ExtraStates</tt>.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/states/totalstates/"
  },
  "ExtraStates": {
    "type": "integer",
    "default": "0",
    "section": "States",
    "description": "The number of states is in principle calculated considering the minimum numbers of states necessary to hold the electrons present in the system. The number of electrons is in turn calculated considering the nature of the species supplied in the <tt>Species</tt> block, and the value of the <tt>ExcessCharge</tt> variable. However, one may command <tt>Octopus</tt> to use more states, which is necessary if one wants to use fractional occupational numbers, either fixed from the beginning through the <tt>Occupations</tt> block or by prescribing an electronic temperature with <tt>Smearing</tt>, or in order to calculate excited states (including with <tt>CalculationMode = unocc</tt>).",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/states/extrastates/"
  },
  "ExtraStatesInPercent": {
    "type": "float",
    "default": "0",
    "section": "States",
    "description": "This variable allows to set the number of extra/empty states as percentage of the used occupied states. For example, a value 35 for ExtraStatesInPercent would amount to int(35/100 * nstates) extra states, where nstates denotes the amount of occupied states Octopus is using for the system at hand.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/states/extrastatesinpercent/"
  },
  "ExtraStatesToConverge": {
    "type": "integer",
    "default": "0",
    "section": "States",
    "description": "Only for unocc calculations. Specifies the number of extra states that will be considered for reaching the convergence. Together with <tt>ExtraStates</tt>, one can have some more states which will not be considered for the convergence criteria, thus making the convergence of the unocc calculation faster. By default, all extra states need to be converged.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/states/extrastatestoconverge/"
  },
  "StatesBlockSize": {
    "type": "integer",
    "default": "",
    "section": "Execution::Optimization",
    "description": "Some routines work over blocks of eigenfunctions, which generally improves performance at the expense of increased memory consumption. This variable selects the size of the blocks to be used. If GPUs are used, the default is 32; otherwise it is 4.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/optimization/statesblocksize/"
  },
  "OnlyUserDefinedInitialStates": {
    "type": "logical",
    "default": "no",
    "section": "States",
    "description": "If true, then only user-defined states from the block <tt>UserDefinedStates</tt> will be used as initial states for a time-propagation. No attempt is made to load ground-state orbitals from a previous ground-state run.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/states/onlyuserdefinedinitialstates/"
  },
  "StatesRandomization": {
    "type": "integer",
    "default": "par_independent",
    "section": "States",
    "description": "The randomization of states can be done in two ways: i) a parallelisation independent way (default), where the random states are identical, irrespectively of the number of tasks and ii) a parallelisation dependent way, which can prevent linear dependency to occur for large systems.",
    "options": [
      {
        "name": "par_independent",
        "value": "1"
      },
      {
        "name": "par_dependent",
        "value": "2"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/states/statesrandomization/"
  },
  "SymmetrizeDensity": {
    "type": "logical",
    "default": "no",
    "section": "States",
    "description": "When enabled the density is symmetrized. Currently, this can only be done for periodic systems. (Experimental.)",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/states/symmetrizedensity/"
  },
  "ForceComplex": {
    "type": "logical",
    "default": "no",
    "section": "Execution::Debug",
    "description": "Normally <tt>Octopus</tt> determines automatically the type necessary for the wavefunctions. When set to yes this variable will force the use of complex wavefunctions. Warning: This variable is designed for testing and benchmarking and normal users need not use it.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/debug/forcecomplex/"
  },
  "RestartFixedOccupations": {
    "type": "logical",
    "default": "yes",
    "section": "States",
    "description": "Setting this variable will make the restart proceed as if the occupations from the previous calculation had been set via the <tt>Occupations</tt> block, <i>i.e.</i> fixed. Otherwise, occupations will be determined by smearing.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/states/restartfixedoccupations/"
  },
  "Occupations": {
    "type": "block",
    "default": "",
    "section": "States",
    "description": "The occupation numbers of the orbitals can be fixed through the use of this variable. For example: <tt>%Occupations <br>&nbsp;&nbsp;2 | 2 | 2 | 2 | 2 <br>%</tt> would fix the occupations of the five states to 2. There can be at most as many columns as states in the calculation. If there are fewer columns than states, then the code will assume that the user is indicating the occupations of the uppermost states where all lower states have full occupation (i.e. 2 for spin-unpolarized calculations, 1 otherwise) and all higher states have zero occupation. The first column will be taken to refer to the lowest state such that the occupations would be consistent with the correct total charge. For example, if there are 8 electrons and 10 states (from <tt>ExtraStates = 6</tt>), then an abbreviated specification <tt>%Occupations <br>&nbsp;&nbsp;1 | 0 | 1 <br>%</tt> would be equivalent to a full specification <tt>%Occupations <br>&nbsp;&nbsp;2 | 2 | 2 | 1 | 0 | 1 | 0 | 0 | 0 | 0 <br>%</tt> This is an example of use for constrained density-functional theory, crudely emulating a HOMO->LUMO+1 optical excitation. The number of rows should be equal to the number of k-points times the number of spins. For example, for a finite system with <tt>SpinComponents == spin_polarized</tt>, this block should contain two lines, one for each spin channel. All rows must have the same number of columns. The <tt>Occupations</tt> block is useful for the ground state of highly symmetric small systems (like an open-shell atom), to fix the occupation numbers of degenerate states in order to help <tt>octopus</tt> to converge. This is to be used in conjuction with <tt>ExtraStates</tt>. For example, to calculate the carbon atom, one would do: <tt>ExtraStates = 2 <br>%Occupations <br>&nbsp;&nbsp;2 | 2/3 | 2/3 | 2/3 <br>%</tt> If you want the calculation to be spin-polarized (which makes more sense), you could do: <tt>ExtraStates = 2 <br>%Occupations <br>&nbsp;&nbsp; 2/3 | 2/3 | 2/3 <br>&nbsp;&nbsp; 0   |   0 |   0 <br>%</tt> Note that in this case the first state is absent, the code will calculate four states (two because there are four electrons, plus two because <tt>ExtraStates</tt> = 2), and since it finds only three columns, it will occupy the first state with one electron for each of the spin options. If the sum of occupations is not equal to the total charge set by <tt>ExcessCharge</tt>, an error message is printed. If <tt>FromScratch = no</tt> and <tt>RestartFixedOccupations = yes</tt>, this block will be ignored.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/states/occupations/"
  },
  "RestartReorderOccs": {
    "type": "logical",
    "default": "no",
    "section": "States",
    "description": "Consider doing a ground-state calculation, and then restarting with new occupations set with the <tt>Occupations</tt> block, in an attempt to populate the orbitals of the original calculation. However, the eigenvalues may reorder as the density changes, in which case the occupations will now be referring to different orbitals. Setting this variable to yes will try to solve this issue when the restart data is being read, by reordering the occupations according to the order of the expectation values of the restart wavefunctions.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/states/restartreorderoccs/"
  },
  "InitialSpins": {
    "type": "block",
    "default": "",
    "section": "States",
    "description": "The spin character of the initial random guesses for the spinors can be fixed by making use of this block. Note that this will not \"fix\" the the spins during the calculation (this cannot be done in spinors mode, in being able to change the spins is why the spinors mode exists in the first place). This block is meaningless and ignored if the run is not in spinors mode (<tt>SpinComponents = spinors</tt>). The structure of the block is very simple: each column contains the desired <math>\\left< S_x \\right>, \\left< S_y \\right>, \\left< S_z \\right> </math> for each spinor. If the calculation is for a periodic system and there is more than one <i>k</i>-point, the spins of all the <i>k</i>-points are the same. For example, if we have two spinors, and we want one in the <math>S_x</math> \"down\" state, and another one in the <math>S_x</math> \"up\" state: <tt>%InitialSpins <br>&nbsp;&nbsp;&nbsp; 0.5 | 0.0 | 0.0 <br>&nbsp;&nbsp; -0.5 | 0.0 | 0.0 <br>%</tt> WARNING: if the calculation is for a system described by pseudopotentials (as opposed to user-defined potentials or model systems), this option is meaningless since the random spinors are overwritten by the atomic orbitals. This constraint must be fulfilled: <br><math> \\left< S_x \\right>^2 + \\left< S_y \\right>^2 + \\left< S_z \\right>^2 = \\frac{1}{4} </math>",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/states/initialspins/"
  },
  "StatesPack": {
    "type": "logical",
    "default": "",
    "section": "Execution::Optimization",
    "description": "When set to yes, states are stored in packed mode, which improves performance considerably. Not all parts of the code will profit from this, but should nevertheless work regardless of how the states are stored. If GPUs are used and this variable is set to yes, Octopus will store the wave-functions in device (GPU) memory. If there is not enough memory to store all the wave-functions, execution will stop with an error. See also the related <tt>HamiltonianApplyPacked</tt> variable. The default is yes.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/optimization/statespack/"
  },
  "StatesOrthogonalization": {
    "type": "integer",
    "default": "",
    "section": "SCF::Eigensolver",
    "description": "The full orthogonalization method used by some eigensolvers. The default is <tt>cholesky_serial</tt>, except with state parallelization, the default is <tt>cholesky_parallel</tt>.",
    "options": [
      {
        "name": "cholesky_serial",
        "value": "1"
      },
      {
        "name": "cholesky_parallel",
        "value": "2"
      },
      {
        "name": "cgs",
        "value": "3"
      },
      {
        "name": "mgs",
        "value": "4"
      },
      {
        "name": "drcgs",
        "value": "5"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/scf/eigensolver/statesorthogonalization/"
  },
  "StatesCLDeviceMemory": {
    "type": "float",
    "default": "-512",
    "section": "Execution::Optimization",
    "description": "This variable selects the amount of OpenCL device memory that will be used by Octopus to store the states. A positive number smaller than 1 indicates a fraction of the total device memory. A number larger than one indicates an absolute amount of memory in megabytes. A negative number indicates an amount of memory in megabytes that would be subtracted from the total device memory.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/optimization/statescldevicememory/"
  },
  "ScaLAPACKCompatible": {
    "type": "logical",
    "default": "",
    "section": "Execution::Parallelization",
    "description": "Whether to use a layout for states parallelization which is compatible with ScaLAPACK. The default is yes for <tt>CalculationMode = gs, unocc, go</tt> without k-point parallelization, and no otherwise. (Setting to other than default is experimental.) The value must be yes if any ScaLAPACK routines are called in the course of the run; it must be set by hand for <tt>td</tt> with <tt>TDDynamics = bo</tt>. This variable has no effect unless you are using states parallelization and have linked ScaLAPACK. Note: currently, use of ScaLAPACK is not compatible with task parallelization (<i>i.e.</i> slaves).",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/parallelization/scalapackcompatible/"
  },
  "CasidaKSEnergyWindow": {
    "type": "float",
    "default": "",
    "section": "Linear Response::Casida",
    "description": "An alternative to <tt>CasidaKohnShamStates</tt> for specifying which occupied-unoccupied transitions will be used: all those whose eigenvalue differences are less than this number will be included. If a value less than 0 is supplied, this criterion will not be used.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/linear response/casida/casidaksenergywindow/"
  },
  "CasidaKohnShamStates": {
    "type": "string",
    "default": "all states",
    "section": "Linear Response::Casida",
    "description": "The calculation of the excitation spectrum of a system in the Casida frequency-domain formulation of linear-response time-dependent density functional theory (TDDFT) implies the use of a basis set of occupied/unoccupied Kohn-Sham orbitals. This basis set should, in principle, include all pairs formed by all occupied states, and an infinite number of unoccupied states. In practice, one has to truncate this basis set, selecting a number of occupied and unoccupied states that will form the pairs. These states are specified with this variable. If there are, say, 15 occupied states, and one sets this variable to the value \"10-18\", this means that occupied states from 10 to 15, and unoccupied states from 16 to 18 will be considered. This variable is a string in list form, <i>i.e.</i> expressions such as \"1,2-5,8-15\" are valid. You should include a non-zero number of unoccupied states and a non-zero number of occupied states.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/linear response/casida/casidakohnshamstates/"
  },
  "SmearingFunction": {
    "type": "integer",
    "default": "semiconducting",
    "section": "States",
    "description": "This is the function used to smear the electronic occupations. It is ignored if the <tt>Occupations</tt> block is set.",
    "options": [
      {
        "name": "semiconducting",
        "value": "1"
      },
      {
        "name": "fermi_dirac",
        "value": "2"
      },
      {
        "name": "cold_smearing",
        "value": "3"
      },
      {
        "name": "methfessel_paxton",
        "value": "4"
      },
      {
        "name": "spline_smearing",
        "value": "5"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/states/smearingfunction/"
  },
  "Smearing": {
    "type": "float",
    "default": "0.1 eV",
    "section": "States",
    "description": "If <tt>Occupations</tt> is not set, <tt>Smearing</tt> is the smearing width used in the <tt>SmearingFunction</tt> to distribute the electrons among the existing states.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/states/smearing/"
  },
  "SmearingMPOrder": {
    "type": "integer",
    "default": "1",
    "section": "States",
    "description": "Sets the order of the Methfessel-Paxton smearing function.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/states/smearingmporder/"
  },
  "MomentumTransfer": {
    "type": "block",
    "default": "",
    "section": "Output",
    "description": "Momentum-transfer vector <math>\\vec{q}</math> to be used when calculating matrix elements <math>\\left< f \\left| e^{i \\vec{q} \\cdot \\vec{r}} \\right| i \\right></math>. This enables the calculation of the dynamical structure factor, which is closely related to generalized oscillator strengths. If the vector is not given, but TPA output is requested (<tt>Output = TPA</tt>), only the oscillator strengths are written in the output file. For example, to use <math>\\vec{q}</math> = (0.1, 0.2, 0.3), set <tt>%MomentumTransfer <br>&nbsp;&nbsp; 0.1 | 0.2 | 0.3 <br>%</tt>",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/output/momentumtransfer/"
  },
  "BandStructureComputeProjections": {
    "type": "logical",
    "default": "false",
    "section": "Output",
    "description": "Determines if projections of wavefunctions on the atomic orbitals are computed or not for obtaining the orbital resolved band-structure.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/output/bandstructurecomputeprojections/"
  },
  "UserDefinedInitialMaxwellStates": {
    "type": "block",
    "default": "",
    "section": "MaxwellStates",
    "description": "The initial electromagnetic fields can be set by the user with the <tt>UserDefinedMaxwellStates</tt> block variable. The electromagnetic fields have to fulfill the Maxwells equations in vacuum. Example: <tt>%UserDefinedMaxwellStates <br>&nbsp;&nbsp; formula | 2 | \"magnetic_field\" | \"-1/P_c * sin(x)\" <br>&nbsp;&nbsp; formula | 3 | \"electric_field\" | \"   sin(x)      \" <br>%</tt> The second column specifies the component of the dimension of the electric field and magnetic field. The first column indicates that column four should be interpreted as a formula for the corresponding state. P_c is the speed of light constant. Alternatively, if column one states <tt>file</tt> the electric field and magnetic field will be read from the files given in column four. <tt>%UserDefinedMaxwellStates <br>&nbsp;&nbsp; file | 3 | electric_field | \"/path/to/file_electric_field_of_dimension_3\" <br>&nbsp;&nbsp; file | 2 | magnetic_field | \"/path/to/file_magnetic_field_of_dimension_2\" <br>%</tt> The third option to define the initial state inside the box is to extend the plane waves used as incident waves in the <tt>MaxwellIncidentWaves</tt> block, as follows: <tt>%UserDefinedMaxwellStates <br>&nbsp;&nbsp; use_incident_waves <br>%</tt>",
    "options": [
      {
        "name": "formula",
        "value": "1"
      },
      {
        "name": "use_incident_waves",
        "value": "2"
      },
      {
        "name": "electric_field",
        "value": "1"
      },
      {
        "name": "magnetic_field",
        "value": "2"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/maxwellstates/userdefinedinitialmaxwellstates/"
  },
  "RiemannSilbersteinSign": {
    "type": "integer",
    "default": "plus",
    "section": "Hamiltonian",
    "description": "Sign for the imaginary part of the Riemann Silberstein vector which represents the magnetic field",
    "options": [
      {
        "name": "plus",
        "value": "1"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/riemannsilbersteinsign/"
  },
  "MaxwellFieldsCoordinate": {
    "type": "block",
    "default": "",
    "section": "Maxwell::Coordinates",
    "description": "The Maxwell MaxwellFieldsCoordinate block allows to output Maxwell fields at particular points in space. For each point a new line with three columns has to be added to the block, where the columns denote the x, y, and z coordinate of the point. <tt>%MaxwellFieldsCoordinate <br>&nbsp;&nbsp;    -1.0 | 2.0 |  4.0 <br>&nbsp;&nbsp;     0.0 | 1.0 | -2.0 <br>%</tt>",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/maxwell/coordinates/maxwellfieldscoordinate/"
  },
  "TransverseFieldCalculation": {
    "type": "integer",
    "default": "no",
    "section": "Maxwell",
    "description": "This variable selects the method for the calculation of the transverse field.",
    "options": [
      {
        "name": "helmholtz",
        "value": "1"
      },
      {
        "name": "total_minus_long",
        "value": "2"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/maxwell/transversefieldcalculation/"
  },
  "NParticleModelmb": {
    "type": "integer",
    "default": " 0",
    "section": "States::ModelMB",
    "description": "Number of particles in modelmb space. Full Ndim = <tt>NDimModelmb</tt>*<tt>NParticleModelmb</tt>",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/states/modelmb/nparticlemodelmb/"
  },
  "NDimModelmb": {
    "type": "integer",
    "default": "1",
    "section": "States::ModelMB",
    "description": "Number of dimensions for modelmb space. Full Ndim = <tt>NDimModelmb</tt>*<tt>NParticleModelmb</tt>",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/states/modelmb/ndimmodelmb/"
  },
  "NTypeParticleModelmb": {
    "type": "integer",
    "default": "1",
    "section": "States::ModelMB",
    "description": "Number of different types of particles in modelmb space.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/states/modelmb/ntypeparticlemodelmb/"
  },
  "DescribeParticlesModelmb": {
    "type": "block",
    "default": "",
    "section": "States::ModelMB",
    "description": "Characterization of different modelmb particles in space%dim dimensional space. <tt>%DescribeParticlesModelmb <br>&nbsp;&nbsp; \"proton\"   | 1 | 1800. | 1. | fermion <br>&nbsp;&nbsp; \"proton\"   | 1 | 1800. | 1. | fermion <br>&nbsp;&nbsp; \"electron\" | 2 | 1.    | 1. | fermion <br>%</tt> would tell <tt>Octopus</tt> that there are presently 3 particles, called proton, proton, and electron, with types 1, 1, and 2, and corresponding masses and charges. All particles should be fermions, and this can be later enforced on the spatial part of the wavefunctions. The label and charge are presently only for informational purposes and are not checked or used in <tt>Octopus</tt>. The interaction has to take the actual charge into account.",
    "options": [
      {
        "name": "fermion",
        "value": "1"
      },
      {
        "name": "boson",
        "value": "2"
      },
      {
        "name": "anyon",
        "value": "3"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/states/modelmb/describeparticlesmodelmb/"
  },
  "UserDefinedStates": {
    "type": "block",
    "default": "",
    "section": "States",
    "description": "Instead of using the ground state as initial state for time-propagations it might be interesting in some cases to specify alternate states. Like with user-defined potentials, this block allows you to specify formulas for the orbitals at <i>t</i>=0. Example: <tt>%UserDefinedStates <br>&nbsp;&nbsp; 1 | 1 | 1 | formula | \"exp(-r^2)*exp(-i*0.2*x)\" | normalize_yes <br>%</tt> The first column specifies the component of the spinor, the second column the number of the state and the third contains <i>k</i>-point and spin quantum numbers. Column four indicates that column five should be interpreted as a formula for the corresponding orbital. Alternatively, if column four states <tt>file</tt> the state will be read from the file given in column five. <tt>%UserDefinedStates <br>&nbsp;&nbsp; 1 | 1 | 1 | file | \"/path/to/file\" | normalize_no <br>%</tt> Octopus reads first the ground-state orbitals from the <tt>restart/gs</tt> directory. Only the states that are specified in the above block will be overwritten with the given analytic expression for the orbital. The sixth (optional) column indicates whether <tt>Octopus</tt> should renormalize the orbital. The default (no sixth column given) is to renormalize.",
    "options": [
      {
        "name": "formula",
        "value": "1"
      },
      {
        "name": "normalize_yes",
        "value": "1"
      },
      {
        "name": "normalize_no",
        "value": "0"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/states/userdefinedstates/"
  },
  "TransformStates": {
    "type": "block",
    "default": "no",
    "section": "States",
    "description": "Before starting the <tt>td</tt> calculation, the initial states (that are read from the <tt>restart/gs</tt> directory, which should have been generated in a previous ground-state calculation) can be \"transformed\" among themselves. The block <tt>TransformStates</tt> gives the transformation matrix to be used. The number of rows and columns of the matrix should equal the number of the states present in the time-dependent calculation (the independent spin and <i>k</i>-point subspaces are all transformed equally); the number of columns should be equal to the number of states present in the <tt>restart/gs</tt> directory. This number may be different: for example, one could have run previously in <tt>unocc</tt> mode in order to obtain unoccupied Kohn-Sham states, and therefore <tt>restart/gs</tt> will contain more states. These states can be used in the transformation. Note that the code will not check the orthonormality of the new states! Each line provides the coefficients of the new states, in terms of the old ones. The coefficients are complex, but the imaginary part will be ignored for real wavefunctions. Note: This variable cannot be used when parallel in states.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/states/transformstates/"
  },
  "CalcNormalModeWfs": {
    "type": "logical",
    "default": "false",
    "section": "Linear Response::Vibrational Modes",
    "description": "If set to true, the response wavefunctions for each normal mode will be calculated and written in directory <tt>restart/vib_modes/phn_nm_wfs_XXXXX</tt>. This part is time-consuming and not parallel, but not needed for most purposes.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/linear response/vibrational modes/calcnormalmodewfs/"
  },
  "CalcInfrared": {
    "type": "logical",
    "default": "true",
    "section": "Linear Response::Vibrational Modes",
    "description": "If set to true, infrared intensities (and born charges) will be calculated and written in <tt>vib_modes/infrared</tt>.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/linear response/vibrational modes/calcinfrared/"
  },
  "SymmetrizeDynamicalMatrix": {
    "type": "logical",
    "default": "true",
    "section": "Linear Response::Vibrational Modes",
    "description": "If set to true, all entries of the dynamical matrix will be calculated and then the matrix will be symmetrized to enforce <math>D_{ij} = D_{ji}</math>. If set to false, only the upper half of the matrix will be calculated.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/linear response/vibrational modes/symmetrizedynamicalmatrix/"
  },
  "vdWNPoints": {
    "type": "integer",
    "default": "6",
    "section": "Linear Response::Polarizabilities",
    "description": "How many points to use in the Gauss-Legendre integration to obtain the van der Waals coefficients.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/linear response/polarizabilities/vdwnpoints/"
  },
  "EMFreqs": {
    "type": "block",
    "default": "",
    "section": "Linear Response::Polarizabilities",
    "description": "This block defines for which frequencies the polarizabilities will be calculated. If it is not present, the static (<math>\\omega = 0</math>) response is calculated. Each row of the block indicates a sequence of frequency values, the first column is an integer that indicates the number of steps, the second number is the initial frequency, and the third number the final frequency. If the first number is one, then only the initial value is considered. The block can have any number of rows. Consider the next example: <tt>%EMFreqs <br>31 | 0.0 | 1.0 <br> 1 | 0.32 <br>%</tt>",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/linear response/polarizabilities/emfreqs/"
  },
  "EMFreqsSort": {
    "type": "logical",
    "default": "true",
    "section": "Linear Response::Polarizabilities",
    "description": "If true, the frequencies specified by the <tt>EMFreqs</tt> block are sorted, so that they are calculated in increasing order. Can be set to false to use the order as stated, in case this makes better use of available restart information.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/linear response/polarizabilities/emfreqssort/"
  },
  "EMEta": {
    "type": "float",
    "default": "0.0",
    "section": "Linear Response::Polarizabilities",
    "description": "The imaginary part of the frequency, effectively a Lorentzian broadening for peaks in the spectrum. It can help convergence of the SCF cycle for the Sternheimer equation when on a resonance, and it can be used as a positive infinitesimal to get the imaginary parts of response functions at poles. In units of energy. Cannot be negative.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/linear response/polarizabilities/emeta/"
  },
  "EMPerturbationType": {
    "type": "integer",
    "default": "electric",
    "section": "Linear Response::Polarizabilities",
    "description": "Which perturbation to consider for electromagnetic linear response.",
    "options": [
      {
        "name": "electric",
        "value": "1"
      },
      {
        "name": "magnetic",
        "value": "2"
      },
      {
        "name": "none",
        "value": "0"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/linear response/polarizabilities/emperturbationtype/"
  },
  "EMCalcRotatoryResponse": {
    "type": "logical",
    "default": "false",
    "section": "Linear Response::Polarizabilities",
    "description": "Calculate circular-dichroism spectrum from electric perturbation, and write to file <tt>rotatory_strength</tt>.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/linear response/polarizabilities/emcalcrotatoryresponse/"
  },
  "EMHyperpol": {
    "type": "block",
    "default": "",
    "section": "Linear Response::Polarizabilities",
    "description": "This block describes the multiples of the frequency used for the dynamic hyperpolarizability. The results are written to the file <tt>beta</tt> in the directory for the first multiple. There must be three factors, summing to zero: <math>\\omega_1 + \\omega_2 + \\omega_3 = 0</math>. For example, for second-harmonic generation, you could use <tt>1 | 1 | -2</tt>.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/linear response/polarizabilities/emhyperpol/"
  },
  "EMCalcMagnetooptics": {
    "type": "logical",
    "default": "false",
    "section": "Linear Response::Polarizabilities",
    "description": "Calculate magneto-optical response.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/linear response/polarizabilities/emcalcmagnetooptics/"
  },
  "EMMagnetoopticsNoHVar": {
    "type": "logical",
    "default": "true",
    "section": "Linear Response::Polarizabilities",
    "description": "Exclude corrections to the exchange-correlation and Hartree terms from consideration of perturbations induced by a magnetic field",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/linear response/polarizabilities/emmagnetoopticsnohvar/"
  },
  "EMKPointOutput": {
    "type": "logical",
    "default": "false",
    "section": "Linear Response::Polarizabilities",
    "description": "Give in the output contributions of different k-points to the dielectric constant. Can be also used for magneto-optical effects.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/linear response/polarizabilities/emkpointoutput/"
  },
  "EMForceNoKdotP": {
    "type": "logical",
    "default": "false",
    "section": "Linear Response::Polarizabilities",
    "description": "If the system is periodic, by default wavefunctions from a previous <tt>kdotp</tt> run will be read, to be used in the formulas for the polarizability and hyperpolarizability in the quantum theory of polarization. For testing purposes, you can set this variable to true to disregard the <tt>kdotp</tt> run, and use the formulas for the finite system. This variable has no effect for a finite system.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/linear response/polarizabilities/emforcenokdotp/"
  },
  "EMCalcBornCharges": {
    "type": "logical",
    "default": "false",
    "section": "Linear Response::Polarizabilities",
    "description": "Calculate linear-response Born effective charges from electric perturbation (experimental).",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/linear response/polarizabilities/emcalcborncharges/"
  },
  "EMOccupiedResponse": {
    "type": "logical",
    "default": "false",
    "section": "Linear Response::Polarizabilities",
    "description": "Solve for full response without projector into unoccupied subspace. Not possible if there are partial occupations. When <tt>EMHyperpol</tt> is set for a periodic system, this variable is ignored and the full response is always calculated.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/linear response/polarizabilities/emoccupiedresponse/"
  },
  "EMWavefunctionsFromScratch": {
    "type": "logical",
    "default": "false",
    "section": "Linear Response::Polarizabilities",
    "description": "Do not use saved linear-response wavefunctions from a previous run as starting guess. Instead initialize to zero as in <tt>FromScratch</tt>, but restart densities will still be used. Restart wavefunctions from a very different frequency can hinder convergence.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/linear response/polarizabilities/emwavefunctionsfromscratch/"
  },
  "KdotPOccupiedSolutionMethod": {
    "type": "integer",
    "default": "sternheimer_eqn",
    "section": "Linear Response::KdotP",
    "description": "Method of calculating the contribution of the projection of the linear-response wavefunctions in the occupied subspace.",
    "options": [
      {
        "name": "sternheimer_eqn",
        "value": "0"
      },
      {
        "name": "sum_over_states",
        "value": "1"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/linear response/kdotp/kdotpoccupiedsolutionmethod/"
  },
  "DegeneracyThreshold": {
    "type": "float",
    "default": "1e-5",
    "section": "States",
    "description": "States with energy <math>E_i</math> and <math>E_j</math> will be considered degenerate if <math> \\left| E_i - E_j \\right| < </math><tt>DegeneracyThreshold</tt>.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/states/degeneracythreshold/"
  },
  "KdotPEta": {
    "type": "float",
    "default": "0.0",
    "section": "Linear Response::KdotP",
    "description": "Imaginary frequency added to Sternheimer equation which may improve convergence. Not recommended.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/linear response/kdotp/kdotpeta/"
  },
  "KdotPCalculateEffectiveMasses": {
    "type": "logical",
    "default": "true",
    "section": "Linear Response::KdotP",
    "description": "If true, uses <tt>kdotp</tt> perturbations of ground-state wavefunctions to calculate effective masses. It is not correct for degenerate states.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/linear response/kdotp/kdotpcalculateeffectivemasses/"
  },
  "KdotPCalcSecondOrder": {
    "type": "logical",
    "default": "false",
    "section": "Linear Response::KdotP",
    "description": "If true, calculates second-order response of wavefunctions as well as first-order response. Note that the second derivative of the Hamiltonian is NOT included in this calculation. This is needed for a subsequent run in <tt>CalculationMode = em_resp</tt> with <tt>EMHyperpol</tt>.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/linear response/kdotp/kdotpcalcsecondorder/"
  },
  "Preorthogonalization": {
    "type": "logical",
    "default": "is true only if <tt>SmearingFunction = semiconducting</tt>,",
    "section": "Linear Response::Sternheimer",
    "description": "Whether initial linear-response wavefunctions should be orthogonalized or not against the occupied states, at the start of each SCF cycle. or if the <tt>Occupations</tt> block specifies all full or empty states, and we are not solving for linear response in the occupied subspace too.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/linear response/sternheimer/preorthogonalization/"
  },
  "HamiltonianVariation": {
    "type": "integer",
    "default": "hartree+fxc",
    "section": "Linear Response::Sternheimer",
    "description": "The terms to be considered in the variation of the Hamiltonian. The external potential (V_ext) is always considered. The default is to include also the exchange-correlation and Hartree terms, which fully takes into account local fields. Just <tt>hartree</tt> gives you the random-phase approximation (RPA). If you want to choose the exchange-correlation kernel, use the variable <tt>XCKernel</tt>. For <tt>kdotp</tt> and magnetic <tt>em_resp</tt> modes, or if <tt>TheoryLevel = independent_particles</tt>, the value <tt>V_ext_only</tt> is used and this variable is ignored.",
    "options": [
      {
        "name": "V_ext_only",
        "value": "0"
      },
      {
        "name": "hartree",
        "value": "1"
      },
      {
        "name": "fxc",
        "value": "2"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/linear response/sternheimer/hamiltonianvariation/"
  },
  "PhotonEta": {
    "type": "float",
    "default": "0.0000367",
    "section": "Linear Response::Sternheimer",
    "description": "This variable provides the value for the broadening of the photonic spectra when the coupling of electrons to photons is enabled in the frequency-dependent Sternheimer equation",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/linear response/sternheimer/photoneta/"
  },
  "CasidaTheoryLevel": {
    "type": "flag",
    "default": "<tt>eps_diff + petersilka + lrtddft_casida</tt>",
    "section": "Linear Response::Casida",
    "description": "Choose which electron-hole matrix-based theory levels to use in calculating excitation energies. More than one may be used to take advantage of the significant commonality between the calculations. <tt>variational</tt> and <tt>lrttdft_casida</tt> are not usable with complex wavefunctions. Note the restart data saved by each theory level is compatible with all the others.",
    "options": [
      {
        "name": "eps_diff",
        "value": "1"
      },
      {
        "name": "petersilka",
        "value": "2"
      },
      {
        "name": "tamm_dancoff",
        "value": "4"
      },
      {
        "name": "variational",
        "value": "8"
      },
      {
        "name": "lrtddft_casida",
        "value": "16"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/linear response/casida/casidatheorylevel/"
  },
  "CasidaTransitionDensities": {
    "type": "string",
    "default": "write none",
    "section": "Linear Response::Casida",
    "description": "Specifies which transition densities are to be calculated and written down. The transition density for the many-body state <i>n</i> will be written to a file called <tt>rho_0n</tt> prefixed by the theory level. Format is set by <tt>OutputFormat</tt>. This variable is a string in list form, <i>i.e.</i> expressions such as \"1,2-5,8-15\" are valid.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/linear response/casida/casidatransitiondensities/"
  },
  "CasidaMomentumTransfer": {
    "type": "block",
    "default": "0",
    "section": "Linear Response::Casida",
    "description": "Momentum-transfer vector for the calculation of the dynamic structure factor. When this variable is set, the transition rates are determined using an exponential operator instead of the normal dipole one.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/linear response/casida/casidamomentumtransfer/"
  },
  "CasidaQuadratureOrder": {
    "type": "integer",
    "default": "5",
    "section": "Linear Response::Casida",
    "description": "Only applies if <tt>CasidaMomentumTransfer</tt> is nonzero. Directionally averaged dynamic structure factor is calculated by averaging over the results from a set of <math>\\vec{q}</math>-vectors. The vectors are generated using Gauss-Legendre quadrature scheme [see <i>e.g.</i> K. Atkinson, <i>J. Austral. Math. Soc.</i> <b>23</b>, 332 (1982)], and this variable determines the order of the scheme.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/linear response/casida/casidaquadratureorder/"
  },
  "CasidaCalcTriplet": {
    "type": "logical",
    "default": "false",
    "section": "Linear Response::Casida",
    "description": "For a non-spin-polarized ground state, singlet or triplet excitations can be calculated using different matrix elements. Default is to calculate singlets. This variable has no effect for a spin-polarized calculation.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/linear response/casida/casidacalctriplet/"
  },
  "CasidaHermitianConjugate": {
    "type": "logical",
    "default": "false",
    "section": "Linear Response::Casida",
    "description": "The Casida matrix is Hermitian, so it should not matter whether we calculate the upper or lower diagonal. Numerical issues may cause small differences however. Use this variable to calculate the Hermitian conjugate of the usual matrix, for testing.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/linear response/casida/casidahermitianconjugate/"
  },
  "CasidaDistributedMatrix": {
    "type": "logical",
    "default": "false",
    "section": "Linear Response::Casida",
    "description": "Large matrices with more than a few thousand rows and columns usually do not fit into the memory of one processor anymore. With this option, the Casida matrix is distributed in block-cyclic fashion over all cores in the ParOther group. The diagonalization is done in parallel using ScaLAPACK or ELPA, if available. For very large matrices (>100000), only the ParOther strategy should be used because the diagonalization dominates the run time of the computation.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/linear response/casida/casidadistributedmatrix/"
  },
  "CasidaWriteDistributedMatrix": {
    "type": "logical",
    "default": "false",
    "section": "Linear Response::Casida",
    "description": "Set to true to write out the full distributed Casida matrix to a file using MPI-IO.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/linear response/casida/casidawritedistributedmatrix/"
  },
  "CasidaParallelEigensolver": {
    "type": "integer",
    "default": "",
    "section": "Linear Response::Casida",
    "description": "Choose library to use for solving the parallel eigenproblem of the Casida problem. This options is only relevant if a distributed matrix is used (CasidaDistributedMatrix=true). By default, elpa is chosen if available.",
    "options": [
      {
        "name": "casida_elpa",
        "value": "1"
      },
      {
        "name": "casida_scalapack",
        "value": "2"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/linear response/casida/casidaparalleleigensolver/"
  },
  "CasidaPrintExcitations": {
    "type": "string",
    "default": "write all",
    "section": "Linear Response::Casida",
    "description": "Specifies which excitations are written at the end of the calculation. This variable is a string in list form, <i>i.e.</i> expressions such as \"1,2-5,8-15\" are valid.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/linear response/casida/casidaprintexcitations/"
  },
  "CasidaWeightThreshold": {
    "type": "float",
    "default": "-1.",
    "section": "Linear Response::Casida",
    "description": "Specifies the threshold value for which the individual excitations are printed. i.e. juste-h pairs with weight larger than this threshold will be printed. If a negative value (default) is set, all coefficients will be printed. For many case, a 0.01 value is a valid option.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/linear response/casida/casidaweightthreshold/"
  },
  "CasidaCalcForces": {
    "type": "logical",
    "default": "false",
    "section": "Linear Response::Casida",
    "description": "(Experimental) Enable calculation of excited-state forces. Requires previous <tt>vib_modes</tt> calculation.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/linear response/casida/casidacalcforces/"
  },
  "CasidaCalcForcesKernel": {
    "type": "logical",
    "default": "true",
    "section": "Linear Response::Casida",
    "description": "If false, the derivative of the kernel will not be included in the excited-state force calculation.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/linear response/casida/casidacalcforceskernel/"
  },
  "CasidaCalcForcesSCF": {
    "type": "logical",
    "default": "false",
    "section": "Linear Response::Casida",
    "description": "If true, the ground-state forces will be included in the excited-state forces, so they are total forces. If false, the excited-state forces that are produced are only the gradients of the excitation energy.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/linear response/casida/casidacalcforcesscf/"
  },
  "InvertKSTargetDensity": {
    "type": "string",
    "default": "<tt>target_density.dat</tt>",
    "section": "Calculation Modes::Invert KS",
    "description": "Name of the file that contains the density used as the target in the inversion of the KS equations.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/invert ks/invertkstargetdensity/"
  },
  "Systems": {
    "type": "block",
    "default": "",
    "section": "System",
    "description": "List of systems that will be treated in the calculation. The first column should be a string containing the system name. The second column should be the system type. See below for a list of available system types.",
    "options": [
      {
        "name": "electronic",
        "value": "1"
      },
      {
        "name": "maxwell",
        "value": "2"
      },
      {
        "name": "classical_particle",
        "value": "3"
      },
      {
        "name": "charged_particle",
        "value": "4"
      },
      {
        "name": "dftbplus",
        "value": "5"
      },
      {
        "name": "linear_medium",
        "value": "6"
      },
      {
        "name": "matter",
        "value": "7"
      },
      {
        "name": "dispersive_medium",
        "value": "8"
      },
      {
        "name": "multisystem",
        "value": "9"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/system/systems/"
  },
  "EMStaticElectricField": {
    "type": "float",
    "default": "0.01 a.u.",
    "section": "Linear Response::Static Polarization",
    "description": "Magnitude of the static electric field used to calculate the static polarizability, if <tt>ResponseMethod = finite_differences</tt>.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/linear response/static polarization/emstaticelectricfield/"
  },
  "EMStartDensityIsZeroField": {
    "type": "logical",
    "default": "true",
    "section": "Linear Response::Static Polarization",
    "description": "Use the charge density from the zero-field calculation as the starting density for SCF calculations with applied fields. For small fields, this will be fastest. If there is trouble converging with larger fields, set to false, to initialize the calculation for each field from scratch, as specified by the LCAO variables. Only applies if <tt>ResponseMethod = finite_differences</tt>.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/linear response/static polarization/emstartdensityiszerofield/"
  },
  "EMCalcDiagonalField": {
    "type": "logical",
    "default": "true",
    "section": "Linear Response::Static Polarization",
    "description": "Calculate <i>yz</i>-field for <math>\\beta_{xyz}</math> hyperpolarizability, which is sometimes harder to converge. Only applies if <tt>ResponseMethod = finite_differences</tt>.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/linear response/static polarization/emcalcdiagonalfield/"
  },
  "EMWriteRestartDensities": {
    "type": "logical",
    "default": "true",
    "section": "Linear Response::Static Polarization",
    "description": "Write density after each calculation for restart, rather than just the resulting electronic dipole moment. Only applies if <tt>ResponseMethod = finite_differences</tt>. Restarting from calculations at smaller fields can be helpful if there are convergence problems.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/linear response/static polarization/emwriterestartdensities/"
  },
  "EMVerbose": {
    "type": "logical",
    "default": "false",
    "section": "Linear Response::Static Polarization",
    "description": "Write full SCF output. Only applies if <tt>ResponseMethod = finite_differences</tt>.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/linear response/static polarization/emverbose/"
  },
  "ResponseMethod": {
    "type": "integer",
    "default": "sternheimer",
    "section": "Linear Response",
    "description": "Some response properties can be calculated either via Sternheimer linear response or by using finite differences. You can use this variable to select how you want them to be calculated, it applies to <tt>em_resp</tt> and <tt>vib_modes</tt> calculation modes. By default, the Sternheimer linear-response technique is used.",
    "options": [
      {
        "name": "sternheimer",
        "value": "1"
      },
      {
        "name": "finite_differences",
        "value": "2"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/linear response/responsemethod/"
  },
  "FromScratch": {
    "type": "logical",
    "default": "false",
    "section": "Execution",
    "description": "When this variable is set to true, <tt>Octopus</tt> will perform a calculation from the beginning, without looking for restart information. NOTE: If available, mesh partitioning information will be used for initializing the calculation regardless of the set value for this variable.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/fromscratch/"
  },
  "GOCenter": {
    "type": "logical",
    "default": "no",
    "section": "Calculation Modes::Geometry Optimization",
    "description": "(Experimental) If set to yes, Octopus centers the geometry at every optimization step. It also reduces the degrees of freedom of the optimization by using the translational invariance.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/geometry optimization/gocenter/"
  },
  "GOMethod": {
    "type": "integer",
    "default": "fire",
    "section": "Calculation Modes::Geometry Optimization",
    "description": "Method by which the minimization is performed. For more information see the <a href=http://www.gnu.org/software/gsl/manual/html_node/Multidimensional-Minimization.html> GSL documentation</a>.",
    "options": [
      {
        "name": "steep",
        "value": "1"
      },
      {
        "name": "cg_fr",
        "value": "2"
      },
      {
        "name": "cg_pr",
        "value": "3"
      },
      {
        "name": "cg_bfgs",
        "value": "4"
      },
      {
        "name": "cg_bfgs2",
        "value": "5"
      },
      {
        "name": "simplex",
        "value": "6"
      },
      {
        "name": "fire",
        "value": "8"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/geometry optimization/gomethod/"
  },
  "GOTolerance": {
    "type": "float",
    "default": "0.001 H/b (0.051 eV/A)",
    "section": "Calculation Modes::Geometry Optimization",
    "description": "Convergence criterion, for stopping the minimization. In units of force; minimization is stopped when all forces on ions are smaller than this criterion, or the <tt>GOMinimumMove</tt> is satisfied. If <tt>GOTolerance < 0</tt>, this criterion is ignored.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/geometry optimization/gotolerance/"
  },
  "GOMinimumMove": {
    "type": "float",
    "default": "is -1, except 0.001 b with <tt>GOMethod = simplex</tt>.",
    "section": "Calculation Modes::Geometry Optimization",
    "description": "Convergence criterion, for stopping the minimization. In units of length; minimization is stopped when the coordinates of all species change less than <tt>GOMinimumMove</tt>, or the <tt>GOTolerance</tt> criterion is satisfied. If <tt>GOMinimumMove < 0</tt>, this criterion is ignored. Note that if you use <tt>GOMethod = simplex</tt>, then you must supply a non-zero <tt>GOMinimumMove</tt>.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/geometry optimization/gominimummove/"
  },
  "GOStep": {
    "type": "float",
    "default": "",
    "section": "Calculation Modes::Geometry Optimization",
    "description": "Initial step for the geometry optimizer. The default is 0.5. WARNING: in some weird units. For the FIRE minimizer, default value is 0.1 fs, and corresponds to the initial time-step for the MD.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/geometry optimization/gostep/"
  },
  "GOLineTol": {
    "type": "float",
    "default": "0.1",
    "section": "Calculation Modes::Geometry Optimization",
    "description": "Tolerance for line-minimization. Applies only to GSL methods that use the forces. WARNING: in some weird units.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/geometry optimization/golinetol/"
  },
  "GOMaxIter": {
    "type": "integer",
    "default": "200",
    "section": "Calculation Modes::Geometry Optimization",
    "description": "Even if the convergence criterion is not satisfied, the minimization will stop after this number of iterations.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/geometry optimization/gomaxiter/"
  },
  "GOFireMass": {
    "type": "float",
    "default": "1.0 amu",
    "section": "Calculation Modes::Geometry Optimization",
    "description": "The Fire algorithm (<tt>GOMethod = fire</tt>) assumes that all degrees of freedom are comparable. All the velocities should be on the same scale,  which  for  heteronuclear  systems  can  be  roughly achieved by setting all the atom masses equal, to the value specified by this variable. By default the mass of a proton is selected (1 amu). However, a selection of <tt>GOFireMass = 0.01</tt> can, in manys systems, speed up the geometry optimization procedure. If <tt>GOFireMass</tt> <= 0, the masses of each species will be used.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/geometry optimization/gofiremass/"
  },
  "GOFireIntegrator": {
    "type": "integer",
    "default": "verlet",
    "section": "Calculation Modes::Geometry Optimization",
    "description": "The Fire algorithm (<tt>GOMethod = fire</tt>) uses a molecular dynamics integrator to compute new geometries and velocities. Currently, two integrator schemes can be selected",
    "options": [
      {
        "name": "verlet",
        "value": "1"
      },
      {
        "name": "euler",
        "value": "0"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/geometry optimization/gofireintegrator/"
  },
  "GOObjective": {
    "type": "integer",
    "default": "minimize_energy",
    "section": "Calculation Modes::Geometry Optimization",
    "description": "This rather esoteric option allows one to choose which objective function to minimize during a geometry minimization. The use of this variable may lead to inconsistencies, so please make sure you know what you are doing.",
    "options": [
      {
        "name": "minimize_energy",
        "value": "1"
      },
      {
        "name": "minimize_forces",
        "value": "2"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/geometry optimization/goobjective/"
  },
  "XYZGOConstrains": {
    "type": "string",
    "default": "",
    "section": "Calculation Modes::Geometry Optimization",
    "description": "<tt>Octopus</tt> will try to read the coordinate-dependent constrains from the XYZ file specified by the variable <tt>XYZGOConstrains</tt>. Note: It is important for the contrains to maintain the ordering in which the atoms were defined in the coordinates specifications. Moreover, constrains impose fixed absolute coordinates, therefore constrains are not compatible with GOCenter = yes",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/geometry optimization/xyzgoconstrains/"
  },
  "XSFGOConstrains": {
    "type": "string",
    "default": "",
    "section": "Calculation Modes::Geometry Optimization",
    "description": "Like <tt>XYZGOConstrains</tt> but in XCrySDen format, as in <tt>XSFCoordinates</tt>.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/geometry optimization/xsfgoconstrains/"
  },
  "PDBGOConstrains": {
    "type": "string",
    "default": "",
    "section": "Calculation Modes::Geometry Optimization",
    "description": "Like <tt>XYZGOConstrains</tt> but in PDB format, as in <tt>PDBCoordinates</tt>.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/geometry optimization/pdbgoconstrains/"
  },
  "GOConstrains": {
    "type": "block",
    "default": "",
    "section": "Calculation Modes::Geometry Optimization",
    "description": "If <tt>XYZGOConstrains</tt>, <tt>PDBConstrains</tt>, and <tt>XSFGOConstrains</tt> are not present, <tt>Octopus</tt> will try to fetch the geometry optimization contrains from this block. If this block is not present, <tt>Octopus</tt> will not set any constrains. The format of this block can be illustrated by this example: <tt>%GOConstrains <br>&nbsp;&nbsp;'C'  |      1 | 0 | 0 <br>&nbsp;&nbsp;'O'  | &nbsp;1 | 0 | 0 <br>%</tt> Coordinates with a constrain value of 0 will be optimized, while coordinates with a constrain different from zero will be kept fixed. So, in this example the x coordinates of both atoms will remain fixed and the distance between the two atoms along the x axis will be constant. Note: It is important for the constrains to maintain the ordering in which the atoms were defined in the coordinates specifications. Moreover, constrains impose fixed absolute coordinates, therefore constrains are not compatible with GOCenter = yes",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/geometry optimization/goconstrains/"
  },
  "TestMode": {
    "type": "integer",
    "default": "hartree",
    "section": "Calculation Modes::Test",
    "description": "Decides what kind of test should be performed.",
    "options": [
      {
        "name": "hartree",
        "value": "1"
      },
      {
        "name": "derivatives",
        "value": "2"
      },
      {
        "name": "orthogonalization",
        "value": "3"
      },
      {
        "name": "interpolation",
        "value": "4"
      },
      {
        "name": "ion_interaction",
        "value": "5"
      },
      {
        "name": "projector",
        "value": "6"
      },
      {
        "name": "dft_u",
        "value": "7"
      },
      {
        "name": "hamiltonian_apply",
        "value": "8"
      },
      {
        "name": "density_calc",
        "value": "9"
      },
      {
        "name": "exp_apply",
        "value": "10"
      },
      {
        "name": "boundaries",
        "value": "11"
      },
      {
        "name": "subspace_diag",
        "value": "12"
      },
      {
        "name": "batch_ops",
        "value": "13"
      },
      {
        "name": "clock",
        "value": "18"
      },
      {
        "name": "linear_solver",
        "value": "19"
      },
      {
        "name": "cgal",
        "value": "20"
      },
      {
        "name": "dense_eigensolver",
        "value": "21"
      },
      {
        "name": "grid_interpolation",
        "value": "22"
      },
      {
        "name": "iihash",
        "value": "23"
      },
      {
        "name": "sihash",
        "value": "24"
      },
      {
        "name": "sphash",
        "value": "25"
      },
      {
        "name": "mpiwrappers",
        "value": "26"
      },
      {
        "name": "regridding",
        "value": "27"
      },
      {
        "name": "helmholtz_decomposition",
        "value": "28"
      },
      {
        "name": "vecpot_analytical",
        "value": "29"
      },
      {
        "name": "current_density",
        "value": "30"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/test/testmode/"
  },
  "TestType": {
    "type": "integer",
    "default": "all",
    "section": "Calculation Modes::Test",
    "description": "Decides on what type of values the test should be performed.",
    "options": [
      {
        "name": "real",
        "value": "1"
      },
      {
        "name": "complex",
        "value": "2"
      },
      {
        "name": "all",
        "value": "3"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/test/testtype/"
  },
  "TestRepetitions": {
    "type": "integer",
    "default": "1",
    "section": "Calculation Modes::Test",
    "description": "This variable controls the behavior of oct-test for performance benchmarking purposes. It sets the number of times the computational kernel of a test will be executed, in order to provide more accurate timings. Currently this variable is used by the <tt>hartree_test</tt>, <tt>derivatives</tt>, and <tt>projector</tt> tests.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/test/testrepetitions/"
  },
  "TestMinBlockSize": {
    "type": "integer",
    "default": "1",
    "section": "Calculation Modes::Test",
    "description": "Some tests can work with multiple blocksizes, in this case of range of blocksizes will be tested. This variable sets the lower bound of that range. Currently this variable is only used by the derivatives test.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/test/testminblocksize/"
  },
  "TestMaxBlockSize": {
    "type": "integer",
    "default": "128",
    "section": "Calculation Modes::Test",
    "description": "Some tests can work with multiple blocksizes, in this case of range of blocksizes will be tested. This variable sets the lower bound of that range. Currently this variable is only used by the derivatives test.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/test/testmaxblocksize/"
  },
  "TestHamiltonianApply": {
    "type": "integer",
    "default": "term_all",
    "section": "Calculation Modes::Test",
    "description": "Decides which part of the Hamiltonian is applied.",
    "options": [
      {
        "name": "term_all",
        "value": "0"
      },
      {
        "name": "term_kinetic",
        "value": "1"
      },
      {
        "name": "term_local_potential",
        "value": "2"
      },
      {
        "name": "term_non_local_potential",
        "value": "4"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/test/testhamiltonianapply/"
  },
  "TestBatchOps": {
    "type": "flag",
    "default": "ops_axpy + ops_scal + ops_nrm2",
    "section": "Calculation Modes::Test",
    "description": "Decides which part of the Hamiltonian is applied.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/test/testbatchops/"
  },
  "TestVectorPotentialType": {
    "type": "integer",
    "default": "bounded",
    "section": "Calculation Modes::Test",
    "description": "Select whether bounded or unbounded type will be used for vector potential tests",
    "options": [
      {
        "name": "bounded",
        "value": "1"
      },
      {
        "name": "unbounded",
        "value": "2"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/test/testvectorpotentialtype/"
  },
  "InterpolationTestOrder": {
    "type": "integer",
    "default": "1",
    "section": "Calculation Modes::Test",
    "description": "This variable controls the order of the grid interpolation used in the corresponding unit test.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/test/interpolationtestorder/"
  },
  "Displacement": {
    "type": "float",
    "default": "0.01 a.u.",
    "section": "Linear Response::Vibrational Modes",
    "description": "When calculating phonon properties by finite differences (<tt>CalculationMode = vib_modes, ResponseMethod = finite_differences</tt>), <tt>Displacement</tt> controls how much the atoms are to be moved in order to calculate the dynamical matrix.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/linear response/vibrational modes/displacement/"
  },
  "ReportMemory": {
    "type": "logical",
    "default": "no",
    "section": "Execution::Debug",
    "description": "If true, after each SCF iteration <tt>Octopus</tt> will print information about the memory the code is using. The quantity reported is an approximation to the size of the heap and generally it is a lower bound to the actual memory <tt>Octopus</tt> is using.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/debug/reportmemory/"
  },
  "CalculationMode": {
    "type": "integer",
    "default": "gs",
    "section": "Calculation Modes",
    "description": "Decides what kind of calculation is to be performed.",
    "options": [
      {
        "name": "gs",
        "value": "01"
      },
      {
        "name": "unocc",
        "value": "02"
      },
      {
        "name": "td",
        "value": "03"
      },
      {
        "name": "go",
        "value": "05"
      },
      {
        "name": "opt_control",
        "value": "07"
      },
      {
        "name": "em_resp",
        "value": "08"
      },
      {
        "name": "casida",
        "value": "09"
      },
      {
        "name": "vdw",
        "value": "11"
      },
      {
        "name": "vib_modes",
        "value": "12"
      },
      {
        "name": "one_shot",
        "value": "14"
      },
      {
        "name": "kdotp",
        "value": "15"
      },
      {
        "name": "dummy",
        "value": "17"
      },
      {
        "name": "invert_ks",
        "value": "18"
      },
      {
        "name": "test",
        "value": "19"
      },
      {
        "name": "recipe",
        "value": "99"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/calculationmode/"
  },
  "AnalyticalExternalSource": {
    "type": "logical",
    "default": "no",
    "section": "Maxwell",
    "description": "This means the analytical evaluation of formula will be used, Maxwell propagation will not be used.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/maxwell/analyticalexternalsource/"
  },
  "MaxwellBoundaryConditions": {
    "type": "block",
    "default": "",
    "section": "Time-Dependent::Propagation",
    "description": "Defines boundary conditions for the electromagnetic field propagation. Example: <tt>%MaxwellBoundaryConditions <br>&nbsp;&nbsp;   zero | mirror_pec | constant <br>%</tt>",
    "options": [
      {
        "name": "zero",
        "value": "0"
      },
      {
        "name": "constant",
        "value": "1"
      },
      {
        "name": "mirror_pec",
        "value": "2"
      },
      {
        "name": "mirror_pmc",
        "value": "3"
      },
      {
        "name": "plane_waves",
        "value": "4"
      },
      {
        "name": "periodic",
        "value": "5"
      },
      {
        "name": "medium",
        "value": "6"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/propagation/maxwellboundaryconditions/"
  },
  "MaxwellTDETRSApprox": {
    "type": "integer",
    "default": "no",
    "section": "Time-Dependent::Propagation",
    "description": "Whether to perform  approximations to the ETRS propagator.",
    "options": [
      {
        "name": "no",
        "value": "0"
      },
      {
        "name": "const_steps",
        "value": "1"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/propagation/maxwelltdetrsapprox/"
  },
  "MaxwellTDOperatorMethod": {
    "type": "integer",
    "default": "op_fd",
    "section": "Time-Dependent::Propagation",
    "description": "The Maxwell Operator e.g. the curl operation can be obtained by two different methods, the finite-difference or the fast fourier transform.",
    "options": [
      {
        "name": "op_fd",
        "value": "1"
      },
      {
        "name": "op_fft",
        "value": "2"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/propagation/maxwelltdoperatormethod/"
  },
  "MaxwellTDSCFThreshold": {
    "type": "float",
    "default": "1.0e-6",
    "section": "Time-Dependent::Propagation",
    "description": "Since the Maxwell-KS propagator is non-linear, each propagation step should be performed self-consistently.  In practice, for most purposes this is not necessary, except perhaps in the first iterations. This variable holds the number of propagation steps for which the propagation is done self-consistently. This variable controls the accuracy threshold for the self consistency.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/propagation/maxwelltdscfthreshold/"
  },
  "MaxwellPlaneWavesInBox": {
    "type": "logical",
    "default": "no",
    "section": "States",
    "description": "Analytic evaluation of the incoming waves inside the box, not doing any numerical propagation of Maxwells equations.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/states/maxwellplanewavesinbox/"
  },
  "UserDefinedConstantSpatialMaxwellField": {
    "type": "block",
    "default": "",
    "section": "MaxwellStates",
    "description": "Define parameters of spatially constant field. Example: <tt>%UserDefinedConstantSpatialMaxwellFields <br>&nbsp;&nbsp;   plane_wave_parser      | E_x | E_y | E_z | B_x | B_y | B_z | \"tdf_function\" <br>%</tt> This block defines three components of E field, three components of B field, and reference to the TD function.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/maxwellstates/userdefinedconstantspatialmaxwellfield/"
  },
  "PropagateSpatialMaxwellField": {
    "type": "logical",
    "default": "yes",
    "section": "MaxwellStates",
    "description": "Allow for numerical propagation of Maxwells equations of spatially constant field. If set to no, do only analytic evaluation of the field inside the box.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/maxwellstates/propagatespatialmaxwellfield/"
  },
  "MaxwellIncidentWaves": {
    "type": "block",
    "default": "",
    "section": "MaxwellStates",
    "description": "The initial electromagnetic fields can be set by the user with the <tt>MaxwellIncidentWaves</tt> block variable. The electromagnetic fields have to fulfill the Maxwells equations in vacuum. Example: <tt>%MaxwellIncidentWaves <br>&nbsp;&nbsp;   plane_wave_parser      | \"k1x\" | \"k1y\" | \"k1z\" | \"E1x\" | \"E1z\" | \"E1x\" <br>&nbsp;&nbsp;   plane_wave_parser      | \"k2x\" | \"k2y\" | \"k2z\" | \"E2x\" | \"E2y\" | \"E2z\" <br>&nbsp;&nbsp;   plane_wave_gauss       | \"k3x\" | \"k3y\" | \"k3z\" | \"E3x\" | \"E3y\" | \"E3z\" | \"width\" | \"shift\" <br>&nbsp;&nbsp;   plane_wave_mx_function | \"E4x\" | \"E4y\" | \"E4z\" | mx_envelope_name <br>%</tt> Description about MaxwellIncidentWaves follows",
    "options": [
      {
        "name": "plane_wave_parser",
        "value": "0"
      },
      {
        "name": "plane_wave_mx_function",
        "value": "1"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/maxwellstates/maxwellincidentwaves/"
  },
  "LinearMediumProperties": {
    "type": "block",
    "default": "",
    "section": "Maxwell",
    "description": "Defines electromagnetic parameters for a linear medium box. Example: <tt>%LinearMediumProperties <br>&nbsp;&nbsp;   epsilon_factor | mu_factor | sigma_e | sigma_m <br>%</tt> Permittivity factor, permeability factor, electric conductivity and magnetic conductivity of the medium box.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/maxwell/linearmediumproperties/"
  },
  "LinearMediumEdgeProfile": {
    "type": "integer",
    "default": "is edged. When the box shape is read from file, only the edged profile is supported.",
    "section": "Maxwell",
    "description": "Defines the type of numerical approximation used for the derivatives at the edges of the medium box.",
    "options": [
      {
        "name": "edged",
        "value": "1"
      },
      {
        "name": "smooth",
        "value": "2"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/maxwell/linearmediumedgeprofile/"
  },
  "LinearMediumBoxShape": {
    "type": "integer",
    "default": "",
    "section": "Maxwell",
    "description": "This variable defines the shape of the linear medium box. The default is <tt>medium_parallelepiped</tt>.",
    "options": [
      {
        "name": "medium_parallelepiped",
        "value": "1"
      },
      {
        "name": "medium_box_file",
        "value": "2"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/maxwell/linearmediumboxshape/"
  },
  "LinearMediumBoxSize": {
    "type": "block",
    "default": "",
    "section": "Maxwell",
    "description": "Defines center and size of a parallelepiped linear medium box. Example: <tt>%LinearMediumBoxSize <br>&nbsp;&nbsp;   center_x | center_y | center_z | x_length | y_length | z_length <br>%</tt>",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/maxwell/linearmediumboxsize/"
  },
  "LinearMediumBoxFile": {
    "type": "string",
    "default": "",
    "section": "Maxwell",
    "description": "File in OFF format with the shape of the linear medium.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/maxwell/linearmediumboxfile/"
  },
  "CheckPointsMediumFromFile": {
    "type": "logical",
    "default": "no",
    "section": "Maxwell",
    "description": "Whether to re-calculate the points map by artificially shrinking the coordinate system by a factor of 0.99 to check if the points inside the medium surface are properly detected. This works for only one medium surface which is centered in the origin of the coordinate system.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/maxwell/checkpointsmediumfromfile/"
  },
  "MaxwellAbsorbingBoundaries": {
    "type": "of absorbing boundaries used for Maxwell propagation in each direction.",
    "default": "",
    "section": "Time-Dependent::Propagation",
    "description": "Example: <tt>%MaxwellAbsorbingBoundaries <br>&nbsp;&nbsp;   cpml | cpml | cpml <br>%</tt>",
    "options": [
      {
        "name": "not_absorbing",
        "value": "0"
      },
      {
        "name": "mask",
        "value": "1"
      },
      {
        "name": "cpml",
        "value": "2"
      },
      {
        "name": "mask_zero",
        "value": "7"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/propagation/maxwellabsorbingboundaries/"
  },
  "MediumWidth": {
    "type": "float",
    "default": "0.0 a.u.",
    "section": "Time-Dependent::Absorbing Boundaries",
    "description": "Width of the boundary region with medium",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/absorbing boundaries/mediumwidth/"
  },
  "MediumEpsilonFactor": {
    "type": "float",
    "default": "1.0.",
    "section": "Time-Dependent::Absorbing Boundaries",
    "description": "Linear medium electric susceptibility.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/absorbing boundaries/mediumepsilonfactor/"
  },
  "MediumMuFactor": {
    "type": "float",
    "default": "1.0",
    "section": "Time-Dependent::Absorbing Boundaries",
    "description": "Linear medium magnetic susceptibility.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/absorbing boundaries/mediummufactor/"
  },
  "MediumElectricSigma": {
    "type": "float",
    "default": "0.",
    "section": "Time-Dependent::Absorbing Boundaries",
    "description": "Electric conductivity of the linear medium.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/absorbing boundaries/mediumelectricsigma/"
  },
  "MediumMagneticSigma": {
    "type": "float",
    "default": "0.",
    "section": "Time-Dependent::Absorbing Boundaries",
    "description": "Magnetic conductivity of the linear medium.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/absorbing boundaries/mediummagneticsigma/"
  },
  "MaxwellABWidth": {
    "type": "float",
    "default": "",
    "section": "Time-Dependent::Absorbing Boundaries",
    "description": "Width of the region used to apply the absorbing boundaries. The default value is twice the derivative order.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/absorbing boundaries/maxwellabwidth/"
  },
  "MaxwellABPMLPower": {
    "type": "float",
    "default": "3.5",
    "section": "Time-Dependent::Absorbing Boundaries",
    "description": "Exponential of the polynomial profile for the non-physical conductivity of the PML. Should be between 2 and 4",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/absorbing boundaries/maxwellabpmlpower/"
  },
  "MaxwellABPMLReflectionError": {
    "type": "float",
    "default": "1.0e-16",
    "section": "Time-Dependent::Absorbing Boundaries",
    "description": "Tolerated reflection error for the PML",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/absorbing boundaries/maxwellabpmlreflectionerror/"
  },
  "PlaneWavesOnOneSide": {
    "type": "logical",
    "default": "No",
    "section": "Maxwell",
    "description": "If PlaneWaves should be fed to the box only from one side.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/maxwell/planewavesononeside/"
  },
  "PlaneWavesSide": {
    "type": "string",
    "default": "",
    "section": "Maxwell",
    "description": "Side of the box in which plane waves are evaluated on the boundaries: negative would mean on boundaries which are towards negative values in the selected directions (e.g. -x).",
    "options": [
      {
        "name": "positive",
        "value": "1"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/maxwell/planewavesside/"
  },
  "MediumDispersionType": {
    "type": "integer",
    "default": "drude_medium",
    "section": "Maxwell",
    "description": "Dispersion model used for the medium (only Drude model available for the moment).",
    "options": [
      {
        "name": "drude_medium",
        "value": "0"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/maxwell/mediumdispersiontype/"
  },
  "MediumPoleEnergy": {
    "type": "float",
    "default": "0",
    "section": "Maxwell",
    "description": "Energy of the pole.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/maxwell/mediumpoleenergy/"
  },
  "MediumPoleDamping": {
    "type": "float",
    "default": "0",
    "section": "Maxwell",
    "description": "Damping factor (inverse relaxation time) of the medium.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/maxwell/mediumpoledamping/"
  },
  "MediumPoleStrength": {
    "type": "float",
    "default": "1.0",
    "section": "Maxwell",
    "description": "Strength of the pole (unitless).",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/maxwell/mediumpolestrength/"
  },
  "MediumCurrentCoordinates": {
    "type": "block",
    "default": "",
    "section": "Maxwell",
    "description": "This allows to output phasor current vectors at particular points in space. <tt>%MediumCurrentCoordinates <br>&nbsp;&nbsp;    -1.0 | 2.0 |  4.0 <br>&nbsp;&nbsp;     0.0 | 1.0 | -2.0 <br>%</tt>",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/maxwell/mediumcurrentcoordinates/"
  },
  "MaxwellHamiltonianOperator": {
    "type": "integer",
    "default": "faraday_ampere",
    "section": "Hamiltonian",
    "description": "With this variable the the Maxwell Hamiltonian operator can be selected",
    "options": [
      {
        "name": "faraday_ampere_old",
        "value": "0"
      },
      {
        "name": "faraday_ampere",
        "value": "1"
      },
      {
        "name": "faraday_ampere_medium",
        "value": "2"
      },
      {
        "name": "faraday_ampere_gauss",
        "value": "3"
      },
      {
        "name": "faraday_ampere_gauss_medium",
        "value": "4"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/maxwellhamiltonianoperator/"
  },
  "ExternalCurrent": {
    "type": "logical",
    "default": "no",
    "section": "Hamiltonian",
    "description": "If an external current density will be used.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/externalcurrent/"
  },
  "MaxwellMediumCalculation": {
    "type": "integer",
    "default": "RS",
    "section": "Hamiltonian",
    "description": "For linear media the calculation of the Maxwell Operator acting on the RS state can be done directly using the Riemann-Silberstein representation or by calculating the curl of the electric and magnetic fields.",
    "options": [
      {
        "name": "RS",
        "value": "1"
      },
      {
        "name": "EM",
        "value": "2"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/maxwellmediumcalculation/"
  },
  "UserDefinedMaxwellExternalCurrent": {
    "type": "block",
    "default": "",
    "section": "MaxwellStates",
    "description": "Example: <tt>%UserDefinedMaxwellExternalCurrent <br>&nbsp;&nbsp; current_parser      | \"expression_x_dir1\" | \"expression_y_dir1\" | \"expression_z_dir1\" <br>&nbsp;&nbsp; current_parser      | \"expression_x_dir2\" | \"expression_y_dir2\" | \"expression_z_dir2\" <br>&nbsp;&nbsp; current_td_function | \"amplitude_j0_x\"    | \"amplitude_j0_y\"    | \"amplitude_j0_z\"    | omega   | envelope_td_function_name | phase <br>%</tt> Description about UserDefinedMaxwellExternalCurrent follows",
    "options": [
      {
        "name": "current_parser",
        "value": "0"
      },
      {
        "name": "current_td_function",
        "value": "1"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/maxwellstates/userdefinedmaxwellexternalcurrent/"
  },
  "PhotoElectronSpectrum": {
    "type": "integer",
    "default": "none",
    "section": "Time-Dependent::PhotoElectronSpectrum",
    "description": "This variable controls the method used for the calculation of the photoelectron spectrum. You can specify more than one value by giving them as a sum, for example: <tt>PhotoElectronSpectrum = pes_spm + pes_mask</tt>",
    "options": [
      {
        "name": "none",
        "value": "0"
      },
      {
        "name": "pes_spm",
        "value": "2"
      },
      {
        "name": "pes_mask",
        "value": "4"
      },
      {
        "name": "pes_flux",
        "value": "8"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/photoelectronspectrum/photoelectronspectrum/"
  },
  "TDOutput": {
    "type": "block",
    "default": "multipoles + energy (+ others depending on other options)",
    "section": "Time-Dependent::TD Output",
    "description": "Defines what should be output during the time-dependent simulation. Many of the options can increase the computational cost of the simulation, so only use the ones that you need. In most cases the default value is enough, as it is adapted to the details of the TD run. If the ions are allowed to be moved, additionally the geometry and the temperature are output. If a laser is included it will output by default. Note: the output files generated by this option are updated every <tt>RestartWriteInterval</tt> steps. Example: <br><br><tt>%TDOutput <br>&nbsp;&nbsp;multipoles <br>&nbsp;&nbsp;energy <br>%<br></tt>",
    "options": [
      {
        "name": "multipoles",
        "value": "1"
      },
      {
        "name": "angular",
        "value": "2"
      },
      {
        "name": "spin",
        "value": "3"
      },
      {
        "name": "populations",
        "value": "4"
      },
      {
        "name": "geometry",
        "value": "5"
      },
      {
        "name": "dipole_acceleration",
        "value": "6"
      },
      {
        "name": "laser",
        "value": "7"
      },
      {
        "name": "energy",
        "value": "8"
      },
      {
        "name": "td_occup",
        "value": "9"
      },
      {
        "name": "local_mag_moments",
        "value": "10"
      },
      {
        "name": "gauge_field",
        "value": "11"
      },
      {
        "name": "temperature",
        "value": "12"
      },
      {
        "name": "ftchd",
        "value": "13"
      },
      {
        "name": "dipole_velocity",
        "value": "14"
      },
      {
        "name": "eigenvalues",
        "value": "15"
      },
      {
        "name": "ionization_channels",
        "value": "16"
      },
      {
        "name": "total_current",
        "value": "17"
      },
      {
        "name": "partial_charges",
        "value": "18"
      },
      {
        "name": "td_kpoint_occup",
        "value": "19"
      },
      {
        "name": "td_floquet",
        "value": "20"
      },
      {
        "name": "n_excited_el",
        "value": "21"
      },
      {
        "name": "coordinates_sep",
        "value": "22"
      },
      {
        "name": "velocities_sep",
        "value": "23"
      },
      {
        "name": "forces_sep",
        "value": "24"
      },
      {
        "name": "total_heat_current",
        "value": "25"
      },
      {
        "name": "total_magnetization",
        "value": "26"
      },
      {
        "name": "photons_q",
        "value": "27"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/td output/tdoutput/"
  },
  "TDOutputResolveStates": {
    "type": "logical",
    "default": "No",
    "section": "Time-Dependent::TD Output",
    "description": "Defines whether the output should be resolved by states. So far only TDOutput = multipoles is supported.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/td output/tdoutputresolvestates/"
  },
  "TDMultipoleLmax": {
    "type": "integer",
    "default": "1",
    "section": "Time-Dependent::TD Output",
    "description": "Maximum electric multipole of the density output to the file <tt>td.general/multipoles</tt> during a time-dependent simulation. Must be non-negative.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/td output/tdmultipolelmax/"
  },
  "TDProjStateStart": {
    "type": "integer",
    "default": "1",
    "section": "Time-Dependent::TD Output",
    "description": "To be used with <tt>TDOutput = td_occup</tt>. Not available if <tt>TDOutput = populations</tt>. Only output projections to states above <tt>TDProjStateStart</tt>. Usually one is only interested in particle-hole projections around the HOMO, so there is no need to calculate (and store) the projections of all TD states onto all static states. This sets a lower limit. The upper limit is set by the number of states in the propagation and the number of unoccupied states available.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/td output/tdprojstatestart/"
  },
  "TDExcitedStatesToProject": {
    "type": "block",
    "default": "",
    "section": "Time-Dependent::TD Output",
    "description": "<b>[WARNING: This is a *very* experimental feature]</b> To be used with <tt>TDOutput = populations</tt>. The population of the excited states (as defined by <Phi_I|Phi(t)> where |Phi(t)> is the many-body time-dependent state at time <i>t</i>, and |Phi_I> is the excited state of interest) can be approximated -- it is not clear how well -- by substituting for those real many-body states the time-dependent Kohn-Sham determinant and some modification of the Kohn-Sham ground-state determinant (<i>e.g.</i>, a simple HOMO-LUMO substitution, or the Casida ansatz for excited states in linear-response theory. If you set <tt>TDOutput</tt> to contain <tt>populations</tt>, you may ask for these approximated populations for a number of excited states, which will be described in the files specified in this block: each line should be the name of a file that contains one excited state. This file structure is the one written by the casida run mode, in the files in the directory <tt>*_excitations</tt>. The file describes the \"promotions\" from occupied to unoccupied levels that change the initial Slater determinant structure specified in ground_state. These promotions are a set of electron-hole pairs. Each line in the file, after an optional header, has four columns: <i>i  a  <math>\\sigma</math> weight</i> where <i>i</i> should be an occupied state, <i>a</i> an unoccupied one, and <math>\\sigma</math> the spin of the corresponding orbital. This pair is then associated with a creation-annihilation pair <math>a^{\\dagger}_{a,\\sigma} a_{i,\\sigma}</math>, so that the excited state will be a linear combination in the form: <math>\\left|{\\rm ExcitedState}\\right> = \\sum weight(i,a,\\sigma) a^{\\dagger}_{a,\\sigma} a_{i,\\sigma} \\left|{\\rm GroundState}\\right></math> where <i>weight</i> is the number in the fourth column. These weights should be normalized to one; otherwise the routine will normalize them, and write a warning.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/td output/tdexcitedstatestoproject/"
  },
  "TDOutputComputeInterval": {
    "type": "integer",
    "default": "50",
    "section": "Time-Dependent::TD Output",
    "description": "The TD output requested are computed when the iteration number is a multiple of the <tt>TDOutputComputeInterval</tt> variable. Must be >= 0. If it is 0, then no output is written. Implemented only for projections and number of excited electrons for the moment.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/td output/tdoutputcomputeinterval/"
  },
  "TDOutputDFTU": {
    "type": "flag",
    "default": "none",
    "section": "Time-Dependent::TD Output",
    "description": "Defines what should be output during the time-dependent simulation, related to DFT+U. Note: the output files generated by this option are updated every <tt>RestartWriteInterval</tt> steps.",
    "options": [
      {
        "name": "effective_u",
        "value": "1"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/td output/tdoutputdftu/"
  },
  "TDFloquetFrequency": {
    "type": "float",
    "default": "0",
    "section": "Time-Dependent::TD Output",
    "description": "Frequency for the Floquet analysis, this should be the carrier frequency or integer multiples of it. Other options will work, but likely be nonsense.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/td output/tdfloquetfrequency/"
  },
  "TDFloquetSample": {
    "type": "integer",
    "default": "20",
    "section": "Time-Dependent::TD Output",
    "description": "Number of points on which one Floquet cycle is sampled in the time-integral of the Floquet analysis.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/td output/tdfloquetsample/"
  },
  "TDFloquetDimension": {
    "type": "integer",
    "default": "-1",
    "section": "Time-Dependent::TD Output",
    "description": "Order of Floquet Hamiltonian. If negative number is given, downfolding is performed.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/td output/tdfloquetdimension/"
  },
  "MaxwellTDOutput": {
    "type": "flag",
    "default": "maxwell_energy",
    "section": "Time-Dependent::TD Output",
    "description": "Defines what should be output during the time-dependent Maxwell simulation. Many of the options can increase the computational cost of the simulation, so only use the ones that you need. In most cases the default value is enough, as it is adapted to the details of the TD run. WARNING: the calculation of the longitudinal or transverse E and B fields can be very expensive, so please consider using the MaxwellOutput block to calculate and output these quantities at certain timesteps.",
    "options": [
      {
        "name": "maxwell_total_e_field",
        "value": "1"
      },
      {
        "name": "maxwell_total_b_field",
        "value": "8"
      },
      {
        "name": "maxwell_longitudinal_e_field",
        "value": "64"
      },
      {
        "name": "maxwell_longitudinal_b_field",
        "value": "512"
      },
      {
        "name": "maxwell_transverse_e_field",
        "value": "4096"
      },
      {
        "name": "maxwell_transverse_b_field",
        "value": "32768"
      },
      {
        "name": "maxwell_energy",
        "value": "262144"
      },
      {
        "name": "e_field_surface_x",
        "value": "524288"
      },
      {
        "name": "e_field_surface_y",
        "value": "1048576"
      },
      {
        "name": "e_field_surface_z",
        "value": "2097152"
      },
      {
        "name": "b_field_surface_x",
        "value": "4194304"
      },
      {
        "name": "b_field_surface_y",
        "value": "8388608"
      },
      {
        "name": "b_field_surface_z",
        "value": "16777216"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/td output/maxwelltdoutput/"
  },
  "PES_Flux_Shape": {
    "type": "integer",
    "default": "",
    "section": "Time-Dependent::PhotoElectronSpectrum",
    "description": "The shape of the surface.",
    "options": [
      {
        "name": "cub",
        "value": "1"
      },
      {
        "name": "sph",
        "value": "2"
      },
      {
        "name": "pln",
        "value": "3"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/photoelectronspectrum/pes_flux_shape/"
  },
  "PES_Flux_AnisotropyCorrection": {
    "type": "logical",
    "default": "",
    "section": "Time-Dependent::PhotoElectronSpectrum",
    "description": "Apply anisotropy correction.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/photoelectronspectrum/pes_flux_anisotropycorrection/"
  },
  "PES_Flux_Offset": {
    "type": "block",
    "default": "",
    "section": "Time-Dependent::PhotoElectronSpectrum",
    "description": "Shifts the surface for <tt>PES_Flux_Shape = cub</tt>. The syntax is: <tt>%PES_Flux_Offset <br>&nbsp;&nbsp;xshift | yshift | zshift <br>% </tt>",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/photoelectronspectrum/pes_flux_offset/"
  },
  "PES_Flux_Lmax": {
    "type": "integer",
    "default": "80",
    "section": "Time-Dependent::PhotoElectronSpectrum",
    "description": "Maximum order of the spherical harmonic to be integrated on an equidistant spherical grid (to be changed to Gauss-Legendre quadrature).",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/photoelectronspectrum/pes_flux_lmax/"
  },
  "PES_Flux_Lsize": {
    "type": "block",
    "default": "",
    "section": "Time-Dependent::PhotoElectronSpectrum",
    "description": "For <tt>PES_Flux_Shape = cub</tt> sets the dimensions along each direction. The syntax is: <tt>%PES_Flux_Lsize <br>&nbsp;&nbsp;xsize | ysize | zsize <br>% </tt> where <tt>xsize</tt>, <tt>ysize</tt>, and <tt>zsize</tt> are with respect to the origin. The surface can be shifted with <tt>PES_Flux_Offset</tt>. If <tt>PES_Flux_Shape = pln</tt>, specifies the position of two planes perpendicular to the non-periodic dimension symmetrically placed at <tt>PES_Flux_Lsize</tt> distance from the origin.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/photoelectronspectrum/pes_flux_lsize/"
  },
  "PES_Flux_Face_Dens": {
    "type": "block",
    "default": "",
    "section": "Time-Dependent::PhotoElectronSpectrum",
    "description": "Define the number of points density per unit of area (in au) on the face of the 'cub' surface.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/photoelectronspectrum/pes_flux_face_dens/"
  },
  "PES_Flux_Radius": {
    "type": "float",
    "default": "",
    "section": "Time-Dependent::PhotoElectronSpectrum",
    "description": "The radius of the sphere, if <tt>PES_Flux_Shape == sph</tt>.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/photoelectronspectrum/pes_flux_radius/"
  },
  "PES_Flux_StepsThetaR": {
    "type": "integer",
    "default": "",
    "section": "Time-Dependent::PhotoElectronSpectrum",
    "description": "Number of steps in <math>\\theta</math> (<math>0 \\le \\theta \\le \\pi</math>) for the spherical surface.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/photoelectronspectrum/pes_flux_stepsthetar/"
  },
  "PES_Flux_StepsPhiR": {
    "type": "integer",
    "default": "",
    "section": "Time-Dependent::PhotoElectronSpectrum",
    "description": "Number of steps in <math>\\phi</math> (<math>0 \\le \\phi \\le 2 \\pi</math>) for the spherical surface.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/photoelectronspectrum/pes_flux_stepsphir/"
  },
  "PES_Flux_Parallelization": {
    "type": "flag",
    "default": "",
    "section": "Time-Dependent::PhotoElectronSpectrum",
    "description": "The parallelization strategy to be used to calculate the PES spectrum using the resources available in the domain parallelization pool. This option is not available without domain parallelization. Parallelization over k-points and states is always enabled when available.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/photoelectronspectrum/pes_flux_parallelization/"
  },
  "PES_Flux_UseSymmetries": {
    "type": "logical",
    "default": "",
    "section": "Time-Dependent::PhotoElectronSpectrum",
    "description": "Use surface and momentum grid symmetries to speed up calculation and lower memory footprint. By default available only when the surface shape matches the grid symmetry i.e.: PES_Flux_Shape = m_cub or m_pln and PES_Flux_Momenutum_Grid = m_cartesian or PES_Flux_Shape = m_sph and PES_Flux_Momenutum_Grid = m_polar",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/photoelectronspectrum/pes_flux_usesymmetries/"
  },
  "PES_Flux_RuntimeOutput": {
    "type": "logical",
    "default": "",
    "section": "Time-Dependent::PhotoElectronSpectrum",
    "description": "Write output in ascii format at runtime.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/photoelectronspectrum/pes_flux_runtimeoutput/"
  },
  "PES_Flux_Momenutum_Grid": {
    "type": "integer",
    "default": "",
    "section": "Time-Dependent::PhotoElectronSpectrum",
    "description": "Decides how the grid in momentum space is generated.",
    "options": [
      {
        "name": "polar",
        "value": "1"
      },
      {
        "name": "cartesian",
        "value": "2"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/photoelectronspectrum/pes_flux_momenutum_grid/"
  },
  "PES_Flux_EnergyGrid": {
    "type": "block",
    "default": "",
    "section": "Time-Dependent::PhotoElectronSpectrum",
    "description": "The block <tt>PES_Flux_EnergyGrid</tt> specifies the energy grid in momentum space. <tt><br>%PES_Flux_EnergyGrid <br>&nbsp;&nbsp; Emin | Emax | DeltaE <br>%</tt>",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/photoelectronspectrum/pes_flux_energygrid/"
  },
  "PES_Flux_Kmax": {
    "type": "float",
    "default": "1.0",
    "section": "Time-Dependent::PhotoElectronSpectrum",
    "description": "The maximum value of the photoelectron momentum. For cartesian momentum grids one can specify a value different for cartesian direction using a block input.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/photoelectronspectrum/pes_flux_kmax/"
  },
  "PES_Flux_Kmin": {
    "type": "float",
    "default": "0.0",
    "section": "Time-Dependent::PhotoElectronSpectrum",
    "description": "The minimum value of the photoelectron momentum. For cartesian momentum grids one can specify a value different for cartesian direction using a block input.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/photoelectronspectrum/pes_flux_kmin/"
  },
  "PES_Flux_DeltaK": {
    "type": "float",
    "default": "0.02",
    "section": "Time-Dependent::PhotoElectronSpectrum",
    "description": "Spacing of the the photoelectron momentum grid.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/photoelectronspectrum/pes_flux_deltak/"
  },
  "PES_Flux_ThetaK": {
    "type": "block",
    "default": "",
    "section": "Time-Dependent::PhotoElectronSpectrum",
    "description": "Define the grid points on theta (<math>0 \\le \\theta \\le \\pi</math>) when using a spherical grid in momentum. The block defines the maximum and minimum values of theta and the number of of points for the discretization. <tt>%PES_Flux_ThetaK <br>&nbsp;&nbsp; theta_min | theta_max  | npoints <br>% </tt> By default theta_min=0, theta_max = pi, npoints = 45.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/photoelectronspectrum/pes_flux_thetak/"
  },
  "PES_Flux_StepsThetaK": {
    "type": "integer",
    "default": "45",
    "section": "Time-Dependent::PhotoElectronSpectrum",
    "description": "Number of steps in <math>\\theta</math> (<math>0 \\le \\theta \\le \\pi</math>) for the spherical grid in k.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/photoelectronspectrum/pes_flux_stepsthetak/"
  },
  "PES_Flux_PhiK": {
    "type": "block",
    "default": "",
    "section": "Time-Dependent::PhotoElectronSpectrum",
    "description": "Define the grid points on theta (<math>0 \\le \\theta \\le 2\\pi</math>) when using a spherical grid in momentum. The block defines the maximum and minimum values of theta and the number of of points for the discretization. <tt>%PES_Flux_PhiK <br>&nbsp;&nbsp; theta_min | theta_max  | npoints <br>% </tt> By default theta_min=0, theta_max = pi, npoints = 90.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/photoelectronspectrum/pes_flux_phik/"
  },
  "PES_Flux_StepsPhiK": {
    "type": "integer",
    "default": "90",
    "section": "Time-Dependent::PhotoElectronSpectrum",
    "description": "Number of steps in <math>\\phi</math> (<math>0 \\le \\phi \\le 2 \\pi</math>) for the spherical grid in k.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/photoelectronspectrum/pes_flux_stepsphik/"
  },
  "PES_Flux_ARPES_grid": {
    "type": "logical",
    "default": "",
    "section": "Time-Dependent::PhotoElectronSpectrum",
    "description": "Use a curvilinear momentum space grid that compensates the transformation used to obtain ARPES. With this choice ARPES data is laid out on a Cartesian regular grid. By default true when <tt>PES_Flux_Shape = pln</tt> and a <tt>KPointsPath</tt> is specified.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/photoelectronspectrum/pes_flux_arpes_grid/"
  },
  "PES_Flux_GridTransformMatrix": {
    "type": "block",
    "default": "",
    "section": "Time-Dependent::PhotoElectronSpectrum",
    "description": "Define an optional transformation matrix for the momentum grid. <tt>%PES_Flux_GridTransformMatrix <br>&nbsp;&nbsp; M_11 | M_12  | M_13 <br>&nbsp;&nbsp; M_21 | M_22  | M_23 <br>&nbsp;&nbsp; M_31 | M_32  | M_33 <br>% </tt>",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/photoelectronspectrum/pes_flux_gridtransformmatrix/"
  },
  "PES_spm_points": {
    "type": "block",
    "default": "",
    "section": "Time-Dependent::PhotoElectronSpectrum",
    "description": "List of points at which to calculate the photoelectron spectrum by the sample point method. If no points are given, a spherical grid is generated automatically. The exact syntax is: <tt>%PES_spm_points <br>&nbsp;&nbsp;x1 | y1 | z1 <br>% </tt>",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/photoelectronspectrum/pes_spm_points/"
  },
  "PES_spm_recipe": {
    "type": "integer",
    "default": "phase",
    "section": "Time-Dependent::PhotoElectronSpectrum",
    "description": "The type for calculating the photoelectron spectrum in the sample point method.",
    "options": [
      {
        "name": "raw",
        "value": "1"
      },
      {
        "name": "phase",
        "value": "2"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/photoelectronspectrum/pes_spm_recipe/"
  },
  "PES_spm_OmegaMax": {
    "type": "float",
    "default": "0.0",
    "section": "Time-Dependent::PhotoElectronSpectrum",
    "description": "If <tt>PES_spm_OmegaMax > 0</tt>, the photoelectron spectrum is directly calculated during time-propagation, evaluated by the PES_spm method. <tt>PES_spm_OmegaMax</tt> is then the maximum frequency (approximate kinetic energy) and <tt>PES_spm_DeltaOmega</tt> the spacing in frequency domain of the spectrum.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/photoelectronspectrum/pes_spm_omegamax/"
  },
  "PES_spm_DeltaOmega": {
    "type": "float",
    "default": "",
    "section": "Time-Dependent::PhotoElectronSpectrum",
    "description": "The spacing in frequency domain for the photoelectron spectrum (if <tt>PES_spm_OmegaMax > 0</tt>). The default is <tt>PES_spm_OmegaMax/500</tt>.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/photoelectronspectrum/pes_spm_deltaomega/"
  },
  "PES_spm_StepsThetaR": {
    "type": "integer",
    "default": "45",
    "section": "Time-Dependent::PhotoElectronSpectrum",
    "description": "Number of steps in <math>\\theta</math> (<math>0 \\le \\theta \\le \\pi</math>) for the spherical grid (if no <tt>PES_spm_points</tt> are given).",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/photoelectronspectrum/pes_spm_stepsthetar/"
  },
  "PES_spm_StepsPhiR": {
    "type": "integer",
    "default": "90",
    "section": "Time-Dependent::PhotoElectronSpectrum",
    "description": "Number of steps in <math>\\phi</math> (<math>0 \\le \\phi \\le 2 \\pi</math>) for the spherical grid (if no <tt>PES_spm_points</tt> are given).",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/photoelectronspectrum/pes_spm_stepsphir/"
  },
  "PES_spm_Radius": {
    "type": "float",
    "default": "",
    "section": "Time-Dependent::PhotoElectronSpectrum",
    "description": "The radius of the sphere for the spherical grid (if no <tt>PES_spm_points</tt> are given).",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/photoelectronspectrum/pes_spm_radius/"
  },
  "PropagationSpectrumType": {
    "type": "of spectrum to calculate.",
    "default": "AbsorptionSpectrum",
    "section": "Utilities::oct-propagation_spectrum",
    "description": "",
    "options": [
      {
        "name": "AbsorptionSpectrum",
        "value": "1"
      },
      {
        "name": "EnergyLossSpectrum",
        "value": "2"
      },
      {
        "name": "DipolePower",
        "value": "3"
      },
      {
        "name": "RotatoryStrength",
        "value": "4"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-propagation_spectrum/propagationspectrumtype/"
  },
  "SpectrumMethod": {
    "type": "integer",
    "default": "fourier",
    "section": "Utilities::oct-propagation_spectrum",
    "description": "Decides which method is used to obtain the spectrum.",
    "options": [
      {
        "name": "fourier",
        "value": "1"
      },
      {
        "name": "compressed_sensing",
        "value": "2"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-propagation_spectrum/spectrummethod/"
  },
  "SpectrumSignalNoise": {
    "type": "float",
    "default": "0.0",
    "section": "Utilities::oct-propagation_spectrum",
    "description": "For compressed sensing, the signal to process, the time-dependent dipole in this case, is assumed to have some noise that is given by this dimensionless quantity.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-propagation_spectrum/spectrumsignalnoise/"
  },
  "PropagationSpectrumDampMode": {
    "type": "integer",
    "default": "",
    "section": "Utilities::oct-propagation_spectrum",
    "description": "Decides which damping/filtering is to be applied in order to calculate spectra by calculating a Fourier transform. The default is polynomial damping, except when <tt>SpectrumMethod = compressed_sensing</tt>. In that case the default is none.",
    "options": [
      {
        "name": "none",
        "value": "0"
      },
      {
        "name": "exponential",
        "value": "1"
      },
      {
        "name": "polynomial",
        "value": "2"
      },
      {
        "name": "gaussian",
        "value": "3"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-propagation_spectrum/propagationspectrumdampmode/"
  },
  "PropagationSpectrumTransform": {
    "type": "integer",
    "default": "sine",
    "section": "Utilities::oct-propagation_spectrum",
    "description": "Decides which transform to perform, if <tt>SpectrumMethod = fourier</tt>.",
    "options": [
      {
        "name": "sine",
        "value": "2"
      },
      {
        "name": "cosine",
        "value": "3"
      },
      {
        "name": "laplace",
        "value": "1"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-propagation_spectrum/propagationspectrumtransform/"
  },
  "PropagationSpectrumStartTime": {
    "type": "float",
    "default": "0.0",
    "section": "Utilities::oct-propagation_spectrum",
    "description": "Processing is done for the given function in a time-window that starts at the value of this variable.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-propagation_spectrum/propagationspectrumstarttime/"
  },
  "PropagationSpectrumEndTime": {
    "type": "float",
    "default": "-1.0 au",
    "section": "Utilities::oct-propagation_spectrum",
    "description": "Processing is done for the given function in a time-window that ends at the value of this variable. If set to a negative value, the maximum value from the corresponding multipole file will used.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-propagation_spectrum/propagationspectrumendtime/"
  },
  "PropagationSpectrumEnergyStep": {
    "type": "float",
    "default": "0.01 eV",
    "section": "Utilities::oct-propagation_spectrum",
    "description": "Sampling rate for the spectrum. If you supply a number equal or smaller than zero, then the sampling rate will be <math>2 \\pi / T</math>, where <math>T</math> is the total propagation time.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-propagation_spectrum/propagationspectrumenergystep/"
  },
  "PropagationSpectrumMinEnergy": {
    "type": "float",
    "default": "0",
    "section": "Utilities::oct-propagation_spectrum",
    "description": "The Fourier transform is calculated for energies larger than this value.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-propagation_spectrum/propagationspectrumminenergy/"
  },
  "PropagationSpectrumMaxEnergy": {
    "type": "float",
    "default": "20 eV",
    "section": "Utilities::oct-propagation_spectrum",
    "description": "The Fourier transform is calculated for energies smaller than this value.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-propagation_spectrum/propagationspectrummaxenergy/"
  },
  "PropagationSpectrumDampFactor": {
    "type": "float",
    "default": "value ensure that the damping function adquires a 0.0001 value at the end of the propagation time.",
    "section": "Utilities::oct-propagation_spectrum",
    "description": "If <tt>PropagationSpectrumDampMode = exponential, gaussian</tt>, the damping parameter of the exponential is fixed through this variable.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-propagation_spectrum/propagationspectrumdampfactor/"
  },
  "PropagationSpectrumSigmaDiagonalization": {
    "type": "logical",
    "default": ".false.",
    "section": "Utilities::oct-propagation_spectrum",
    "description": "If <tt>PropagationSpectrumSigmaDiagonalization = yes</tt>, the polarizability tensor is diagonalizied. This variable is only used if the cross_section_tensor is computed.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-propagation_spectrum/propagationspectrumsigmadiagonalization/"
  },
  "PropagationSpectrumSymmetrizeSigma": {
    "type": "logical",
    "default": ".false.",
    "section": "Utilities::oct-propagation_spectrum",
    "description": "The polarizablity tensor has to be real and symmetric. Due to numerical accuracy, that is not extricly conserved when computing it from different time-propations. If <tt>PropagationSpectrumSymmetrizeSigma = yes</tt>, the polarizability tensor is symmetrized before its diagonalizied. This variable is only used if the cross_section_tensor is computed.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-propagation_spectrum/propagationspectrumsymmetrizesigma/"
  },
  "PESMaskMode": {
    "type": "integer",
    "default": "mask_mode",
    "section": "Time-Dependent::PhotoElectronSpectrum",
    "description": "PES calculation mode.",
    "options": [
      {
        "name": "mask_mode",
        "value": "1"
      },
      {
        "name": "fullmask_mode",
        "value": "2"
      },
      {
        "name": "passive_mode",
        "value": "3"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/photoelectronspectrum/pesmaskmode/"
  },
  "PESMaskStartTime": {
    "type": "float",
    "default": "-1.0",
    "section": "Time-Dependent::PhotoElectronSpectrum",
    "description": "The time photoelectrons start to be recorded. In pump-probe simulations, this allows getting rid of an unwanted ionization signal coming from the pump. NOTE: This will enforce the mask boundary conditions for all times.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/photoelectronspectrum/pesmaskstarttime/"
  },
  "PESMaskPlaneWaveProjection": {
    "type": "integer",
    "default": "fft_map",
    "section": "Time-Dependent::PhotoElectronSpectrum",
    "description": "With the mask method, wavefunctions in the continuum are treated as plane waves. This variable sets how to calculate the plane-wave projection in the buffer region. We perform discrete Fourier transforms (DFT) in order to approximate a continuous Fourier transform. The major drawback of this approach is the built-in periodic boundary condition of DFT. Choosing an appropriate plane-wave projection for a given simulation in addition to <tt>PESMaskEnlargeFactor</tt> and <tt>PESMask2PEnlargeFactor</tt>will help to converge the results. NOTE: depending on the value of <tt>PESMaskMode</tt> <tt>PESMaskPlaneWaveProjection</tt>, may affect not only performance but also the time evolution of the density.",
    "options": [
      {
        "name": "fft_out",
        "value": "2"
      },
      {
        "name": "fft_map",
        "value": "3"
      },
      {
        "name": "nfft_map",
        "value": "5"
      },
      {
        "name": "pfft_map",
        "value": "6"
      },
      {
        "name": "pnfft_map",
        "value": "7"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/photoelectronspectrum/pesmaskplanewaveprojection/"
  },
  "PESMaskEnlargeFactor": {
    "type": "float",
    "default": "1",
    "section": "Time-Dependent::PhotoElectronSpectrum",
    "description": "Mask box enlargement level. Enlarges the mask bounding box by a <tt>PESMaskEnlargeFactor</tt>. This helps to avoid wavefunction wrapping at the boundaries.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/photoelectronspectrum/pesmaskenlargefactor/"
  },
  "PESMask2PEnlargeFactor": {
    "type": "float",
    "default": "1.0",
    "section": "Time-Dependent::PhotoElectronSpectrum",
    "description": "Mask two points enlargement factor. Enlarges the mask box by adding two points at the edges of the box in each direction (x,y,z) at a distance L=Lb*<tt>PESMask2PEnlargeFactor</tt> where <i>Lb</i> is the box size. This allows to run simulations with an additional void space at a price of adding few points. The Fourier space associated with the new box is restricted by the same factor. Note: needs <tt> PESMaskPlaneWaveProjection = nfft_map or pnfft_map </tt>.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/photoelectronspectrum/pesmask2penlargefactor/"
  },
  "PESMaskShape": {
    "type": "integer",
    "default": "m_sin2",
    "section": "Time-Dependent::PhotoElectronSpectrum",
    "description": "The mask function shape.",
    "options": [
      {
        "name": "m_sin2",
        "value": "1"
      },
      {
        "name": "m_step",
        "value": "2"
      },
      {
        "name": "m_erf",
        "value": "3"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/photoelectronspectrum/pesmaskshape/"
  },
  "PESMaskSize": {
    "type": "block",
    "default": "",
    "section": "Time-Dependent::PhotoElectronSpectrum",
    "description": "Set the size of the mask function. Here you can set the inner (R1) and outer (R2) radius by setting the block as follows: <tt>%PESMaskSize <br>&nbsp;&nbsp; R1 | R2 | \"user-defined\" <br>%</tt> The optional 3rd column is a user-defined expression for the mask function. For example, <i>r</i> creates a spherical mask (which is the default for <tt>BoxShape = sphere</tt>). Note, values R2 larger than the box size may lead in this case to unexpected reflection behaviours.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/photoelectronspectrum/pesmasksize/"
  },
  "PESMaskFilterCutOff": {
    "type": "float",
    "default": "-1",
    "section": "Time-Dependent::PhotoElectronSpectrum",
    "description": "In calculation with <tt>PESMaskMode = fullmask_mode</tt> and NFFT, spurious frequencies may lead to numerical instability of the algorithm. This option gives the possibility to filter out the unwanted components by setting an energy cut-off. If <tt>PESMaskFilterCutOff = -1</tt> no filter is applied.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/photoelectronspectrum/pesmaskfiltercutoff/"
  },
  "PESMaskIncludePsiA": {
    "type": "logical",
    "default": "false",
    "section": "Time-Dependent::PhotoElectronSpectrum",
    "description": "Add the contribution of <math>\\Psi_A</math> in the mask region to the photo-electron spectrum. Literally adds the Fourier components of: <math>\\Theta(r-R1) \\Psi_A(r)</math> with <math>\\Theta</math> being the Heaviside step function. With this option PES will contain all the contributions starting from the inner radius <math>R1</math>. Use this option to improve convergence with respect to the box size and total simulation time. Note: Carefully choose <math>R1</math> in order to avoid contributions from returning electrons.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/photoelectronspectrum/pesmaskincludepsia/"
  },
  "PESMaskSpectEnergyMax": {
    "type": "float",
    "default": "maxval(mask%Lk)<math>^2/2</math>",
    "section": "Time-Dependent::PhotoElectronSpectrum",
    "description": "The maximum energy for the PES spectrum.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/photoelectronspectrum/pesmaskspectenergymax/"
  },
  "PESMaskSpectEnergyStep": {
    "type": "float",
    "default": "",
    "section": "Time-Dependent::PhotoElectronSpectrum",
    "description": "The PES spectrum energy step.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/photoelectronspectrum/pesmaskspectenergystep/"
  },
  "TDPropagator": {
    "type": "integer",
    "default": "etrs",
    "section": "Time-Dependent::Propagation",
    "description": "This variable determines which algorithm will be used to approximate the evolution operator <math>U(t+\\delta t, t)</math>. That is, given <math>\\psi(\\tau)</math> and <math>H(\\tau)</math> for <math>\\tau \\le t</math>, calculate <math>t+\\delta t</math>. Note that in general the Hamiltonian is not known at times in the interior of the interval <math>[t,t+\\delta t]</math>. This is due to the self-consistent nature of the time-dependent Kohn-Sham problem: the Hamiltonian at a given time <math>\\tau</math> is built from the \"solution\" wavefunctions at that time. Some methods, however, do require the knowledge of the Hamiltonian at some point of the interval <math>[t,t+\\delta t]</math>. This problem is solved by making use of extrapolation: given a number <math>l</math> of time steps previous to time <math>t</math>, this information is used to build the Hamiltonian at arbitrary times within <math>[t,t+\\delta t]</math>. To be fully precise, one should then proceed <i>self-consistently</i>: the obtained Hamiltonian at time <math>t+\\delta t</math> may then be used to interpolate the Hamiltonian, and repeat the evolution algorithm with this new information. Whenever iterating the procedure does not change the solution wavefunctions, the cycle is stopped. In practice, in <tt>Octopus</tt> we perform a second-order extrapolation without a self-consistency check, except for the first two iterations, where obviously the extrapolation is not reliable. The proliferation of methods is certainly excessive. The reason for it is that the propagation algorithm is currently a topic of active development. We hope that in the future the optimal schemes are clearly identified. In the mean time, if you do not feel like testing, use the default choices and make sure the time step is small enough.",
    "options": [
      {
        "name": "etrs",
        "value": "2"
      },
      {
        "name": "aetrs",
        "value": "3"
      },
      {
        "name": "caetrs",
        "value": "12"
      },
      {
        "name": "exp_mid",
        "value": "4"
      },
      {
        "name": "crank_nicholson",
        "value": "5"
      },
      {
        "name": "crank_nicolson",
        "value": "5"
      },
      {
        "name": "crank_nicholson_sparskit",
        "value": "6"
      },
      {
        "name": "crank_nicolson_sparskit",
        "value": "6"
      },
      {
        "name": "magnus",
        "value": "7"
      },
      {
        "name": "qoct_tddft_propagator",
        "value": "10"
      },
      {
        "name": "runge_kutta4",
        "value": "13"
      },
      {
        "name": "runge_kutta2",
        "value": "14"
      },
      {
        "name": "expl_runge_kutta4",
        "value": "15"
      },
      {
        "name": "cfmagnus4",
        "value": "16"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/propagation/tdpropagator/"
  },
  "TDStepsWithSelfConsistency": {
    "type": "integer",
    "default": "0",
    "section": "Time-Dependent::Propagation",
    "description": "Since the KS propagator is non-linear, each propagation step should be performed self-consistently.  In practice, for most purposes this is not necessary, except perhaps in the first iterations. This variable holds the number of propagation steps for which the propagation is done self-consistently. The special value <tt>all_steps</tt> forces self-consistency to be imposed on all propagation steps. A value of 0 means that self-consistency will not be imposed.  The default is 0.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/propagation/tdstepswithselfconsistency/"
  },
  "TDSCFThreshold": {
    "type": "float",
    "default": "1.0e-6",
    "section": "Time-Dependent::Propagation",
    "description": "Since the KS propagator is non-linear, each propagation step should be performed self-consistently.  In practice, for most purposes this is not necessary, except perhaps in the first iterations. This variable holds the number of propagation steps for which the propagation is done self-consistently. The self consistency has to be measured against some accuracy threshold. This variable controls the value of that threshold.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/propagation/tdscfthreshold/"
  },
  "TDTimeStep": {
    "type": "float",
    "default": "",
    "section": "Time-Dependent::Propagation",
    "description": "The time-step for the time propagation. For most propagators you want to use the largest value that is possible without the evolution becoming unstable. The default value is the maximum value that we have found empirically that is stable for the spacing <math>h</math>: <math>dt = 0.0426 - 0.207 h + 0.808 h^2</math> (from parabolic fit to Fig. 4 of http://dx.doi.org/10.1021/ct800518j, probably valid for 3D systems only). However, you might need to adjust this value.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/propagation/tdtimestep/"
  },
  "TDPropagationTime": {
    "type": "float",
    "default": "",
    "section": "Time-Dependent::Propagation",
    "description": "The length of the time propagation. You cannot set this variable at the same time as <tt>TDMaxSteps</tt>. By default this variable will not be used. The units for this variable are <math>\\hbar</math>/Hartree (or <math>\\hbar</math>/eV if you selected <tt>ev_angstrom</tt> as input units). The approximate conversions to femtoseconds are 1 fs = 41.34 <math>\\hbar</math>/Hartree = 1.52 <math>\\hbar</math>/eV.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/propagation/tdpropagationtime/"
  },
  "TDMaxSteps": {
    "type": "integer",
    "default": "1500",
    "section": "Time-Dependent::Propagation",
    "description": "Number of time-propagation steps that will be performed. You cannot use this variable together with <tt>TDPropagationTime</tt>.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/propagation/tdmaxsteps/"
  },
  "TDDynamics": {
    "type": "of dynamics to follow during a time propagation.",
    "default": "ehrenfest",
    "section": "Time-Dependent::Propagation",
    "description": "For BO, you must set <tt>MoveIons = yes</tt>.",
    "options": [
      {
        "name": "ehrenfest",
        "value": "1"
      },
      {
        "name": "bo",
        "value": "2"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/propagation/tddynamics/"
  },
  "RecalculateGSDuringEvolution": {
    "type": "logical",
    "default": "no",
    "section": "Time-Dependent::Propagation",
    "description": "In order to calculate some information about the system along the evolution (e.g. projection onto the ground-state KS determinant, projection of the TDKS spin-orbitals onto the ground-state KS spin-orbitals), the ground-state KS orbitals are needed. If the ionic potential changes -- that is, the ions move -- one may want to recalculate the ground state. You may do this by setting this variable. The recalculation is not done every time step, but only every <tt>RestartWriteInterval</tt> time steps.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/propagation/recalculategsduringevolution/"
  },
  "TDScissor": {
    "type": "float",
    "default": "0.0",
    "section": "Time-Dependent",
    "description": "(experimental) If set, a scissor operator will be applied in the Hamiltonian, shifting the excitation energies by the amount specified. By default, it is not applied.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/tdscissor/"
  },
  "TDEnergyUpdateIter": {
    "type": "integer",
    "default": "",
    "section": "Time-Dependent::Propagation",
    "description": "This variable controls after how many iterations Octopus updates the total energy during a time-propagation run. For iterations where the energy is not updated, the last calculated value is reported. If you set this variable to 1, the energy will be calculated in each step.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/propagation/tdenergyupdateiter/"
  },
  "TDFreezeOrbitals": {
    "type": "integer",
    "default": "0",
    "section": "Time-Dependent",
    "description": "(Experimental) You have the possibility of \"freezing\" a number of orbitals during a time-propagation. The Hartree and exchange-correlation potential due to these orbitals (which will be the lowest-energy ones) will be added during the propagation, but the orbitals will not be propagated.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/tdfreezeorbitals/"
  },
  "TDFreezeHXC": {
    "type": "logical",
    "default": "no",
    "section": "Time-Dependent",
    "description": "The electrons are evolved as independent particles feeling the Hartree and exchange-correlation potentials from the ground-state electronic configuration.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/tdfreezehxc/"
  },
  "TDFreezeDFTUOccupations": {
    "type": "logical",
    "default": "no",
    "section": "Time-Dependent",
    "description": "The occupation matrices than enters in the DFT+U potential are not evolved during the time evolution.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/tdfreezedftuoccupations/"
  },
  "TDFreezeU": {
    "type": "logical",
    "default": "no",
    "section": "Time-Dependent",
    "description": "The effective U of DFT+U is not evolved during the time evolution.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/tdfreezeu/"
  },
  "StaticExternalPotentials": {
    "type": "block",
    "default": "",
    "section": "System",
    "description": "An static external potential is a model potential added to the local potential of the Hamiltonian The format of this block is the following: The first field defines the type of species (the valid options are detailed below). Then a list of parameters follows. The parameters are specified by a first field with the parameter name and the field that follows with the value of the parameter. Some parameters are specific to a certain species while others are accepted by all species. These are <tt>mass</tt>, <tt>max_spacing</tt>, and <tt>min_radius</tt>. These are examples of possible species: <tt>%ExternalPotential <br>&nbsp;&nbsp; potential_user_defined | potential_formula | \"1/2*r^2\" <br>%</tt>",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/system/staticexternalpotentials/"
  },
  "StaticMagneticField": {
    "type": "block",
    "default": "",
    "section": "Hamiltonian",
    "description": "A static constant magnetic field may be added to the usual Hamiltonian, by setting the block <tt>StaticMagneticField</tt>. The three possible components of the block (which should only have one line) are the three components of the magnetic field vector. Note that if you are running the code in 1D mode, this will not work, and if you are running the code in 2D mode the magnetic field will have to be in the <i>z</i>-direction, so that the first two columns should be zero. Possible in periodic system only in these cases: 2D system, 1D periodic, with <tt>StaticMagneticField2DGauge = linear_y</tt>; 3D system, 1D periodic, field is zero in <i>y</i>- and <i>z</i>-directions (given currently implemented gauges). The magnetic field should always be entered in atomic units, regardless of the <tt>Units</tt> variable. Note that we use the \"Gaussian\" system meaning 1 au[B] = <math> 2.350517568\\times 10^9</math> Gauss, which corresponds to <math>2.3505175678\\times 10^5</math> Tesla.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/staticmagneticfield/"
  },
  "StaticMagneticField2DGauge": {
    "type": "integer",
    "default": "linear_xy",
    "section": "Hamiltonian",
    "description": "The gauge of the static vector potential <math>A</math> when a magnetic field <math>B = \\left( 0, 0, B_z \\right)</math> is applied to a 2D-system.",
    "options": [
      {
        "name": "linear_xy",
        "value": "0"
      },
      {
        "name": "linear_y",
        "value": "1"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/staticmagneticfield2dgauge/"
  },
  "StaticElectricField": {
    "type": "block",
    "default": "0",
    "section": "Hamiltonian",
    "description": "A static constant electric field may be added to the usual Hamiltonian, by setting the block <tt>StaticElectricField</tt>. The three possible components of the block (which should only have one line) are the three components of the electric field vector. It can be applied in a periodic direction of a large supercell via the single-point Berry phase.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/staticelectricfield/"
  },
  "Interactions": {
    "type": "block",
    "default": "",
    "section": "System",
    "description": "This input option controls the interactions between systems. It basically allows to select which systems will interact with another system through a given interaction type. The format of the block is the following: <br>%<tt>Namespace.Interactions <br>&nbsp;&nbsp;interaction_type | interaction_mode | ... <br>%</tt> Here is an example to better understand how this works: <br>%<tt>SystemA.Interactions <br>&nbsp;&nbsp;gravity | all_except | \"SystemB\" <br>%</tt> This means that SystemA and all the systems that belong to the same namespace (i.e., all its subsystems) will interact through gravity with all interaction partners that are also able to interact through gravity, except with SystemB. Note that the opposite is not true so, although clearly unphysical, this will not prevent SystemB from feeling the gravity from SystemA (in <tt>Octopus</tt> the interactions are always one-sided). NB: Each interaction type should only appear once in the block. Any further instances beyond the first will be ignored. Available modes and interaction types:",
    "options": [
      {
        "name": "gravity",
        "value": "1"
      },
      {
        "name": "lorentz_force",
        "value": "2"
      },
      {
        "name": "coulomb_force",
        "value": "3"
      },
      {
        "name": "linear_medium_to_em_field",
        "value": "4"
      },
      {
        "name": "current_to_mxll_field",
        "value": "5"
      },
      {
        "name": "maxwell_field_to_medium",
        "value": "6"
      },
      {
        "name": "lennard_jones",
        "value": "7"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/system/interactions/"
  },
  "RegularizationFunction": {
    "type": "integer",
    "default": "COS2",
    "section": "Maxwell",
    "description": "The current arising from charged point particles must be mapped onto the Maxwell propagation grid. This requires a smearing or regularization function $\\phi(\\mathbf{r})$ attached to each particle position $\\mathbf{r}_i$ with user defined cutoff width, $\\sigma$",
    "options": [
      {
        "name": "COS2",
        "value": "1"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/maxwell/regularizationfunction/"
  },
  "RegularizationFunctionWidth": {
    "type": "float",
    "default": "2 bohrradii",
    "section": "Maxwell",
    "description": "The current arising from charged point particles must be mapped onto the Maxwell propagation grid. This requires a smearing or regularization function $\\phi(\\mathbf{r})$ attached to each particle position $\\mathbf{r}_i$ with user defined cutoff width, $\\sigma$.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/maxwell/regularizationfunctionwidth/"
  },
  "MaxAngularMomentum": {
    "type": "block",
    "default": "",
    "section": "DFTBPlusInterface",
    "description": "Specifies the highest angular momentum for each atom type. All orbitals up to that angular momentum will be included in the calculation. Possible values for the angular momenta are s, p, d, f. These are examples: <tt>%MaxAngularMomentum <br>&nbsp;&nbsp;'O'   | 'p' <br>&nbsp;&nbsp;'H'   | 's' <br>%</tt>",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/dftbplusinterface/maxangularmomentum/"
  },
  "SlakoDir": {
    "type": "string",
    "default": "\"./\"",
    "section": "Execution::IO",
    "description": "Folder containing the Slako files",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/io/slakodir/"
  },
  "InitialIonicTemperature": {
    "type": "float",
    "default": "0.0",
    "section": "DFTBPlusInterface",
    "description": "If this variable is present, the ions will have initial velocities velocities to the atoms following a Boltzmann distribution with this temperature (in Kelvin). Used only if <tt>TDDynamics = Ehrenfest</tt> and  <tt>MoveIons = yes</tt>.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/dftbplusinterface/initialionictemperature/"
  },
  "SccTolerance": {
    "type": "float",
    "default": "",
    "section": "DFTBPlusInterface",
    "description": "Self-consistent-charges convergence tolerance. Once this tolerance has been achieved the SCC cycle will stop.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/dftbplusinterface/scctolerance/"
  },
  "BerkeleyGW_NumberBands": {
    "type": "integer",
    "default": "all states",
    "section": "Output::BerkeleyGW",
    "description": "Wavefunctions for bands up to this number will be output. Must be between <= number of states. If < 1, no wavefunction file will be output.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/output/berkeleygw/berkeleygw_numberbands/"
  },
  "BerkeleyGW_Vxc_diag_nmin": {
    "type": "integer",
    "default": "1",
    "section": "Output::BerkeleyGW",
    "description": "Lowest band for which to write diagonal exchange-correlation matrix elements. Must be <= number of states. If < 1, diagonals will be skipped.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/output/berkeleygw/berkeleygw_vxc_diag_nmin/"
  },
  "BerkeleyGW_Vxc_diag_nmax": {
    "type": "integer",
    "default": "nst",
    "section": "Output::BerkeleyGW",
    "description": "Highest band for which to write diagonal exchange-correlation matrix elements. Must be between <= number of states. If < 1, diagonals will be skipped.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/output/berkeleygw/berkeleygw_vxc_diag_nmax/"
  },
  "BerkeleyGW_Vxc_offdiag_nmin": {
    "type": "integer",
    "default": "1",
    "section": "Output::BerkeleyGW",
    "description": "Lowest band for which to write off-diagonal exchange-correlation matrix elements. Must be <= number of states. If < 1, off-diagonals will be skipped.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/output/berkeleygw/berkeleygw_vxc_offdiag_nmin/"
  },
  "BerkeleyGW_Vxc_offdiag_nmax": {
    "type": "integer",
    "default": "nst",
    "section": "Output::BerkeleyGW",
    "description": "Highest band for which to write off-diagonal exchange-correlation matrix elements. Must be <= number of states. If < 1, off-diagonals will be skipped.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/output/berkeleygw/berkeleygw_vxc_offdiag_nmax/"
  },
  "BerkeleyGW_WFN_filename": {
    "type": "string",
    "default": "WFN",
    "section": "Output::BerkeleyGW",
    "description": "Filename for the wavefunctions.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/output/berkeleygw/berkeleygw_wfn_filename/"
  },
  "BerkeleyGW_CalcExchange": {
    "type": "logical",
    "default": "false",
    "section": "Output::BerkeleyGW",
    "description": "Whether to calculate exchange matrix elements, to be written in <tt>x.dat</tt>. These will be calculated anyway by BerkeleyGW <tt>Sigma</tt>, so this is useful mainly for comparison and testing.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/output/berkeleygw/berkeleygw_calcexchange/"
  },
  "BerkeleyGW_CalcDipoleMtxels": {
    "type": "logical",
    "default": "false",
    "section": "Output::BerkeleyGW",
    "description": "Whether to calculate dipole matrix elements, to be written in <tt>vmtxel</tt>. This should be done when calculating <tt>WFN_fi</tt> for Bethe-Salpeter calculations with light polarization in a finite direction. In that case, a shifted grid <tt>WFNq_fi</tt> cannot be calculated, but we can instead use matrix elements of <math>r</math> in a more exact scheme. In <tt>absorption.inp</tt>, set <tt>read_vmtxel</tt> and <tt>use_momentum</tt>. Specify the number of conduction and valence bands you will use in BSE here with <tt>BerkeleyGW_VmtxelNumCondBands</tt> and <tt>BerkeleyGW_VmtxelNumValBands</tt>.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/output/berkeleygw/berkeleygw_calcdipolemtxels/"
  },
  "BerkeleyGW_VmtxelPolarization": {
    "type": "block",
    "default": "(1, 0, 0)",
    "section": "Output::BerkeleyGW",
    "description": "Polarization, <i>i.e.</i> direction vector, for which to calculate <tt>vmtxel</tt>, if you have set <tt>BerkeleyGW_CalcDipoleMtxels = yes</tt>. May not have any component in a periodic direction. The vector will be normalized.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/output/berkeleygw/berkeleygw_vmtxelpolarization/"
  },
  "BerkeleyGW_VmtxelNumCondBands": {
    "type": "integer",
    "default": "0",
    "section": "Output::BerkeleyGW",
    "description": "Number of conduction bands for which to calculate <tt>vmtxel</tt>, if you have set <tt>BerkeleyGW_CalcDipoleMtxels = yes</tt>. This should be equal to the number to be used in BSE.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/output/berkeleygw/berkeleygw_vmtxelnumcondbands/"
  },
  "BerkeleyGW_VmtxelNumValBands": {
    "type": "integer",
    "default": "0",
    "section": "Output::BerkeleyGW",
    "description": "Number of valence bands for which to calculate <tt>vmtxel</tt>, if you have set <tt>BerkeleyGW_CalcDipoleMtxels = yes</tt>. This should be equal to the number to be used in BSE.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/output/berkeleygw/berkeleygw_vmtxelnumvalbands/"
  },
  "OutputWfsNumber": {
    "type": "string",
    "default": "all states",
    "section": "Output",
    "description": "Which wavefunctions to print, in list form: <i>i.e.</i>, \"1-5\" to print the first five states, \"2,3\" to print the second and the third state, etc. If more states are specified than available, extra ones will be ignored.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/output/outputwfsnumber/"
  },
  "CurrentThroughPlane": {
    "type": "block",
    "default": "",
    "section": "Output",
    "description": "The code can calculate current traversing a user-defined portion of a plane, as specified by this block. A small plain-text file <tt>current-flow</tt> will be written containing this information. Only available for 1D, 2D, or 3D. In the format below, <tt>origin</tt> is a point in the plane. <tt>u</tt> and <tt>v</tt> are the (dimensionless) vectors defining the plane; they will be normalized. <tt>spacing</tt> is the fineness of the mesh on the plane. Integers <tt>nu</tt> and <tt>mu</tt> are the length and width of the portion of the plane, in units of <tt>spacing</tt>. Thus, the grid points included in the plane are <tt>x_ij = origin + i*spacing*u + j*spacing*v</tt>, for <tt>nu <= i <= mu</tt> and <tt>nv <= j <= mv</tt>. Analogously, in the 2D case, the current flow is calculated through a line; in the 1D case, the current flow is calculated through a point. Note that the spacing can differ from the one used in the main calculation; an interpolation will be performed. Example (3D): <tt>%CurrentThroughPlane <br>&nbsp;&nbsp; 0.0 | 0.0 | 0.0  # origin <br>&nbsp;&nbsp; 0.0 | 1.0 | 0.0  # u <br>&nbsp;&nbsp; 0.0 | 0.0 | 1.0  # v <br>&nbsp;&nbsp; 0.2              # spacing <br>&nbsp;&nbsp; 0 | 50           # nu | mu <br>&nbsp;&nbsp; -50 | 50         # nv | mv <br>%</tt> Example (2D): <tt>%CurrentThroughPlane <br>&nbsp;&nbsp; 0.0 | 0.0        # origin <br>&nbsp;&nbsp; 1.0 | 0.0        # u <br>&nbsp;&nbsp; 0.2              # spacing <br>&nbsp;&nbsp; 0 | 50           # nu | mu <br>%</tt> Example (1D): <tt>%CurrentThroughPlane <br>&nbsp;&nbsp; 0.0              # origin <br>%</tt>",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/output/currentthroughplane/"
  },
  "OutputDuringSCF": {
    "type": "logical",
    "default": "no",
    "section": "Output",
    "description": "During <tt>gs</tt> and <tt>unocc</tt> runs, if this variable is set to yes, output will be written after every <tt>OutputInterval</tt> iterations.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/output/outputduringscf/"
  },
  "RestartWriteInterval": {
    "type": "integer",
    "default": "50",
    "section": "Execution::IO",
    "description": "Restart data is written when the iteration number is a multiple of the <tt>RestartWriteInterval</tt> variable. For time-dependent runs this includes the update of the output controlled by the <tt>TDOutput</tt> variable. (Other output is controlled by <tt>OutputInterval</tt>.)",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/io/restartwriteinterval/"
  },
  "OutputIterDir": {
    "type": "string",
    "default": "\"output_iter\"",
    "section": "Output",
    "description": "The name of the directory where <tt>Octopus</tt> stores information such as the density, forces, etc. requested by variable <tt>Output</tt> in the format specified by <tt>OutputFormat</tt>. This information is written while iterating <tt>CalculationMode = gs</tt>, <tt>unocc</tt>, or <tt>td</tt>, according to <tt>OutputInterval</tt>, and has nothing to do with the restart information.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/output/outputiterdir/"
  },
  "OutputMatrixElements": {
    "type": "block",
    "default": "none",
    "section": "Output",
    "description": "Specifies what matrix elements to print. Enabled only if <tt>Output</tt> block includes <tt>matrix_elements</tt>. The output files go into the <tt>static</tt> directory, except when running a time-dependent simulation, when the directory <tt>td.XXXXXXX</tt> is used. Example: <br><br><tt>%OutputMatrixElements <br>&nbsp;&nbsp;momentum <br>&nbsp;&nbsp;ks_multipoles <br>%<br></tt> It is possible to specify only compute the matrix elements for some of the states using the variables <tt>OutptMEStart</tt> and <tt>OutputMEEnd</tt>.",
    "options": [
      {
        "name": "momentum",
        "value": "1"
      },
      {
        "name": "ang_momentum",
        "value": "2"
      },
      {
        "name": "one_body",
        "value": "3"
      },
      {
        "name": "two_body",
        "value": "4"
      },
      {
        "name": "two_body_exc_k",
        "value": "5"
      },
      {
        "name": "ks_multipoles",
        "value": "6"
      },
      {
        "name": "dipole",
        "value": "7"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/output/outputmatrixelements/"
  },
  "OutputMEMultipoles": {
    "type": "integer",
    "default": "1",
    "section": "Output",
    "description": "This variable decides which multipole moments are printed out for <tt>OutputMatrixElements = ks_multipoles</tt>: In 3D, if, for example, <tt>OutputMEMultipoles = 1</tt>, then the program will print three files, <tt>ks_me_multipoles.x</tt> (<tt>x</tt>=1,2,3), containing respectively the (1,-1), (1,0) and (1,1) multipole matrix elements between Kohn-Sham states. In 2D, this variable is ignored: it will always print two files, <tt>ks_me_multipoles.i</tt> (<tt>i</tt>=1,2), containing the <math>x</math> and <math>y</math> dipole matrix elements. In 1D, if, for example, <tt>OutputMEMultipoles = 2</tt>, the program will print two files, containing the <math>x</math> and <math>x^2</math> matrix elements between Kohn-Sham states.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/output/outputmemultipoles/"
  },
  "OutputMEStart": {
    "type": "integer",
    "default": "1",
    "section": "Output",
    "description": "Specifies the state/band index for starting to compute the matrix element. So far, this is only used for dipole matrix elements.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/output/outputmestart/"
  },
  "OutputMEEnd": {
    "type": "integer",
    "default": "1",
    "section": "Output",
    "description": "Specifies the highest state/band index used to compute the matrix element. So far, this is only used for dipole matrix elements.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/output/outputmeend/"
  },
  "LinearMediumOutput": {
    "type": "block",
    "default": "none",
    "section": "Output",
    "description": "Specifies what to print. The output files are written at the beginning of the run into the output directory for the linear medium. Each option must be in a separate row. Optionally individual output formats can be defined for each row (VTK format is supported) or they can be read separately from <tt>OutputFormat</tt> in the input file. Example: <br><br><tt>%LinearMediumOutput <br>&nbsp;&nbsp;permittivity <br>&nbsp;&nbsp;permeability <br>%<br></tt> This block supports all the formats of the <tt>Output</tt> block. See <tt>Output</tt>.",
    "options": [
      {
        "name": "points",
        "value": "1"
      },
      {
        "name": "permittivity",
        "value": "2"
      },
      {
        "name": "permeability",
        "value": "3"
      },
      {
        "name": "speed_of_light",
        "value": "3"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/output/linearmediumoutput/"
  },
  "LinearMediumOutputDir": {
    "type": "string",
    "default": "\"output_iter\"",
    "section": "Output",
    "description": "The name of the directory where <tt>Octopus</tt> stores the information about the linear medium system, as required by the <tt>LinearMediumOutput</tt> variable.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/output/linearmediumoutputdir/"
  },
  "MaxwellOutput": {
    "type": "block",
    "default": "none",
    "section": "Output",
    "description": "Specifies what to print. The output files are written at the end of the run into the output directory for the Maxwell run. Time-dependent simulations print only per iteration, including always the last. The frequency of output per iteration is set by <tt>OutputInterval</tt> and the directory is set by <tt>OutputIterDir</tt>. Each option must be in a separate row. Optionally individual output formats and output intervals can be defined for each row or they can be read separately from <tt>OutputFormat</tt> and <tt>MaxwellOutputInterval</tt> variables in the input file. Example: <br><br><tt>%MaxwellOutput <br>&nbsp;&nbsp;electric_field <br>&nbsp;&nbsp;magnetic_field <br>%<br></tt> This block supports all the formats of the <tt>Output</tt> block. See <tt>Output</tt>.",
    "options": [
      {
        "name": "electric_field",
        "value": "1"
      },
      {
        "name": "magnetic_field",
        "value": "2"
      },
      {
        "name": "trans_electric_field",
        "value": "3"
      },
      {
        "name": "trans_magnetic_field",
        "value": "4"
      },
      {
        "name": "long_electric_field",
        "value": "5"
      },
      {
        "name": "long_magnetic_field",
        "value": "6"
      },
      {
        "name": "div_electric_field",
        "value": "7"
      },
      {
        "name": "div_magnetic_field",
        "value": "8"
      },
      {
        "name": "poynting_vector",
        "value": "9"
      },
      {
        "name": "maxwell_energy_density",
        "value": "10"
      },
      {
        "name": "external_current",
        "value": "11"
      },
      {
        "name": "charge_density",
        "value": "12"
      },
      {
        "name": "orbital_angular_momentum",
        "value": "13"
      },
      {
        "name": "vector_potential_mag",
        "value": "14"
      },
      {
        "name": "magnetic_field_diff",
        "value": "15"
      },
      {
        "name": "total_current_mxll",
        "value": "16"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/output/maxwelloutput/"
  },
  "MaxwellOutputInterval": {
    "type": "integer",
    "default": "50",
    "section": "Output",
    "description": "The output requested by variable <tt>MaxwellOutput</tt> is written to the directory <tt>MaxwellOutputIterDir</tt> when the iteration number is a multiple of the <tt>MaxwellOutputInterval</tt> variable. Subdirectories are named Y.X, where Y is <tt>td</tt>, <tt>scf</tt>, or <tt>unocc</tt>, and X is the iteration number. To use the working directory, specify <tt>\".\"</tt> (Output of restart files is instead controlled by <tt>MaxwellRestartWriteInterval</tt>.) Must be >= 0. If it is 0, then no output is written. This variable can also be defined inside the <tt>MaxwellOutput</tt> block. See <tt>MaxwellOutput</tt>.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/output/maxwelloutputinterval/"
  },
  "MaxwellOutputIterDir": {
    "type": "string",
    "default": "\"output_iter\"",
    "section": "Output",
    "description": "The name of the directory where <tt>Octopus</tt> stores information such as the density, forces, etc. requested by variable <tt>MaxwellOutput</tt> in the format specified by <tt>OutputHow</tt>. This information is written while iterating <tt>CalculationMode = maxwell</tt> according to <tt>OutputInterval</tt>, and has nothing to do with the restart information.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/output/maxwelloutputiterdir/"
  },
  "MaxwellRestartWriteInterval": {
    "type": "integer",
    "default": "50",
    "section": "Execution::IO",
    "description": "Restart data is written when the iteration number is a multiple of the <tt>MaxwellRestartWriteInterval</tt> variable. (Other output is controlled by <tt>MaxwellOutputInterval</tt>.)",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/io/maxwellrestartwriteinterval/"
  },
  "ParticleMass": {
    "type": "float",
    "default": "1.0",
    "section": "Hamiltonian",
    "description": "It is possible to make calculations for a particle with a mass different from one (atomic unit of mass, or mass of the electron). This is useful to describe non-electronic systems, or for esoteric purposes.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/particlemass/"
  },
  "LennardJonesEpsilon": {
    "type": "float",
    "default": "",
    "section": "ClassicalParticles",
    "description": "Epsilon parameter (dispersion energy) of Lennard-Jones interaction for this species. In case two particles have a different epsilon, the combination rule will be computed <math>\\epsilon_{12} = \\sqrt{\\epsilon_1 + \\epsilon_2}</math>.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/classicalparticles/lennardjonesepsilon/"
  },
  "LennardJonesSigma": {
    "type": "float",
    "default": "",
    "section": "ClassicalParticles",
    "description": "Sigma parameter (particle size) of Lennard-Jones interaction for this species. In case two particles have a different sigma, the combination rule will be computed <math>\\sigma_{12} = (\\sigma_1 + \\sigma_2) / 2.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/classicalparticles/lennardjonessigma/"
  },
  "ParticleInitialPosition": {
    "type": "block",
    "default": "",
    "section": "ClassicalParticles",
    "description": "Initial position of classical particle, in Km.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/classicalparticles/particleinitialposition/"
  },
  "ParticleInitialVelocity": {
    "type": "block",
    "default": "",
    "section": "ClassicalParticles",
    "description": "Initial velocity of classical particle in Km/s.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/classicalparticles/particleinitialvelocity/"
  },
  "ParticleCharge": {
    "type": "float",
    "default": "",
    "section": "ClassicalParticles",
    "description": "Charge of classical particle",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/classicalparticles/particlecharge/"
  },
  "AOTruncation": {
    "type": "flag",
    "default": "ao_full",
    "section": "Atomic Orbitals",
    "description": "This option determines how Octopus will truncate the orbitals used for DFT+U. Except for the full method, the other options are only there to get a quick idea.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/atomic orbitals/aotruncation/"
  },
  "AOThreshold": {
    "type": "float",
    "default": "0.01",
    "section": "Atomic Orbitals",
    "description": "Determines the threshold used to compute the radius of the atomic orbitals for DFT+U and for Wannier90. This radius is computed by making sure that the absolute value of the radial part of the atomic orbital is below the specified threshold. This value should be converged to be sure that results do not depend on this value. However increasing this value increases the number of grid points covered by the orbitals and directly affect performances.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/atomic orbitals/aothreshold/"
  },
  "AONormalize": {
    "type": "logical",
    "default": "yes",
    "section": "Atomic Orbitals",
    "description": "If set to yes, Octopus will normalize the atomic orbitals individually. This variable is ignored is <tt>AOLoewdin</tt> is set to yes.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/atomic orbitals/aonormalize/"
  },
  "AOSubmesh": {
    "type": "logical",
    "default": "",
    "section": "Atomic Orbitals",
    "description": "If set to yes, Octopus will use submeshes to internally store the orbitals with their phase instead of storing them on the mesh. This is usually slower for small periodic systems, but becomes advantageous for large supercells. Submeshes are not compatible with Loewdin orthogonalization. For periodic systems, the default is set to no, whereas it is set to yes for isolated systems.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/atomic orbitals/aosubmesh/"
  },
  "AOLoewdin": {
    "type": "logical",
    "default": "no",
    "section": "Atomic Orbitals",
    "description": "This option determines if the atomic orbital basis is orthogonalized or not. This is done for using the Loewdin orthogonalization scheme. The default is set to no for the moment as this option is not yet implemented for isolated systems, and seems to lead to important egg-box effect",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/atomic orbitals/aoloewdin/"
  },
  "MaxwellFunctions": {
    "type": "block",
    "default": "",
    "section": "Time-Dependent",
    "description": "This block specifies the shape of a \"spatial-dependent function\", such as the envelope needed when using the <tt>MaxwellFunctions</tt> block. Each line in the block specifies one function. The first element of each line will be a string that defines the name of the function. The second element specifies which type of function we are using; in the following we provide an example for each of the possible types:",
    "options": [
      {
        "name": "mxf_const_wave",
        "value": "10002"
      },
      {
        "name": "mxf_const_phase",
        "value": "10004"
      },
      {
        "name": "mxf_gaussian_wave",
        "value": "10005"
      },
      {
        "name": "mxf_cosinoidal_wave",
        "value": "10006"
      },
      {
        "name": "mxf_logistic_wave",
        "value": "10007"
      },
      {
        "name": "mxf_trapezoidal_wave",
        "value": "10008"
      },
      {
        "name": "mxf_from_expr",
        "value": "10011"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/maxwellfunctions/"
  },
  "PNFFTCutoff": {
    "type": "integer",
    "default": "6",
    "section": "Mesh::FFTs",
    "description": "Cut-off parameter of the window function.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/mesh/ffts/pnfftcutoff/"
  },
  "PNFFTOversampling": {
    "type": "float",
    "default": "2.0",
    "section": "Mesh::FFTs",
    "description": "PNFFT oversampling factor (sigma). This will rule the size of the FFT under the hood.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/mesh/ffts/pnfftoversampling/"
  },
  "SurfaceCorrection": {
    "type": "logical",
    "default": "no",
    "section": "Calculation Modes::Test",
    "description": "Compute the surface correction for Helmholtz decomposition?",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/test/surfacecorrection/"
  },
  "HelmholtzVisualizeBoxes": {
    "type": "logical",
    "default": "no",
    "section": "Calculation Modes::Test",
    "description": "If true, output the volume points for the three boxes of the Helmholtz surface correction. 1) The volume points of the system box 2) The inner mask for the system box. This region has the thickness of the stencil and it is used to set to zero the longitudinal or transverse field after computing the final divergence or curl (to avoid spikes) 3) The surface points of the system box",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/test/helmholtzvisualizeboxes/"
  },
  "NFFTGuruInterface": {
    "type": "logical",
    "default": "false",
    "section": "Mesh::FFTs",
    "description": "Perform NFFT with guru interface. This permits the fine tuning of several critical parameters.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/mesh/ffts/nfftguruinterface/"
  },
  "NFFTCutoff": {
    "type": "integer",
    "default": "6",
    "section": "Mesh::FFTs",
    "description": "Cut-off parameter of the window function. See NFFT manual for details.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/mesh/ffts/nfftcutoff/"
  },
  "NFFTOversampling": {
    "type": "float",
    "default": "2",
    "section": "Mesh::FFTs",
    "description": "NFFT oversampling factor (sigma). This will rule the size of the FFT under the hood.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/mesh/ffts/nfftoversampling/"
  },
  "NFFTPrecompute": {
    "type": "integer",
    "default": "NFFT_PRE_PSI",
    "section": "Mesh::FFTs",
    "description": "NFFT precomputation strategy.",
    "options": [
      {
        "name": "NFFT_PRE_LIN_PSI",
        "value": "4"
      },
      {
        "name": "NFFT_PRE_PSI",
        "value": "16"
      },
      {
        "name": "NFFT_PRE_FULL_PSI",
        "value": "32"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/mesh/ffts/nfftprecompute/"
  },
  "TDFunctions": {
    "type": "block",
    "default": "",
    "section": "Time-Dependent",
    "description": "This block specifies the shape of a \"time-dependent function\", such as the envelope needed when using the <tt>TDExternalFields</tt> block. Each line in the block specifies one function. The first element of each line will be a string that defines the name of the function. The second element specifies which type of function we are using; in the following we provide an example for each of the possible types:",
    "options": [
      {
        "name": "tdf_cw",
        "value": "10002"
      },
      {
        "name": "tdf_gaussian",
        "value": "10003"
      },
      {
        "name": "tdf_cosinoidal",
        "value": "10004"
      },
      {
        "name": "tdf_trapezoidal",
        "value": "10005"
      },
      {
        "name": "tdf_from_file",
        "value": "10006"
      },
      {
        "name": "tdf_from_expr",
        "value": "10008"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/tdfunctions/"
  },
  "FFTOptimize": {
    "type": "logical",
    "default": "yes",
    "section": "Mesh::FFTs",
    "description": "Should <tt>octopus</tt> optimize the FFT dimensions? This means that the mesh to which FFTs are applied is not taken to be as small as possible: some points may be added to each direction in order to get a \"good number\" for the performance of the FFT algorithm. The best FFT grid dimensions are given by <math>2^a 3^b 5^c 7^d 11^e 13^f</math> where <math>a,b,c,d</math> are arbitrary and <math>e,f</math> are 0 or 1. (<a href=http://www.fftw.org/doc/Complex-DFTs.html>ref</a>). In some cases, namely when using the split-operator, or Suzuki-Trotter propagators, this option should be turned off. For spatial FFTs in periodic directions, the grid is never optimized, but a warning will be written if the number is not good, with a suggestion of a better one to use, so you can try a different spacing if you want to get a good number.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/mesh/ffts/fftoptimize/"
  },
  "FFTPreparePlan": {
    "type": "integer",
    "default": "fftw_measure",
    "section": "Mesh::FFTs",
    "description": "The FFTs are performed in octopus with the help of <a href=http://www.fftw.org>FFTW</a> and similar packages. Before doing the actual computations, this package prepares a \"plan\", which means that the precise numerical strategy to be followed to compute the FFT is machine/compiler-dependent, and therefore the software attempts to figure out which is this precise strategy (see the FFTW documentation for details). This plan preparation, which has to be done for each particular FFT shape, can be done exhaustively and carefully (slow), or merely estimated. Since this is a rather critical numerical step, by default it is done carefully, which implies a longer initial initialization, but faster subsequent computations. You can change this behaviour by changing this <tt>FFTPreparePlan</tt> variable, and in this way you can force FFTW to do a fast guess or estimation of which is the best way to perform the FFT.",
    "options": [
      {
        "name": "fftw_measure",
        "value": "0"
      },
      {
        "name": "fftw_estimate",
        "value": "64"
      },
      {
        "name": "fftw_patient",
        "value": "32"
      },
      {
        "name": "fftw_exhaustive",
        "value": "8"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/mesh/ffts/fftprepareplan/"
  },
  "FFTLibrary": {
    "type": "integer",
    "default": "fftw",
    "section": "Mesh::FFTs",
    "description": "(experimental) You can select the FFT library to use.",
    "options": [
      {
        "name": "fftw",
        "value": "1"
      },
      {
        "name": "pfft",
        "value": "2"
      },
      {
        "name": "accel",
        "value": "3"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/mesh/ffts/fftlibrary/"
  },
  "SPARSKITSolver": {
    "type": "integer",
    "default": "sk_bcg",
    "section": "Math::SPARSKIT",
    "description": "Specifies what kind of linear solver will be used.",
    "options": [
      {
        "name": "sk_cg",
        "value": "1"
      },
      {
        "name": "sk_cgnr",
        "value": "2"
      },
      {
        "name": "sk_bcg",
        "value": "3"
      },
      {
        "name": "sk_dbcg",
        "value": "4"
      },
      {
        "name": "sk_bcgstab",
        "value": "5"
      },
      {
        "name": "sk_tfqmr",
        "value": "6"
      },
      {
        "name": "sk_fom",
        "value": "7"
      },
      {
        "name": "sk_gmres",
        "value": "8"
      },
      {
        "name": "sk_fgmres",
        "value": "9"
      },
      {
        "name": "sk_dqgmres",
        "value": "10"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/math/sparskit/sparskitsolver/"
  },
  "SPARSKITKrylovSubspaceSize": {
    "type": "integer",
    "default": "15",
    "section": "Math::SPARSKIT",
    "description": "Some of the SPARSKIT solvers are Krylov subspace methods. This variable determines what size the solver will use for the subspace.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/math/sparskit/sparskitkrylovsubspacesize/"
  },
  "SPARSKITMaxIter": {
    "type": "integer",
    "default": "50000",
    "section": "Math::SPARSKIT",
    "description": "This variable controls the maximum number of iteration steps that will be performed by the (iterative) linear solver.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/math/sparskit/sparskitmaxiter/"
  },
  "SPARSKITIterOut": {
    "type": "integer",
    "default": "-1",
    "section": "Math::SPARSKIT",
    "description": "Determines how often status info of the solver is printed. If <= 0, will never be printed.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/math/sparskit/sparskititerout/"
  },
  "SPARSKITRelTolerance": {
    "type": "float",
    "default": "1e-8",
    "section": "Math::SPARSKIT",
    "description": "Some SPARSKIT solvers use a relative tolerance as a stopping criterion for the iterative solution process. This variable can be used to specify the tolerance.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/math/sparskit/sparskitreltolerance/"
  },
  "SPARSKITAbsTolerance": {
    "type": "float",
    "default": "1e-10",
    "section": "Math::SPARSKIT",
    "description": "Some SPARSKIT solvers use an absolute tolerance as a stopping criterion for the iterative solution process. This variable can be used to specify the tolerance.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/math/sparskit/sparskitabstolerance/"
  },
  "SPARSKITVerboseSolver": {
    "type": "logical",
    "default": "no",
    "section": "Math::SPARSKIT",
    "description": "When set to yes, the SPARSKIT solver will write more detailed output.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/math/sparskit/sparskitverbosesolver/"
  },
  "RootSolver": {
    "type": "integer",
    "default": "root_newton",
    "section": "Math::RootSolver",
    "description": "Specifies what kind of root solver will be used.",
    "options": [
      {
        "name": "root_newton",
        "value": "3"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/math/rootsolver/rootsolver/"
  },
  "RootSolverMaxIter": {
    "type": "integer",
    "default": "500",
    "section": "Math::RootSolver",
    "description": "In case of an iterative root solver, this variable determines the maximum number of iteration steps.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/math/rootsolver/rootsolvermaxiter/"
  },
  "RootSolverRelTolerance": {
    "type": "float",
    "default": "1e-10",
    "section": "Math::RootSolver",
    "description": "Relative tolerance for the root-finding process.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/math/rootsolver/rootsolverreltolerance/"
  },
  "RootSolverAbsTolerance": {
    "type": "float",
    "default": "1e-10",
    "section": "Math::RootSolver",
    "description": "Relative tolerance for the root-finding process.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/math/rootsolver/rootsolverabstolerance/"
  },
  "MainAxis": {
    "type": "block",
    "default": "",
    "section": "Utilities::oct-center-geom",
    "description": "A vector of reals defining the axis to which the molecule should be aligned. If not present, the default value will be the x-axis. For example in 3D: <tt> <br>%MainAxis <br> 1 | 0 | 0 <br>%</tt>",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-center-geom/mainaxis/"
  },
  "AxisType": {
    "type": "integer",
    "default": "inertia",
    "section": "Utilities::oct-center-geom",
    "description": "After the structure is centered, it is also aligned to a set of orthogonal axes. This variable decides which set of axes to use. Only implemented for 3D, in which case the default is <tt>inertia</tt>; otherwise <tt>none</tt> is default and the only legal value.",
    "options": [
      {
        "name": "none",
        "value": "0"
      },
      {
        "name": "inertia",
        "value": "1"
      },
      {
        "name": "pseudo_inertia",
        "value": "2"
      },
      {
        "name": "large_axis",
        "value": "3"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-center-geom/axistype/"
  },
  "PhotoelectronSpectrumOutput": {
    "type": "block",
    "default": "none",
    "section": "Utilities::oct-photoelectron_spectrum",
    "description": "Specifies what to output extracting the photoelectron cross-section informations. When we use polar coordinates the zenith axis is set by vec (default is the first laser field polarization vector), theta is the inclination angle measured from vec (from 0 to \\pi), and phi is the azimuthal angle on a plane perpendicular to vec (from 0 to 2\\pi). Each option must be in a separate row. Optionally individual output formats can be defined for each row or they can be read separately from <tt>OutputFormat</tt> variable in the input file. Example (minimal): <br><br><tt>%PhotoelectronSpectrumOutput <br>&nbsp;&nbsp;energy_tot <br>&nbsp;&nbsp;velocity_map <br>%<br></tt> Example (with OutputFormat): <br><br><tt>%PhotoelectronSpectrumOutput <br>&nbsp;&nbsp;arpes        | vtk <br>&nbsp;&nbsp;velocity_map | ncdf <br>%<br></tt>",
    "options": [
      {
        "name": "energy_tot",
        "value": "1"
      },
      {
        "name": "energy_angle",
        "value": "2"
      },
      {
        "name": "velocity_map_cut",
        "value": "3"
      },
      {
        "name": "energy_xy",
        "value": "4"
      },
      {
        "name": "energy_th_ph",
        "value": "5"
      },
      {
        "name": "velocity_map",
        "value": "6"
      },
      {
        "name": "arpes",
        "value": "7"
      },
      {
        "name": "arpes_cut",
        "value": "8"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-photoelectron_spectrum/photoelectronspectrumoutput/"
  },
  "PhotoelectronSpectrumResolveStates": {
    "type": "block",
    "default": "",
    "section": "Utilities::oct-photoelectron_spectrum",
    "description": "If <tt>yes</tt> calculate the photoelectron spectrum resolved in each K.S. state. Optionally a range of states can be given as two slot block where the first slot is the lower state index and the second is the highest one. For example to calculate the spectra from state i to state j: <tt>%PhotoelectronSpectrumResolveStates <br> i | j <br>%</tt>",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-photoelectron_spectrum/photoelectronspectrumresolvestates/"
  },
  "TDTDMFrequencies": {
    "type": "block",
    "default": "",
    "section": "Utilities::oct-tdtdm",
    "description": "This block defines for which frequencies the analysis is performed. Each row of the block indicates a frequency.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-tdtdm/tdtdmfrequencies/"
  },
  "SupercellDimensions": {
    "type": "block",
    "default": "KPointsGrid",
    "section": "Utilities::oct-tdtdm",
    "description": "This block allows to specify the size of the supercell used to plot excitonic wavefunctions. If not specified, the code uses the number of k-points for defining the size of the supercell.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-tdtdm/supercelldimensions/"
  },
  "TDTDMHoleCoordinates": {
    "type": "float",
    "default": "",
    "section": "Utilities::oct-tdtdm",
    "description": "The position of the hole used to compute the TDTDM, in Cartesian coordinates. Note that the code will use the closest grid point. The coordinates of the hole are specified in the following way <tt>%TDTDMHoleCoordinates <br>&nbsp;&nbsp;hole_x | hole_y | hole_z <br>%</tt> If TDTDMHoleCoordinates or TDTDMHoleReducedCoordinates are not specified, the code will use the coordinate of the first atom in the cell.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-tdtdm/tdtdmholecoordinates/"
  },
  "TDTDMHoleReducedCoordinates": {
    "type": "float",
    "default": "",
    "section": "Utilities::oct-tdtdm",
    "description": "Same as TDTDMHoleCoordinates, except that coordinates are given in reduced coordinates",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-tdtdm/tdtdmholereducedcoordinates/"
  },
  "TransientMagnetizationReference": {
    "type": "string",
    "default": "\".\"",
    "section": "Utilities::oct-spin_susceptibility",
    "description": "In case of delayed kick, the calculation of the transient spin susceptibility requires to substract a reference calculation, containing dynamics of the magnetization without the kick This reference must be computed having TDOutput = total_magnetization. This variables defined the directory in which the reference total_magnetization file is, relative to the current folder",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-spin_susceptibility/transientmagnetizationreference/"
  },
  "UnfoldMode": {
    "type": "flag",
    "default": "none",
    "section": "Utilities::oct-unfold",
    "description": "Specifies which stage of the unfolding tool to use",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-unfold/unfoldmode/"
  },
  "UnfoldLatticeParameters": {
    "type": "block",
    "default": "",
    "section": "Utilities::oct-unfold",
    "description": "The lattice parameters of the primitive cell, on which unfolding is performed. See the LatticeParameters variable for a more detailed description.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-unfold/unfoldlatticeparameters/"
  },
  "UnfoldLatticeVectors": {
    "type": "block",
    "default": "simple cubic",
    "section": "Utilities::oct-unfold",
    "description": "Lattice vectors of the primitive cell on which the unfolding is performed. See the LatticeVectors variable for a more detailed description.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-unfold/unfoldlatticevectors/"
  },
  "UnfoldKPointsPath": {
    "type": "block",
    "default": "",
    "section": "Utilities::oct-unfold",
    "description": "Specifies the k-point path for which the unfolding need to be done. The syntax is identical to <tt>KPointsPath</tt>.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-unfold/unfoldkpointspath/"
  },
  "UnfoldEnergyStep": {
    "type": "float",
    "default": "0",
    "section": "Utilities::oct-unfold",
    "description": "Specifies the energy resolution for the unfolded band structure. If you specify 0, the resolution will be set to be 1/1000 points between <tt>UnfoldMinEnergy</tt> and <tt>UnfoldMaxEnergy</tt>",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-unfold/unfoldenergystep/"
  },
  "UnfoldMinEnergy": {
    "type": "float",
    "default": "",
    "section": "Utilities::oct-unfold",
    "description": "Specifies the start of the energy range for the unfolded band structure. The default value correspond to the samllest eigenvalue.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-unfold/unfoldminenergy/"
  },
  "UnfoldMaxEnergy": {
    "type": "float",
    "default": "",
    "section": "Utilities::oct-unfold",
    "description": "Specifies the end of the energy range for the unfolded band structure. The default value correspond to the largest eigenvalue.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-unfold/unfoldmaxenergy/"
  },
  "Wannier90Prefix": {
    "type": "string",
    "default": "w90",
    "section": "Utilities::oct-wannier90",
    "description": "Prefix for wannier90 files",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-wannier90/wannier90prefix/"
  },
  "Wannier90Mode": {
    "type": "integer",
    "default": "0",
    "section": "Utilities::oct-wannier90",
    "description": "Specifies which stage of the Wannier90 interface to use",
    "options": [
      {
        "name": "none",
        "value": "0"
      },
      {
        "name": "w90_setup",
        "value": "1"
      },
      {
        "name": "w90_output",
        "value": "2"
      },
      {
        "name": "w90_wannier",
        "value": "3"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-wannier90/wannier90mode/"
  },
  "Wannier90Files": {
    "type": "flag",
    "default": "w90_mmn + w90_amn + w90_eig",
    "section": "Utilities::oct-wannier90",
    "description": "Specifies which files to generate. Example: <tt>w90_mmn + w90_unk</tt>",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-wannier90/wannier90files/"
  },
  "Wannier90UseTD": {
    "type": "logical",
    "default": "no",
    "section": "Utilities::oct-wannier90",
    "description": "By default oct-wannier90 uses the ground-state states to compute the necessary information. By setting this variable to yes, oct-wannier90 will use the TD states instead.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-wannier90/wannier90usetd/"
  },
  "Wannier90UseSCDM": {
    "type": "logical",
    "default": "no",
    "section": "Utilities::oct-wannier90",
    "description": "By default oct-wannier90 uses the projection method to generate the .amn file. By setting this variable to yes, oct-wannier90 will use SCDM method instead.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-wannier90/wannier90usescdm/"
  },
  "SCDMsigma": {
    "type": "float",
    "default": "0.2",
    "section": "Utilities::oct-wannier90",
    "description": "Broadening of SCDM smearing function.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-wannier90/scdmsigma/"
  },
  "SCDMmu": {
    "type": "float",
    "default": "",
    "section": "Utilities::oct-wannier90",
    "description": "Energy range up to which states are considered for SCDM.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-wannier90/scdmmu/"
  },
  "AnimationSampling": {
    "type": "integer",
    "default": "100",
    "section": "Utilities::oct-xyz-anim",
    "description": "Sampling rate of the animation. The animation will be constructed using the iteration numbers that are multiples of <tt>AnimationSampling</tt>.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-xyz-anim/animationsampling/"
  },
  "AnimationMultiFiles": {
    "type": "logical",
    "default": "false",
    "section": "Utilities::oct-xyz-anim",
    "description": "If true, each iteration written will be in a separate file.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-xyz-anim/animationmultifiles/"
  },
  "TransientAbsorptionReference": {
    "type": "string",
    "default": "\".\"",
    "section": "Utilities::oct-propagation_spectrum",
    "description": "In case of delayed kick, the calculation of the transient absorption requires to substract a reference calculation, containing the gauge-field without the kick This reference must be computed using GaugeFieldPropagate=yes and to have TDOutput = gauge_field. This variables defined the directory in which the reference gauge_field field is, relative to the current folder",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-propagation_spectrum/transientabsorptionreference/"
  },
  "CasidaSpectrumBroadening": {
    "type": "float",
    "default": "0.005 Ha",
    "section": "Utilities::oct-casida_spectrum",
    "description": "Width of the Lorentzian used to broaden the excitations.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-casida_spectrum/casidaspectrumbroadening/"
  },
  "CasidaSpectrumEnergyStep": {
    "type": "float",
    "default": "0.001 Ha",
    "section": "Utilities::oct-casida_spectrum",
    "description": "Sampling rate for the spectrum.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-casida_spectrum/casidaspectrumenergystep/"
  },
  "CasidaSpectrumMinEnergy": {
    "type": "float",
    "default": "0.0",
    "section": "Utilities::oct-casida_spectrum",
    "description": "The broadening is done for energies greater than <tt>CasidaSpectrumMinEnergy</tt>.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-casida_spectrum/casidaspectrumminenergy/"
  },
  "CasidaSpectrumMaxEnergy": {
    "type": "float",
    "default": "1.0 Ha",
    "section": "Utilities::oct-casida_spectrum",
    "description": "The broadening is done for energies smaller than <tt>CasidaSpectrumMaxEnergy</tt>.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-casida_spectrum/casidaspectrummaxenergy/"
  },
  "CasidaSpectrumRotationMatrix": {
    "type": "block",
    "default": "identity",
    "section": "Utilities::oct-casida_spectrum",
    "description": "Supply a rotation matrix to apply to the transition dipoles in generating the spectrum. The rotated atomic structure will also be output. Size of matrix must be <tt>Dimensions</tt>.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-casida_spectrum/casidaspectrumrotationmatrix/"
  },
  "LDFolder": {
    "type": "string",
    "default": "",
    "section": "Utilities::oct-local_multipoles",
    "description": "The folder name where the density used as input file is.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-local_multipoles/ldfolder/"
  },
  "LDFilename": {
    "type": "string",
    "default": "'density'",
    "section": "Utilities::oct-local_multipoles",
    "description": "Input filename. The original filename for the density which is going to be fragmented into domains.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-local_multipoles/ldfilename/"
  },
  "LDUpdate": {
    "type": "logical",
    "default": "false",
    "section": "Utilities::oct-local_multipoles",
    "description": "Controls if the calculation of the local domains is desired at each iteration.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-local_multipoles/ldupdate/"
  },
  "LDOverWrite": {
    "type": "logical",
    "default": "true",
    "section": "Utilities::oct-local_multipoles",
    "description": "Controls whether to over-write existing files.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-local_multipoles/ldoverwrite/"
  },
  "LDRadiiFile": {
    "type": "string",
    "default": "'default'",
    "section": "Utilities::oct-local_multipoles",
    "description": "Full path for the radii file. If set, def_rsize will be reset to the new values. This file should have the same format as share/PP/default.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-local_multipoles/ldradiifile/"
  },
  "LDRestart": {
    "type": "logical",
    "default": "false",
    "section": "Utilities::oct-local_multipoles",
    "description": "Restart information will be read from <tt>LDRestartFolder</tt>.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-local_multipoles/ldrestart/"
  },
  "LDRestartFolder": {
    "type": "string",
    "default": "\"ld.general\"",
    "section": "Utilities::oct-local_multipoles",
    "description": "The folder name where the density used as input file is.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-local_multipoles/ldrestartfolder/"
  },
  "LDIterateFolder": {
    "type": "logical",
    "default": "false",
    "section": "Utilities::oct-local_multipoles",
    "description": "This variable decides if a folder is going to be iterated.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-local_multipoles/lditeratefolder/"
  },
  "LDStart": {
    "type": "integer",
    "default": "0",
    "section": "Utilities::oct-local_multipoles",
    "description": "The starting number of the filename or folder.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-local_multipoles/ldstart/"
  },
  "LDEnd": {
    "type": "integer",
    "default": "0",
    "section": "Utilities::oct-local_multipoles",
    "description": "The last number of the filename or folder.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-local_multipoles/ldend/"
  },
  "LDStep": {
    "type": "integer",
    "default": "1",
    "section": "Utilities::oct-local_multipoles",
    "description": "The padding between the filenames or folder.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-local_multipoles/ldstep/"
  },
  "LocalDomains": {
    "type": "block",
    "default": "",
    "section": "Utilities::oct-local_multipoles",
    "description": "The LocalDomains are by definition part of the global grid. The domains are defined by selecting a type shape. The domain box will be constructed using the given parameters. A local domain could be construct by addition of several box centered on the ions. The grid points inside this box will belong to the local domain. The format of this block is the following:<br> <tt> 'Label' | Shape | %< | Shape dependencies >% </tt> <br>The first field is the label of the domain. Label = string with the name of the new local domain. The second is the shape type of the box used to define the domain. Shape = SPHERE, CYLINDER, PARALLELEPIPED, MINIMUM, BADER. Some types may need some parameters given in the remaining fields of the row. (the valid options are detailed below). <tt>%LocalDomains <br>case (SPHERE):         | rsize | %<dim origin coordinates> <br>case (CYLINDER):       | rsize | xsize | %<origin coordinates> <br>case (PARALLELEPIPED): | %<lsize> | %<origin coordinates> <br>case (MINIMUM):        | rsize | 'center_list' <br>case (BADER):          | 'center_list' <br>%</tt> <br>rsize: Radius in input length units <br>xsize: the length of the cylinder in the x-direction <br>origin coordinates: in input length units separated by |, where the box is centered. <br>lsize: half of the length of the parallelepiped in each direction. <br>center_list: string containing the list of atoms in xyz file for each domain in the form \"2,16-23\"",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-local_multipoles/localdomains/"
  },
  "LDBaderThreshold": {
    "type": "float",
    "default": "0.01",
    "section": "Utilities::oct-local_multipoles",
    "description": "This variable sets the threshold for the basins calculations. Recommended values: 0.01 -> intramolecular volumes; 0.2 -> intermolecular volumes.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-local_multipoles/ldbaderthreshold/"
  },
  "LDUseAtomicRadii": {
    "type": "logical",
    "default": "false",
    "section": "Utilities::oct-local_multipoles",
    "description": "If set, atomic radii will be used to assign lone pairs to ion.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-local_multipoles/lduseatomicradii/"
  },
  "ConvertFilename": {
    "type": "string",
    "default": "\"density\"",
    "section": "Utilities::oct-convert",
    "description": "Input filename. The original filename which is going to be converted in the format specified in <tt>OutputFormat</tt>. It is going to convert various files, it should only contain the beginning of the name. For instance, in the case of the restart files, it should be one space ' '.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-convert/convertfilename/"
  },
  "ConvertHow": {
    "type": "integer",
    "default": "convert_format",
    "section": "Utilities::oct-convert",
    "description": "Select how the mesh function will be converted.",
    "options": [
      {
        "name": "format",
        "value": "1"
      },
      {
        "name": "fourier_transform",
        "value": "2"
      },
      {
        "name": "operation",
        "value": "3"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-convert/converthow/"
  },
  "ConvertIterateFolder": {
    "type": "logical",
    "default": "true",
    "section": "Utilities::oct-convert",
    "description": "This variable decides if a folder is going to be iterated or the filename is going to be iterated.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-convert/convertiteratefolder/"
  },
  "ConvertFolder": {
    "type": "string",
    "default": "",
    "section": "Utilities::oct-convert",
    "description": "The folder name where the input files are. The default is <tt>td.</tt> if <tt>ConvertIterateFolder = true</tt>, otherwise <tt>restart</tt>.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-convert/convertfolder/"
  },
  "ConvertStart": {
    "type": "integer",
    "default": "is 0 if <tt>ConvertIterateFolder = true</tt>, otherwise 1.",
    "section": "Utilities::oct-convert",
    "description": "The starting number of the filename or folder.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-convert/convertstart/"
  },
  "ConvertEnd": {
    "type": "integer",
    "default": "1",
    "section": "Utilities::oct-convert",
    "description": "The last number of the filename or folder.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-convert/convertend/"
  },
  "ConvertStep": {
    "type": "integer",
    "default": "1",
    "section": "Utilities::oct-convert",
    "description": "The padding between the filenames or folder.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-convert/convertstep/"
  },
  "ConvertSubtractFilename": {
    "type": "string",
    "default": "density",
    "section": "Utilities::oct-convert",
    "description": "Input filename. The file which is going to subtracted to rest of the files.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-convert/convertsubtractfilename/"
  },
  "ConvertSubtract": {
    "type": "logical",
    "default": "false",
    "section": "Utilities::oct-convert",
    "description": "Decides if a reference file is going to be subtracted.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-convert/convertsubtract/"
  },
  "ConvertSubtractFolder": {
    "type": "string",
    "default": ".",
    "section": "Utilities::oct-convert",
    "description": "The folder name which is going to be subtracted.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-convert/convertsubtractfolder/"
  },
  "ConvertEnergyMin": {
    "type": "float",
    "default": "0.0",
    "section": "Utilities::oct-convert",
    "description": "Minimum energy to output from Fourier transform.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-convert/convertenergymin/"
  },
  "ConvertReadSize": {
    "type": "integer",
    "default": "mesh%np",
    "section": "Utilities::oct-convert",
    "description": "How many points are read at once. For the parallel run this has not been yet tested, so it should be one. For the serial run, a number of 100-1000 will speed-up the execution time by this factor.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-convert/convertreadsize/"
  },
  "ConvertEnergyMax": {
    "type": "float",
    "default": "w_max",
    "section": "Utilities::oct-convert",
    "description": "Maximum energy to output from Fourier transform.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-convert/convertenergymax/"
  },
  "ConvertFTMethod": {
    "type": "integer",
    "default": "FAST_FOURIER",
    "section": "Utilities::oct-convert",
    "description": "Describes the method used to perform the Fourier Transform",
    "options": [
      {
        "name": "fast_fourier",
        "value": "1"
      },
      {
        "name": "standard_fourier",
        "value": "2"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-convert/convertftmethod/"
  },
  "ConvertEnergyStep": {
    "type": "float",
    "default": "<math>2 \\pi / T</math>, where <math>T</math> is the total propagation time",
    "section": "Utilities::oct-convert",
    "description": "Energy step to output from Fourier transform. Sampling rate for the Fourier transform. If you supply a number equal or smaller than zero, then the sampling rate will be <math>2 \\pi / T</math>, where <math>T</math> is the total propagation time.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-convert/convertenergystep/"
  },
  "ConvertScalarOperation": {
    "type": "block",
    "default": "",
    "section": "Utilities::oct-convert",
    "description": "This variable is used to generate a new mesh function as a linear combination different mesh function having the same mesh. Each row defines an operation for for a single mesh function. The format of the block is the following: <br> 'variable name' | 'folder' | 'file' | 'operation'",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-convert/convertscalaroperation/"
  },
  "ConvertOutputFolder": {
    "type": "string",
    "default": "",
    "section": "Utilities::oct-convert",
    "description": "The folder name where the output files will be write. The default is <tt>convert</tt>.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-convert/convertoutputfolder/"
  },
  "ConvertOutputFilename": {
    "type": "string",
    "default": "\"density\"",
    "section": "Utilities::oct-convert",
    "description": "Output filename. The name of the file in which the converted mesh function will be written in the format specified in <tt>OutputFormat</tt>.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-convert/convertoutputfilename/"
  },
  "ConductivitySpectrumTimeStepFactor": {
    "type": "integer",
    "default": "1",
    "section": "Utilities::oct-conductivity_spectrum",
    "description": "In the calculation of the conductivity, it is not necessary to read the velocity at every time step. This variable controls the integer factor between the simulation time step and the time step used to calculate the conductivity.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-conductivity_spectrum/conductivityspectrumtimestepfactor/"
  },
  "ConductivityFromForces": {
    "type": "logical",
    "default": "no",
    "section": "Utilities::oct-conductivity_spectrum",
    "description": "(Experimental) If enabled, Octopus will attempt to calculate the conductivity from the forces instead of the current.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-conductivity_spectrum/conductivityfromforces/"
  },
  "VibrationalSpectrumTimeStepFactor": {
    "type": "integer",
    "default": "10",
    "section": "Utilities::oct-vibrational_spectrum",
    "description": "In the calculation of the vibrational spectrum, it is not necessary to read the velocity at every time step. This variable controls the integer factor between the simulation time step and the time step used to calculate the vibrational spectrum.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-vibrational_spectrum/vibrationalspectrumtimestepfactor/"
  },
  "VibrationalSpectrumTime": {
    "type": "integer",
    "default": "",
    "section": "Utilities::oct-vibrational_spectrum",
    "description": "This variable controls the maximum time for the calculation of the velocity autocorrelation function. The default is the total propagation time.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-vibrational_spectrum/vibrationalspectrumtime/"
  },
  "LDOutput": {
    "type": "flag",
    "default": "multipoles",
    "section": "Utilities::oct-local_multipoles",
    "description": "Defines what should be output during the local domains simulation. Many of the options can increase the computational cost of the simulation, so only use the ones that you need. In most cases the default value is enough, as it is adapted to the details.",
    "options": [
      {
        "name": "multipoles",
        "value": "1"
      },
      {
        "name": "density",
        "value": "2"
      },
      {
        "name": "local_v",
        "value": "4"
      },
      {
        "name": "energy",
        "value": "8"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-local_multipoles/ldoutput/"
  },
  "LDOutputFormat": {
    "type": "flag",
    "default": "none",
    "section": "Utilities::oct-local_multipoles",
    "description": "Describes the format of the output files (see <tt>LDOutput</tt>). It can take the same values as <tt>OutputFormat</tt> flag.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-local_multipoles/ldoutputformat/"
  },
  "LDMultipoleLmax": {
    "type": "integer",
    "default": "1",
    "section": "Utilities::oct-local_multipoles",
    "description": "Maximum electric multipole of the density output to the file <tt>local.multipoles/<>domain%<>.multipoles</tt> during a time-dependent simulation. Must be non-negative.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-local_multipoles/ldmultipolelmax/"
  },
  "LDIonicDipole": {
    "type": "logical",
    "default": "yes",
    "section": "Utilities::oct-local_multipoles",
    "description": "Describes if the ionic dipole has to be take into account when computing the multipoles.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/utilities/oct-local_multipoles/ldionicdipole/"
  },
  "DFTUBasisFromStates": {
    "type": "logical",
    "default": "no",
    "section": "Hamiltonian::DFT+U",
    "description": "If set to yes, Octopus will construct the localized basis from user-defined states. The states are taken at the Gamma point (or the first k-point of the states in the restart_proj folder. The states are defined via the block DFTUBasisStates",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/dft+u/dftubasisfromstates/"
  },
  "DFTUDoubleCounting": {
    "type": "integer",
    "default": "dft_u_fll",
    "section": "Hamiltonian::DFT+U",
    "description": "This variable selects which DFT+U double counting term is used.",
    "options": [
      {
        "name": "dft_u_fll",
        "value": "0"
      },
      {
        "name": "dft_u_amf",
        "value": "1"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/dft+u/dftudoublecounting/"
  },
  "DFTUPoissonSolver": {
    "type": "integer",
    "default": "",
    "section": "Hamiltonian::DFT+U",
    "description": "This variable selects which Poisson solver is used to compute the Coulomb integrals over a submesh. These are non-periodic Poisson solvers. The FFT Poisson solver with spherical cutoff is used by default.",
    "options": [
      {
        "name": "dft_u_poisson_direct",
        "value": "0"
      },
      {
        "name": "dft_u_poisson_isf",
        "value": "1"
      },
      {
        "name": "dft_u_poisson_psolver",
        "value": "2"
      },
      {
        "name": "dft_u_poisson_fft",
        "value": "3"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/dft+u/dftupoissonsolver/"
  },
  "UseAllAtomicOrbitals": {
    "type": "logical",
    "default": "no",
    "section": "Hamiltonian::DFT+U",
    "description": "If set to yes, Octopus will determine the effective U for all atomic orbitals from the peusopotential. Only available with ACBN0 functional. It is strongly recommended to set AOLoewdin=yes when using the option.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/dft+u/useallatomicorbitals/"
  },
  "SkipSOrbitals": {
    "type": "logical",
    "default": "no",
    "section": "Hamiltonian::DFT+U",
    "description": "If set to yes, Octopus will determine the effective U for all atomic orbitals from the peusopotential but s orbitals. Only available with ACBN0 functional.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/dft+u/skipsorbitals/"
  },
  "ACBN0Screening": {
    "type": "float",
    "default": "1.0",
    "section": "Hamiltonian::DFT+U",
    "description": "If set to 0, no screening will be included in the ACBN0 functional, and the U will be estimated from bare Hartree-Fock. If set to 1 (default), the full screening of the U, as defined in the ACBN0 functional, is used.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/dft+u/acbn0screening/"
  },
  "ACBN0RotationallyInvariant": {
    "type": "logical",
    "default": "",
    "section": "Hamiltonian::DFT+U",
    "description": "If set to yes, Octopus will use for U and J a formula which is rotationally invariant. This is different from the original formula for U and J. This is activated by default, except in the case of spinors, as this is not yet implemented in this case.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/dft+u/acbn0rotationallyinvariant/"
  },
  "ACBN0IntersiteInteraction": {
    "type": "logical",
    "default": "no",
    "section": "Hamiltonian::DFT+U",
    "description": "If set to yes, Octopus will determine the effective intersite interaction V Only available with ACBN0 functional. It is strongly recommended to set AOLoewdin=yes when using the option.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/dft+u/acbn0intersiteinteraction/"
  },
  "ACBN0IntersiteCutoff": {
    "type": "float",
    "default": "",
    "section": "Hamiltonian::DFT+U",
    "description": "The cutoff radius defining the maximal intersite distance considered. Only available with ACBN0 functional with intersite interaction.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/dft+u/acbn0intersitecutoff/"
  },
  "DFTUBasisStates": {
    "type": "block",
    "default": "none",
    "section": "Hamiltonian::DFT+U",
    "description": "This block starts by a line containing a single integer describing the number of orbital sets. One orbital set is a group of orbitals on which one adds a Hubbard U. Each following line of this block contains the index of a state to be used to construct the localized basis, followed by the index of the corresponding orbital set. See DFTUBasisFromStates for details.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/dft+u/dftubasisstates/"
  },
  "TDDeltaKickTime": {
    "type": "float",
    "default": "0.0",
    "section": "Time-Dependent::Response",
    "description": "The delta-perturbation that can be applied by making use of the <tt>TDDeltaStrength</tt> variable, can be applied at the time given by this variable. Usually, this time is zero, since one wants to apply the delta pertubation or \"kick\" at a system at equilibrium, and no other time-dependent external potential is used. However, one may want to apply a kick on top of a laser field, for example.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/response/tddeltakicktime/"
  },
  "TDDeltaStrength": {
    "type": "float",
    "default": "0",
    "section": "Time-Dependent::Response",
    "description": "When no laser is applied, a delta (in time) perturbation with strength <tt>TDDeltaStrength</tt> can be applied. This is used to calculate, <i>e.g.</i>, the linear optical spectra. If the ions are allowed to move, the kick will affect them also. The electric field is <math>-(\\hbar k / e) \\delta(t)</math> for a dipole with zero wavevector, where <i>k</i> = <tt>TDDeltaStrength</tt>, which causes the wavefunctions instantaneously to acquire a phase <math>e^{ikx}</math>. The unit is inverse length.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/response/tddeltastrength/"
  },
  "TDDeltaStrengthMode": {
    "type": "integer",
    "default": "kick_density",
    "section": "Time-Dependent::Response",
    "description": "When calculating the density response via real-time propagation, one needs to perform an initial kick on the KS system, at time zero. Depending on what kind of response property one wants to obtain, this kick may be done in several modes. For use to calculate triplet excitations, see MJT Oliveira, A Castro, MAL Marques, and A Rubio, <i>J. Nanoscience and Nanotechnology</i> <b>8</b>, 3392 (2008).",
    "options": [
      {
        "name": "kick_density",
        "value": "0"
      },
      {
        "name": "kick_spin",
        "value": "1"
      },
      {
        "name": "kick_spin_and_density",
        "value": "2"
      },
      {
        "name": "kick_magnon",
        "value": "3"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/response/tddeltastrengthmode/"
  },
  "TDDeltaUserDefined": {
    "type": "string",
    "default": "",
    "section": "Time-Dependent::Response",
    "description": "By default, the kick function will be a dipole. This will change if (1) the variable <tt>TDDeltaUserDefined</tt> is present in the inp file, or (2) if the block <tt>TDKickFunction</tt> is present in the <tt>inp</tt> file. If both are present in the <tt>inp</tt> file, the <tt>TDKickFunction</tt> block will be ignored. The value of <tt>TDDeltaUserDefined</tt> should be a string describing the function that is going to be used as delta perturbation.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/response/tddeltauserdefined/"
  },
  "TDKickFunction": {
    "type": "block",
    "default": "",
    "section": "Time-Dependent::Response",
    "description": "If the block <tt>TDKickFunction</tt> is present in the input file, and the variable <tt>TDDeltaUserDefined</tt> is not present in the input file, the kick function to be applied at time zero of the time-propagation will not be a \"dipole\" function (<i>i.e.</i> <math>\\phi \\rightarrow e^{ikx} \\phi</math>, but a general multipole in the form <math>r^l Y_{lm}(r)</math>. Each line has three columns: integers <i>l</i> and <i>m</i> that defines the multipole, and a weight. Any number of lines may be given, and the kick will be the sum of those multipoles with the given weights. This feature allows calculation of quadrupole, octupole, etc., response functions.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/response/tdkickfunction/"
  },
  "TDPolarizationEquivAxes": {
    "type": "integer",
    "default": "0",
    "section": "Time-Dependent::Response::Dipole",
    "description": "Defines how many of the <tt>TDPolarization</tt> axes are equivalent. This information is stored in a file and then used by <tt>oct-propagation_spectrum</tt> to rebuild the full polarizability tensor from just the first <tt>TDPolarizationEquivAxes</tt> directions. This variable is also used by <tt>CalculationMode = vdw</tt>.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/response/dipole/tdpolarizationequivaxes/"
  },
  "TDPolarizationDirection": {
    "type": "integer",
    "default": "",
    "section": "Time-Dependent::Response::Dipole",
    "description": "When a delta potential is included in a time-dependent run, this variable defines in which direction the field will be applied by selecting one of the lines of <tt>TDPolarization</tt>. In a typical run (without using symmetry), the <tt>TDPolarization</tt> block would contain the three Cartesian unit vectors (the default value), and one would make 3 runs varying <tt>TDPolarization</tt> from 1 to 3. If one is using symmetry,  <tt>TDPolarization</tt> should run only from 1 to <tt>TDPolarizationEquivAxes</tt>.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/response/dipole/tdpolarizationdirection/"
  },
  "TDPolarization": {
    "type": "block",
    "default": "",
    "section": "Time-Dependent::Response::Dipole",
    "description": "The (real) polarization of the delta electric field. Normally one needs three perpendicular polarization directions to calculate a spectrum (unless symmetry is used). The format of the block is: <tt>%TDPolarization <br>&nbsp;&nbsp;pol1x | pol1y | pol1z <br>&nbsp;&nbsp;pol2x | pol2y | pol2z <br>&nbsp;&nbsp;pol3x | pol3y | pol3z <br>%</tt> <tt>Octopus</tt> uses both this block and the variable <tt>TDPolarizationDirection</tt> to determine the polarization vector for the run. For example, if <tt>TDPolarizationDirection=2</tt> the polarization <tt>(pol2x, pol2y, pol2z)</tt> would be used. These directions may not be in periodic directions. The default value for <tt>TDPolarization</tt> is the three Cartesian unit vectors (1,0,0), (0,1,0), and (0,0,1). Note that the directions do not necessarily need to be perpendicular when symmetries are used. WARNING: If you want to obtain the cross-section tensor, the <tt>TDPolarization</tt> block must be exactly the same for the run in each direction. The direction must be selected by the <tt>TDPolarizationDirection</tt> variable.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/response/dipole/tdpolarization/"
  },
  "TDPolarizationWprime": {
    "type": "block",
    "default": "",
    "section": "Time-Dependent::Response::Dipole",
    "description": "This block is needed only when <tt>TDPolarizationEquivAxes</tt> is set to 3.  In such a case, the three directions (<i>pol1</i>, <i>pol2</i>, and <i>pol3</i>) defined in the <tt>TDPolarization</tt> block should be related by symmetry operations. If <i>A</i> is the symmetry operation that takes you from <i>pol1</i> to <i>pol2</i>, then <tt>TDPolarizationWprime</tt> should be set to the direction defined by <i>A</i><math>^{-1}</math><i>pol3</i>. For more information see MJT Oliveira <i>et al.</i>, <i>J. Nanoscience and Nanotechnology</i> <b>8</b>, 3392 (2008).",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/response/dipole/tdpolarizationwprime/"
  },
  "TDReducedMomentumTransfer": {
    "type": "block",
    "default": "",
    "section": "Time-Dependent::Response",
    "description": "The same as TDMomentumTransfer, but the momentum is specified in reduced coordinates. Only available for magnon kicks at the moment, and only with an exponential kick.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/response/tdreducedmomentumtransfer/"
  },
  "TDMomentumTransfer": {
    "type": "block",
    "default": "",
    "section": "Time-Dependent::Response",
    "description": "Momentum-transfer vector for the calculation of the dynamic structure factor. When this variable is set, a non-dipole field is applied, and an output file <tt>ftchd</tt> is created (it contains the Fourier transform of the charge density at each time). The type of the applied external field can be set by an optional last number. Possible options are <tt>qexp</tt> (default), <tt>qcos</tt>, <tt>qsin</tt>, or <tt>qcos+qsin</tt>. In the formulae below, <math>\\vec{q}</math> is the momentum-transfer vector.",
    "options": [
      {
        "name": "qexp",
        "value": "1"
      },
      {
        "name": "qcos",
        "value": "2"
      },
      {
        "name": "qsin",
        "value": "3"
      },
      {
        "name": "qbessel",
        "value": "4"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/response/tdmomentumtransfer/"
  },
  "TDEasyAxis": {
    "type": "block",
    "default": "",
    "section": "Time-Dependent::Response::Dipole",
    "description": "For magnon kicks only. This variable defines the direction of the easy axis of the crystal. The magnetization is kicked in the plane transverse to this vector",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/response/dipole/tdeasyaxis/"
  },
  "TDMultipleMomentumTransfer": {
    "type": "block",
    "default": "",
    "section": "Time-Dependent::Response",
    "description": "For magnon kicks only. A simple way to specify momentum-transfer vectors for the calculation of the magnetization dynamics. This variable should be used for a supercell. For each reciprocal lattice vectors, the code will kick the original magnetization using all the multiples of it. The syntax reads: <tt>%TDMultipleMomentumTransfer <br>&nbsp;&nbsp;N_x | N_y | N_z <br>%</tt> and will include the (2N_x+1)*(2N_y+1)*(2N_z+1) multiples vectors of the reciprocal lattice vectors of the current cell.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/response/tdmultiplemomentumtransfer/"
  },
  "libvdwxcDebug": {
    "type": "logical",
    "default": "",
    "section": "Hamiltonian::XC",
    "description": "Dump libvdwxc inputs and outputs to files.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/xc/libvdwxcdebug/"
  },
  "libvdwxcVDWFactor": {
    "type": "float",
    "default": "",
    "section": "Hamiltonian::XC",
    "description": "Prefactor of non-local van der Waals functional. Setting a prefactor other than one is wrong, but useful for debugging.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/xc/libvdwxcvdwfactor/"
  },
  "libvdwxcMode": {
    "type": "integer",
    "default": "",
    "section": "Hamiltonian::XC",
    "description": "Whether libvdwxc should run with serial fftw3, fftw3-mpi, or pfft. to specify fftw3-mpi in serial for debugging. pfft is not implemented at the moment.",
    "options": [
      {
        "name": "libvdwxc_mode_auto",
        "value": "1"
      },
      {
        "name": "libvdwxc_mode_serial",
        "value": "2"
      },
      {
        "name": "libvdwxc_mode_mpi",
        "value": "3"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/xc/libvdwxcmode/"
  },
  "RashbaSpinOrbitCoupling": {
    "type": "float",
    "default": "0.0",
    "section": "Hamiltonian",
    "description": "(Experimental.) For systems described in 2D (electrons confined to 2D in semiconductor structures), one may add the Bychkov-Rashba spin-orbit coupling term [Bychkov and Rashba, <i>J. Phys. C: Solid State Phys.</i> <b>17</b>, 6031 (1984)]. This variable determines the strength of this perturbation, and has dimensions of energy times length.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/rashbaspinorbitcoupling/"
  },
  "CalculateSelfInducedMagneticField": {
    "type": "logical",
    "default": "no",
    "section": "Hamiltonian",
    "description": "The existence of an electronic current implies the creation of a self-induced magnetic field, which may in turn back-react on the system. Of course, a fully consistent treatment of this kind of effect should be done in QED theory, but we will attempt a first approximation to the problem by considering the lowest-order relativistic terms plugged into the normal Hamiltonian equations (spin-other-orbit coupling terms, etc.). For the moment being, none of this is done, but a first step is taken by calculating the induced magnetic field of a system that has a current, by considering the magnetostatic approximation and Biot-Savart law: <math> \\nabla^2 \\vec{A} + 4\\pi\\alpha \\vec{J} = 0</math> <math> \\vec{B} = \\vec{\\nabla} \\times \\vec{A}</math> If <tt>CalculateSelfInducedMagneticField</tt> is set to yes, this <i>B</i> field is calculated at the end of a <tt>gs</tt> calculation (nothing is done -- yet -- in the <tt>td</tt>case) and printed out, if the <tt>Output</tt> variable contains the <tt>potential</tt> keyword (the prefix of the output files is <tt>Bind</tt>).",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/calculateselfinducedmagneticfield/"
  },
  "DFTULevel": {
    "type": "integer",
    "default": "no",
    "section": "Hamiltonian::XC",
    "description": "This variable selects which DFT+U expression is added to the Hamiltonian.",
    "options": [
      {
        "name": "dft_u_none",
        "value": "0"
      },
      {
        "name": "dft_u_empirical",
        "value": "1"
      },
      {
        "name": "dft_u_acbn0",
        "value": "2"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/xc/dftulevel/"
  },
  "HamiltonianApplyPacked": {
    "type": "logical",
    "default": "yes",
    "section": "Execution::Optimization",
    "description": "If set to yes (the default), Octopus will 'pack' the wave-functions when operating with them. This might involve some additional copying but makes operations more efficient. See also the related <tt>StatesPack</tt> variable.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/optimization/hamiltonianapplypacked/"
  },
  "TimeZero": {
    "type": "logical",
    "default": "no",
    "section": "Hamiltonian",
    "description": "(Experimental) If set to yes, the ground state and other time dependent calculation will assume that they are done at time zero, so that all time depedent field at that time will be included.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/timezero/"
  },
  "MaxwellCouplingMode": {
    "type": "integer",
    "default": "none",
    "section": "Hamiltonian",
    "description": "This variable selects the level of Maxwell-matter coupling.",
    "options": [
      {
        "name": "none",
        "value": "0"
      },
      {
        "name": "length_gauge_dipole",
        "value": "1"
      },
      {
        "name": "velocity_gauge_dipole",
        "value": "2"
      },
      {
        "name": "full_minimal_coupling",
        "value": "3"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/maxwellcouplingmode/"
  },
  "MaxwellDipoleField": {
    "type": "integer",
    "default": "average",
    "section": "Hamiltonian",
    "description": "This variable selects the method to get the E field vector at the position of the system if Maxwell-matter coupling at dipole level within length gauge is done.",
    "options": [
      {
        "name": "average",
        "value": "0"
      },
      {
        "name": "center_of_mass",
        "value": "1"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/maxwelldipolefield/"
  },
  "VDW_TS_cutoff": {
    "type": "float",
    "default": "10.0",
    "section": "Hamiltonian::XC",
    "description": "Set the value of the cutoff (unit of length) for the VDW correction in periodic system in the Tkatchenko and Scheffler (vdw_ts) scheme only.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/xc/vdw_ts_cutoff/"
  },
  "VDW_TS_damping": {
    "type": "float",
    "default": "20.0",
    "section": "Hamiltonian::XC",
    "description": "Set the value of the damping function (in unit of 1/length) steepness for the VDW correction in the Tkatchenko-Scheffler scheme. See Equation (12) of Phys. Rev. Lett. 102 073005 (2009).",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/xc/vdw_ts_damping/"
  },
  "VDW_TS_sr": {
    "type": "float",
    "default": "0.94",
    "section": "Hamiltonian::XC",
    "description": "Set the value of the sr parameter in the damping function of the VDW correction in the Tkatchenko-Scheffler scheme. See Equation (12) of Phys. Rev. Lett. 102 073005 (2009). This parameter depends on the xc functional used. The default value is 0.94, which holds for PBE. For PBE0, a value of 0.96 should be used.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/xc/vdw_ts_sr/"
  },
  "AdaptivelyCompressedExchange": {
    "type": "logical",
    "default": "false",
    "section": "Hamiltonian",
    "description": "(Experimental) If set to yes, Octopus will use the adaptively compressed exchange operator (ACE) for HF and hybrid calculations, as defined in Lin, J. Chem. Theory Comput. 2016, 12, 2242.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/adaptivelycompressedexchange/"
  },
  "XCFunctional": {
    "type": "integer",
    "default": "",
    "section": "Hamiltonian::XC",
    "description": "Defines the exchange and correlation functionals to be used, specified as a sum of an exchange functional and a correlation functional, or a single exchange-correlation functional (<i>e.g.</i> <tt>hyb_gga_xc_pbeh</tt>). For more information on the functionals, see <a href=https://www.tddft.org/programs/libxc/functionals/previous/libxc-5.2.3/> Libxc documentation</a>. The list provided here is from libxc 5; if you have linked against a different libxc version, you may have a somewhat different set of available functionals. Note that kinetic-energy functionals are not supported. The default functional will be selected by Octopus to be consistent with the pseudopotentials you are using. If you are not using pseudopotentials, Octopus cannot determine the functional used to generate the pseudopotential, or the pseudopotential functionals are inconsistent, Octopus will use the following defaults: <br>1D: <tt>lda_x_1d_soft + lda_c_1d_csc</tt> <br>2D: <tt>lda_x_2d + lda_c_2d_amgb</tt> <br>3D: <tt>lda_x + lda_c_pz_mod</tt>",
    "options": [
      {
        "name": "lda_x",
        "value": "1"
      },
      {
        "name": "lda_c_wigner",
        "value": "2000"
      },
      {
        "name": "lda_c_rpa",
        "value": "3000"
      },
      {
        "name": "lda_c_hl",
        "value": "4000"
      },
      {
        "name": "lda_c_gl",
        "value": "5000"
      },
      {
        "name": "lda_c_xalpha",
        "value": "6000"
      },
      {
        "name": "lda_c_vwn",
        "value": "7000"
      },
      {
        "name": "lda_c_vwn_rpa",
        "value": "8000"
      },
      {
        "name": "lda_c_pz",
        "value": "9000"
      },
      {
        "name": "lda_c_pz_mod",
        "value": "10000"
      },
      {
        "name": "lda_c_ob_pz",
        "value": "11000"
      },
      {
        "name": "lda_c_pw",
        "value": "12000"
      },
      {
        "name": "lda_c_pw_mod",
        "value": "13000"
      },
      {
        "name": "lda_c_ob_pw",
        "value": "14000"
      },
      {
        "name": "lda_c_2d_amgb",
        "value": "15000"
      },
      {
        "name": "lda_c_2d_prm",
        "value": "16000"
      },
      {
        "name": "lda_c_vbh",
        "value": "17000"
      },
      {
        "name": "lda_c_1d_csc",
        "value": "18000"
      },
      {
        "name": "lda_x_2d",
        "value": "19"
      },
      {
        "name": "lda_xc_teter93",
        "value": "20000"
      },
      {
        "name": "lda_x_1d_soft",
        "value": "21"
      },
      {
        "name": "lda_c_ml1",
        "value": "22000"
      },
      {
        "name": "lda_c_ml2",
        "value": "23000"
      },
      {
        "name": "lda_c_gombas",
        "value": "24000"
      },
      {
        "name": "lda_c_pw_rpa",
        "value": "25000"
      },
      {
        "name": "lda_c_1d_loos",
        "value": "26000"
      },
      {
        "name": "lda_c_rc04",
        "value": "27000"
      },
      {
        "name": "lda_c_vwn_1",
        "value": "28000"
      },
      {
        "name": "lda_c_vwn_2",
        "value": "29000"
      },
      {
        "name": "lda_c_vwn_3",
        "value": "30000"
      },
      {
        "name": "lda_c_vwn_4",
        "value": "31000"
      },
      {
        "name": "lda_xc_zlp",
        "value": "43000"
      },
      {
        "name": "lda_xc_ksdt",
        "value": "259000"
      },
      {
        "name": "lda_c_chachiyo",
        "value": "287000"
      },
      {
        "name": "lda_c_lp96",
        "value": "289000"
      },
      {
        "name": "lda_x_rel",
        "value": "532"
      },
      {
        "name": "lda_xc_1d_ehwlrg_1",
        "value": "536000"
      },
      {
        "name": "lda_xc_1d_ehwlrg_2",
        "value": "537000"
      },
      {
        "name": "lda_xc_1d_ehwlrg_3",
        "value": "538000"
      },
      {
        "name": "lda_x_erf",
        "value": "546"
      },
      {
        "name": "lda_xc_lp_a",
        "value": "547000"
      },
      {
        "name": "lda_xc_lp_b",
        "value": "548000"
      },
      {
        "name": "lda_x_rae",
        "value": "549"
      },
      {
        "name": "lda_c_mcweeny",
        "value": "551000"
      },
      {
        "name": "lda_c_br78",
        "value": "552000"
      },
      {
        "name": "lda_c_pk09",
        "value": "554000"
      },
      {
        "name": "lda_c_ow_lyp",
        "value": "573000"
      },
      {
        "name": "lda_c_ow",
        "value": "574000"
      },
      {
        "name": "lda_xc_gdsmfb",
        "value": "577000"
      },
      {
        "name": "lda_c_gk72",
        "value": "578000"
      },
      {
        "name": "lda_c_karasiev",
        "value": "579000"
      },
      {
        "name": "gga_x_gam",
        "value": "32"
      },
      {
        "name": "gga_c_gam",
        "value": "33000"
      },
      {
        "name": "gga_x_hcth_a",
        "value": "34"
      },
      {
        "name": "gga_x_ev93",
        "value": "35"
      },
      {
        "name": "gga_x_bcgp",
        "value": "38"
      },
      {
        "name": "gga_c_bcgp",
        "value": "39000"
      },
      {
        "name": "gga_x_lambda_oc2_n",
        "value": "40"
      },
      {
        "name": "gga_x_b86_r",
        "value": "41"
      },
      {
        "name": "gga_x_lambda_ch_n",
        "value": "44"
      },
      {
        "name": "gga_x_lambda_lo_n",
        "value": "45"
      },
      {
        "name": "gga_x_hjs_b88_v2",
        "value": "46"
      },
      {
        "name": "gga_c_q2d",
        "value": "47000"
      },
      {
        "name": "gga_x_q2d",
        "value": "48"
      },
      {
        "name": "gga_x_pbe_mol",
        "value": "49"
      },
      {
        "name": "gga_x_ak13",
        "value": "56"
      },
      {
        "name": "gga_x_lv_rpw86",
        "value": "58"
      },
      {
        "name": "gga_x_pbe_tca",
        "value": "59"
      },
      {
        "name": "gga_x_pbeint",
        "value": "60"
      },
      {
        "name": "gga_c_zpbeint",
        "value": "61000"
      },
      {
        "name": "gga_c_pbeint",
        "value": "62000"
      },
      {
        "name": "gga_c_zpbesol",
        "value": "63000"
      },
      {
        "name": "gga_xc_opbe_d",
        "value": "65000"
      },
      {
        "name": "gga_xc_opwlyp_d",
        "value": "66000"
      },
      {
        "name": "gga_xc_oblyp_d",
        "value": "67000"
      },
      {
        "name": "gga_x_vmt84_ge",
        "value": "68"
      },
      {
        "name": "gga_x_vmt84_pbe",
        "value": "69"
      },
      {
        "name": "gga_x_vmt_ge",
        "value": "70"
      },
      {
        "name": "gga_x_vmt_pbe",
        "value": "71"
      },
      {
        "name": "gga_c_n12_sx",
        "value": "79000"
      },
      {
        "name": "gga_c_n12",
        "value": "80000"
      },
      {
        "name": "gga_x_n12",
        "value": "82"
      },
      {
        "name": "gga_c_regtpss",
        "value": "83000"
      },
      {
        "name": "gga_c_op_xalpha",
        "value": "84000"
      },
      {
        "name": "gga_c_op_g96",
        "value": "85000"
      },
      {
        "name": "gga_c_op_pbe",
        "value": "86000"
      },
      {
        "name": "gga_c_op_b88",
        "value": "87000"
      },
      {
        "name": "gga_c_ft97",
        "value": "88000"
      },
      {
        "name": "gga_c_spbe",
        "value": "89000"
      },
      {
        "name": "gga_x_ssb_sw",
        "value": "90"
      },
      {
        "name": "gga_x_ssb",
        "value": "91"
      },
      {
        "name": "gga_x_ssb_d",
        "value": "92"
      },
      {
        "name": "gga_xc_hcth_407p",
        "value": "93000"
      },
      {
        "name": "gga_xc_hcth_p76",
        "value": "94000"
      },
      {
        "name": "gga_xc_hcth_p14",
        "value": "95000"
      },
      {
        "name": "gga_xc_b97_gga1",
        "value": "96000"
      },
      {
        "name": "gga_c_hcth_a",
        "value": "97000"
      },
      {
        "name": "gga_x_bpccac",
        "value": "98"
      },
      {
        "name": "gga_c_revtca",
        "value": "99000"
      },
      {
        "name": "gga_c_tca",
        "value": "100000"
      },
      {
        "name": "gga_x_pbe",
        "value": "101"
      },
      {
        "name": "gga_x_pbe_r",
        "value": "102"
      },
      {
        "name": "gga_x_b86",
        "value": "103"
      },
      {
        "name": "gga_x_herman",
        "value": "104"
      },
      {
        "name": "gga_x_b86_mgc",
        "value": "105"
      },
      {
        "name": "gga_x_b88",
        "value": "106"
      },
      {
        "name": "gga_x_g96",
        "value": "107"
      },
      {
        "name": "gga_x_pw86",
        "value": "108"
      },
      {
        "name": "gga_x_pw91",
        "value": "109"
      },
      {
        "name": "gga_x_optx",
        "value": "110"
      },
      {
        "name": "gga_x_dk87_r1",
        "value": "111"
      },
      {
        "name": "gga_x_dk87_r2",
        "value": "112"
      },
      {
        "name": "gga_x_lg93",
        "value": "113"
      },
      {
        "name": "gga_x_ft97_a",
        "value": "114"
      },
      {
        "name": "gga_x_ft97_b",
        "value": "115"
      },
      {
        "name": "gga_x_pbe_sol",
        "value": "116"
      },
      {
        "name": "gga_x_rpbe",
        "value": "117"
      },
      {
        "name": "gga_x_wc",
        "value": "118"
      },
      {
        "name": "gga_x_mpw91",
        "value": "119"
      },
      {
        "name": "gga_x_am05",
        "value": "120"
      },
      {
        "name": "gga_x_pbea",
        "value": "121"
      },
      {
        "name": "gga_x_mpbe",
        "value": "122"
      },
      {
        "name": "gga_x_xpbe",
        "value": "123"
      },
      {
        "name": "gga_x_2d_b86_mgc",
        "value": "124"
      },
      {
        "name": "gga_x_bayesian",
        "value": "125"
      },
      {
        "name": "gga_x_pbe_jsjr",
        "value": "126"
      },
      {
        "name": "gga_x_2d_b88",
        "value": "127"
      },
      {
        "name": "gga_x_2d_b86",
        "value": "128"
      },
      {
        "name": "gga_x_2d_pbe",
        "value": "129"
      },
      {
        "name": "gga_c_pbe",
        "value": "130000"
      },
      {
        "name": "gga_c_lyp",
        "value": "131000"
      },
      {
        "name": "gga_c_p86",
        "value": "132000"
      },
      {
        "name": "gga_c_pbe_sol",
        "value": "133000"
      },
      {
        "name": "gga_c_pw91",
        "value": "134000"
      },
      {
        "name": "gga_c_am05",
        "value": "135000"
      },
      {
        "name": "gga_c_xpbe",
        "value": "136000"
      },
      {
        "name": "gga_c_lm",
        "value": "137000"
      },
      {
        "name": "gga_c_pbe_jrgx",
        "value": "138000"
      },
      {
        "name": "gga_x_optb88_vdw",
        "value": "139"
      },
      {
        "name": "gga_x_pbek1_vdw",
        "value": "140"
      },
      {
        "name": "gga_x_optpbe_vdw",
        "value": "141"
      },
      {
        "name": "gga_x_rge2",
        "value": "142"
      },
      {
        "name": "gga_c_rge2",
        "value": "143000"
      },
      {
        "name": "gga_x_rpw86",
        "value": "144"
      },
      {
        "name": "gga_x_kt1",
        "value": "145"
      },
      {
        "name": "gga_xc_kt2",
        "value": "146000"
      },
      {
        "name": "gga_c_wl",
        "value": "147000"
      },
      {
        "name": "gga_c_wi",
        "value": "148000"
      },
      {
        "name": "gga_x_mb88",
        "value": "149"
      },
      {
        "name": "gga_x_sogga",
        "value": "150"
      },
      {
        "name": "gga_x_sogga11",
        "value": "151"
      },
      {
        "name": "gga_c_sogga11",
        "value": "152000"
      },
      {
        "name": "gga_c_wi0",
        "value": "153000"
      },
      {
        "name": "gga_xc_th1",
        "value": "154000"
      },
      {
        "name": "gga_xc_th2",
        "value": "155000"
      },
      {
        "name": "gga_xc_th3",
        "value": "156000"
      },
      {
        "name": "gga_xc_th4",
        "value": "157000"
      },
      {
        "name": "gga_x_c09x",
        "value": "158"
      },
      {
        "name": "gga_c_sogga11_x",
        "value": "159000"
      },
      {
        "name": "gga_x_lb",
        "value": "160"
      },
      {
        "name": "gga_xc_hcth_93",
        "value": "161000"
      },
      {
        "name": "gga_xc_hcth_120",
        "value": "162000"
      },
      {
        "name": "gga_xc_hcth_147",
        "value": "163000"
      },
      {
        "name": "gga_xc_hcth_407",
        "value": "164000"
      },
      {
        "name": "gga_xc_edf1",
        "value": "165000"
      },
      {
        "name": "gga_xc_xlyp",
        "value": "166000"
      },
      {
        "name": "gga_xc_kt1",
        "value": "167000"
      },
      {
        "name": "gga_xc_b97_d",
        "value": "170000"
      },
      {
        "name": "gga_xc_pbe1w",
        "value": "173000"
      },
      {
        "name": "gga_xc_mpwlyp1w",
        "value": "174000"
      },
      {
        "name": "gga_xc_pbelyp1w",
        "value": "175000"
      },
      {
        "name": "gga_x_lbm",
        "value": "182"
      },
      {
        "name": "gga_x_ol2",
        "value": "183"
      },
      {
        "name": "gga_x_apbe",
        "value": "184"
      },
      {
        "name": "gga_c_apbe",
        "value": "186000"
      },
      {
        "name": "gga_x_htbs",
        "value": "191"
      },
      {
        "name": "gga_x_airy",
        "value": "192"
      },
      {
        "name": "gga_x_lag",
        "value": "193"
      },
      {
        "name": "gga_xc_mohlyp",
        "value": "194000"
      },
      {
        "name": "gga_xc_mohlyp2",
        "value": "195000"
      },
      {
        "name": "gga_xc_th_fl",
        "value": "196000"
      },
      {
        "name": "gga_xc_th_fc",
        "value": "197000"
      },
      {
        "name": "gga_xc_th_fcfo",
        "value": "198000"
      },
      {
        "name": "gga_xc_th_fco",
        "value": "199000"
      },
      {
        "name": "gga_c_optc",
        "value": "200000"
      },
      {
        "name": "gga_c_pbeloc",
        "value": "246000"
      },
      {
        "name": "gga_xc_vv10",
        "value": "255000"
      },
      {
        "name": "gga_c_pbefe",
        "value": "258000"
      },
      {
        "name": "gga_c_op_pw91",
        "value": "262000"
      },
      {
        "name": "gga_x_pbefe",
        "value": "265"
      },
      {
        "name": "gga_x_cap",
        "value": "270"
      },
      {
        "name": "gga_x_eb88",
        "value": "271"
      },
      {
        "name": "gga_c_pbe_mol",
        "value": "272000"
      },
      {
        "name": "gga_c_bmk",
        "value": "280000"
      },
      {
        "name": "gga_c_tau_hcth",
        "value": "281000"
      },
      {
        "name": "gga_c_hyb_tau_hcth",
        "value": "283000"
      },
      {
        "name": "gga_x_beefvdw",
        "value": "285"
      },
      {
        "name": "gga_xc_beefvdw",
        "value": "286000"
      },
      {
        "name": "gga_x_pbetrans",
        "value": "291"
      },
      {
        "name": "gga_x_chachiyo",
        "value": "298"
      },
      {
        "name": "gga_x_wpbeh",
        "value": "524"
      },
      {
        "name": "gga_x_hjs_pbe",
        "value": "525"
      },
      {
        "name": "gga_x_hjs_pbe_sol",
        "value": "526"
      },
      {
        "name": "gga_x_hjs_b88",
        "value": "527"
      },
      {
        "name": "gga_x_hjs_b97x",
        "value": "528"
      },
      {
        "name": "gga_x_ityh",
        "value": "529"
      },
      {
        "name": "gga_x_sfat",
        "value": "530"
      },
      {
        "name": "gga_x_sg4",
        "value": "533"
      },
      {
        "name": "gga_c_sg4",
        "value": "534000"
      },
      {
        "name": "gga_x_gg99",
        "value": "535"
      },
      {
        "name": "gga_x_pbepow",
        "value": "539"
      },
      {
        "name": "gga_x_kgg99",
        "value": "544"
      },
      {
        "name": "gga_xc_hle16",
        "value": "545000"
      },
      {
        "name": "gga_c_scan_e0",
        "value": "553000"
      },
      {
        "name": "gga_c_gapc",
        "value": "555000"
      },
      {
        "name": "gga_c_gaploc",
        "value": "556000"
      },
      {
        "name": "gga_c_zvpbeint",
        "value": "557000"
      },
      {
        "name": "gga_c_zvpbesol",
        "value": "558000"
      },
      {
        "name": "gga_c_tm_lyp",
        "value": "559000"
      },
      {
        "name": "gga_c_tm_pbe",
        "value": "560000"
      },
      {
        "name": "gga_c_w94",
        "value": "561000"
      },
      {
        "name": "gga_c_cs1",
        "value": "565000"
      },
      {
        "name": "gga_x_b88m",
        "value": "570"
      },
      {
        "name": "hyb_gga_x_n12_sx",
        "value": "81"
      },
      {
        "name": "hyb_gga_xc_b97_1p",
        "value": "266000"
      },
      {
        "name": "hyb_gga_xc_pbe_mol0",
        "value": "273000"
      },
      {
        "name": "hyb_gga_xc_pbe_sol0",
        "value": "274000"
      },
      {
        "name": "hyb_gga_xc_pbeb0",
        "value": "275000"
      },
      {
        "name": "hyb_gga_xc_pbe_molb0",
        "value": "276000"
      },
      {
        "name": "hyb_gga_xc_pbe50",
        "value": "290000"
      },
      {
        "name": "hyb_gga_xc_b3pw91",
        "value": "401000"
      },
      {
        "name": "hyb_gga_xc_b3lyp",
        "value": "402000"
      },
      {
        "name": "hyb_gga_xc_b3p86",
        "value": "403000"
      },
      {
        "name": "hyb_gga_xc_o3lyp",
        "value": "404000"
      },
      {
        "name": "hyb_gga_xc_mpw1k",
        "value": "405000"
      },
      {
        "name": "hyb_gga_xc_pbeh",
        "value": "406000"
      },
      {
        "name": "hyb_gga_xc_b97",
        "value": "407000"
      },
      {
        "name": "hyb_gga_xc_b97_1",
        "value": "408000"
      },
      {
        "name": "hyb_gga_xc_b97_2",
        "value": "410000"
      },
      {
        "name": "hyb_gga_xc_x3lyp",
        "value": "411000"
      },
      {
        "name": "hyb_gga_xc_b1wc",
        "value": "412000"
      },
      {
        "name": "hyb_gga_xc_b97_k",
        "value": "413000"
      },
      {
        "name": "hyb_gga_xc_b97_3",
        "value": "414000"
      },
      {
        "name": "hyb_gga_xc_mpw3pw",
        "value": "415000"
      },
      {
        "name": "hyb_gga_xc_b1lyp",
        "value": "416000"
      },
      {
        "name": "hyb_gga_xc_b1pw91",
        "value": "417000"
      },
      {
        "name": "hyb_gga_xc_mpw1pw",
        "value": "418000"
      },
      {
        "name": "hyb_gga_xc_mpw3lyp",
        "value": "419000"
      },
      {
        "name": "hyb_gga_xc_sb98_1a",
        "value": "420000"
      },
      {
        "name": "hyb_gga_xc_sb98_1b",
        "value": "421000"
      },
      {
        "name": "hyb_gga_xc_sb98_1c",
        "value": "422000"
      },
      {
        "name": "hyb_gga_xc_sb98_2a",
        "value": "423000"
      },
      {
        "name": "hyb_gga_xc_sb98_2b",
        "value": "424000"
      },
      {
        "name": "hyb_gga_xc_sb98_2c",
        "value": "425000"
      },
      {
        "name": "hyb_gga_x_sogga11_x",
        "value": "426"
      },
      {
        "name": "hyb_gga_xc_hse03",
        "value": "427000"
      },
      {
        "name": "hyb_gga_xc_hse06",
        "value": "428000"
      },
      {
        "name": "hyb_gga_xc_hjs_pbe",
        "value": "429000"
      },
      {
        "name": "hyb_gga_xc_hjs_pbe_sol",
        "value": "430000"
      },
      {
        "name": "hyb_gga_xc_hjs_b88",
        "value": "431000"
      },
      {
        "name": "hyb_gga_xc_hjs_b97x",
        "value": "432000"
      },
      {
        "name": "hyb_gga_xc_cam_b3lyp",
        "value": "433000"
      },
      {
        "name": "hyb_gga_xc_tuned_cam_b3lyp",
        "value": "434000"
      },
      {
        "name": "hyb_gga_xc_bhandh",
        "value": "435000"
      },
      {
        "name": "hyb_gga_xc_bhandhlyp",
        "value": "436000"
      },
      {
        "name": "hyb_gga_xc_mb3lyp_rc04",
        "value": "437000"
      },
      {
        "name": "hyb_gga_xc_mpwlyp1m",
        "value": "453000"
      },
      {
        "name": "hyb_gga_xc_revb3lyp",
        "value": "454000"
      },
      {
        "name": "hyb_gga_xc_camy_blyp",
        "value": "455000"
      },
      {
        "name": "hyb_gga_xc_pbe0_13",
        "value": "456000"
      },
      {
        "name": "hyb_gga_xc_b3lyps",
        "value": "459000"
      },
      {
        "name": "hyb_gga_xc_wb97",
        "value": "463000"
      },
      {
        "name": "hyb_gga_xc_wb97x",
        "value": "464000"
      },
      {
        "name": "hyb_gga_xc_lrc_wpbeh",
        "value": "465000"
      },
      {
        "name": "hyb_gga_xc_wb97x_v",
        "value": "466000"
      },
      {
        "name": "hyb_gga_xc_lcy_pbe",
        "value": "467000"
      },
      {
        "name": "hyb_gga_xc_lcy_blyp",
        "value": "468000"
      },
      {
        "name": "hyb_gga_xc_lc_vv10",
        "value": "469000"
      },
      {
        "name": "hyb_gga_xc_camy_b3lyp",
        "value": "470000"
      },
      {
        "name": "hyb_gga_xc_wb97x_d",
        "value": "471000"
      },
      {
        "name": "hyb_gga_xc_hpbeint",
        "value": "472000"
      },
      {
        "name": "hyb_gga_xc_lrc_wpbe",
        "value": "473000"
      },
      {
        "name": "hyb_gga_xc_b3lyp5",
        "value": "475000"
      },
      {
        "name": "hyb_gga_xc_edf2",
        "value": "476000"
      },
      {
        "name": "hyb_gga_xc_cap0",
        "value": "477000"
      },
      {
        "name": "hyb_gga_xc_lc_wpbe",
        "value": "478000"
      },
      {
        "name": "hyb_gga_xc_hse12",
        "value": "479000"
      },
      {
        "name": "hyb_gga_xc_hse12s",
        "value": "480000"
      },
      {
        "name": "hyb_gga_xc_hse_sol",
        "value": "481000"
      },
      {
        "name": "hyb_gga_xc_cam_qtp_01",
        "value": "482000"
      },
      {
        "name": "hyb_gga_xc_mpw1lyp",
        "value": "483000"
      },
      {
        "name": "hyb_gga_xc_mpw1pbe",
        "value": "484000"
      },
      {
        "name": "hyb_gga_xc_kmlyp",
        "value": "485000"
      },
      {
        "name": "hyb_gga_xc_b5050lyp",
        "value": "572000"
      },
      {
        "name": "mgga_c_dldf",
        "value": "37000"
      },
      {
        "name": "mgga_xc_zlp",
        "value": "42000"
      },
      {
        "name": "mgga_xc_otpss_d",
        "value": "64000"
      },
      {
        "name": "mgga_c_cs",
        "value": "72000"
      },
      {
        "name": "mgga_c_mn12_sx",
        "value": "73000"
      },
      {
        "name": "mgga_c_mn12_l",
        "value": "74000"
      },
      {
        "name": "mgga_c_m11_l",
        "value": "75000"
      },
      {
        "name": "mgga_c_m11",
        "value": "76000"
      },
      {
        "name": "mgga_c_m08_so",
        "value": "77000"
      },
      {
        "name": "mgga_c_m08_hx",
        "value": "78000"
      },
      {
        "name": "mgga_x_lta",
        "value": "201"
      },
      {
        "name": "mgga_x_tpss",
        "value": "202"
      },
      {
        "name": "mgga_x_m06_l",
        "value": "203"
      },
      {
        "name": "mgga_x_gvt4",
        "value": "204"
      },
      {
        "name": "mgga_x_tau_hcth",
        "value": "205"
      },
      {
        "name": "mgga_x_br89",
        "value": "206"
      },
      {
        "name": "mgga_x_bj06",
        "value": "207"
      },
      {
        "name": "mgga_x_tb09",
        "value": "208"
      },
      {
        "name": "mgga_x_rpp09",
        "value": "209"
      },
      {
        "name": "mgga_x_2d_prhg07",
        "value": "210"
      },
      {
        "name": "mgga_x_2d_prhg07_prp10",
        "value": "211"
      },
      {
        "name": "mgga_x_revtpss",
        "value": "212"
      },
      {
        "name": "mgga_x_pkzb",
        "value": "213"
      },
      {
        "name": "mgga_x_ms0",
        "value": "221"
      },
      {
        "name": "mgga_x_ms1",
        "value": "222"
      },
      {
        "name": "mgga_x_ms2",
        "value": "223"
      },
      {
        "name": "mgga_x_m11_l",
        "value": "226"
      },
      {
        "name": "mgga_x_mn12_l",
        "value": "227"
      },
      {
        "name": "mgga_xc_cc06",
        "value": "229000"
      },
      {
        "name": "mgga_x_mk00",
        "value": "230"
      },
      {
        "name": "mgga_c_tpss",
        "value": "231000"
      },
      {
        "name": "mgga_c_vsxc",
        "value": "232000"
      },
      {
        "name": "mgga_c_m06_l",
        "value": "233000"
      },
      {
        "name": "mgga_c_m06_hf",
        "value": "234000"
      },
      {
        "name": "mgga_c_m06",
        "value": "235000"
      },
      {
        "name": "mgga_c_m06_2x",
        "value": "236000"
      },
      {
        "name": "mgga_c_m05",
        "value": "237000"
      },
      {
        "name": "mgga_c_m05_2x",
        "value": "238000"
      },
      {
        "name": "mgga_c_pkzb",
        "value": "239000"
      },
      {
        "name": "mgga_c_bc95",
        "value": "240000"
      },
      {
        "name": "mgga_c_revtpss",
        "value": "241000"
      },
      {
        "name": "mgga_xc_tpsslyp1w",
        "value": "242000"
      },
      {
        "name": "mgga_x_mk00b",
        "value": "243"
      },
      {
        "name": "mgga_x_bloc",
        "value": "244"
      },
      {
        "name": "mgga_x_modtpss",
        "value": "245"
      },
      {
        "name": "mgga_c_tpssloc",
        "value": "247000"
      },
      {
        "name": "mgga_x_mbeef",
        "value": "249"
      },
      {
        "name": "mgga_x_mbeefvdw",
        "value": "250"
      },
      {
        "name": "mgga_xc_b97m_v",
        "value": "254000"
      },
      {
        "name": "mgga_x_mvs",
        "value": "257"
      },
      {
        "name": "mgga_x_mn15_l",
        "value": "260"
      },
      {
        "name": "mgga_c_mn15_l",
        "value": "261000"
      },
      {
        "name": "mgga_x_scan",
        "value": "263"
      },
      {
        "name": "mgga_c_scan",
        "value": "267000"
      },
      {
        "name": "mgga_c_mn15",
        "value": "269000"
      },
      {
        "name": "mgga_x_b00",
        "value": "284"
      },
      {
        "name": "mgga_xc_hle17",
        "value": "288000"
      },
      {
        "name": "mgga_c_scan_rvv10",
        "value": "292000"
      },
      {
        "name": "mgga_x_revm06_l",
        "value": "293"
      },
      {
        "name": "mgga_c_revm06_l",
        "value": "294000"
      },
      {
        "name": "mgga_x_tm",
        "value": "540"
      },
      {
        "name": "mgga_x_vt84",
        "value": "541"
      },
      {
        "name": "mgga_x_sa_tpss",
        "value": "542"
      },
      {
        "name": "mgga_c_kcis",
        "value": "562000"
      },
      {
        "name": "mgga_xc_lp90",
        "value": "564000"
      },
      {
        "name": "mgga_c_b88",
        "value": "571000"
      },
      {
        "name": "mgga_x_gx",
        "value": "575"
      },
      {
        "name": "mgga_x_pbe_gx",
        "value": "576"
      },
      {
        "name": "mgga_x_revscan",
        "value": "581"
      },
      {
        "name": "mgga_c_revscan",
        "value": "582000"
      },
      {
        "name": "mgga_c_scan_vv10",
        "value": "584000"
      },
      {
        "name": "mgga_c_revscan_vv10",
        "value": "585000"
      },
      {
        "name": "mgga_x_br89_explicit",
        "value": "586"
      },
      {
        "name": "hyb_mgga_x_dldf",
        "value": "36"
      },
      {
        "name": "hyb_mgga_x_ms2h",
        "value": "224"
      },
      {
        "name": "hyb_mgga_x_mn12_sx",
        "value": "248"
      },
      {
        "name": "hyb_mgga_x_scan0",
        "value": "264"
      },
      {
        "name": "hyb_mgga_x_mn15",
        "value": "268"
      },
      {
        "name": "hyb_mgga_x_bmk",
        "value": "279"
      },
      {
        "name": "hyb_mgga_x_tau_hcth",
        "value": "282"
      },
      {
        "name": "hyb_mgga_x_m08_hx",
        "value": "295"
      },
      {
        "name": "hyb_mgga_x_m08_so",
        "value": "296"
      },
      {
        "name": "hyb_mgga_x_m11",
        "value": "297"
      },
      {
        "name": "hyb_mgga_x_m05",
        "value": "438"
      },
      {
        "name": "hyb_mgga_x_m05_2x",
        "value": "439"
      },
      {
        "name": "hyb_mgga_xc_b88b95",
        "value": "440000"
      },
      {
        "name": "hyb_mgga_xc_b86b95",
        "value": "441000"
      },
      {
        "name": "hyb_mgga_xc_pw86b95",
        "value": "442000"
      },
      {
        "name": "hyb_mgga_xc_bb1k",
        "value": "443000"
      },
      {
        "name": "hyb_mgga_x_m06_hf",
        "value": "444"
      },
      {
        "name": "hyb_mgga_xc_mpw1b95",
        "value": "445000"
      },
      {
        "name": "hyb_mgga_xc_mpwb1k",
        "value": "446000"
      },
      {
        "name": "hyb_mgga_xc_x1b95",
        "value": "447000"
      },
      {
        "name": "hyb_mgga_xc_xb1k",
        "value": "448000"
      },
      {
        "name": "hyb_mgga_x_m06",
        "value": "449"
      },
      {
        "name": "hyb_mgga_x_m06_2x",
        "value": "450"
      },
      {
        "name": "hyb_mgga_xc_pw6b95",
        "value": "451000"
      },
      {
        "name": "hyb_mgga_xc_pwb6k",
        "value": "452000"
      },
      {
        "name": "hyb_mgga_xc_tpssh",
        "value": "457000"
      },
      {
        "name": "hyb_mgga_xc_revtpssh",
        "value": "458000"
      },
      {
        "name": "hyb_mgga_x_mvsh",
        "value": "474"
      },
      {
        "name": "hyb_mgga_xc_wb97m_v",
        "value": "531000"
      },
      {
        "name": "hyb_mgga_xc_b0kcis",
        "value": "563000"
      },
      {
        "name": "hyb_mgga_xc_mpw1kcis",
        "value": "566000"
      },
      {
        "name": "hyb_mgga_xc_mpwkcis1k",
        "value": "567000"
      },
      {
        "name": "hyb_mgga_xc_pbe1kcis",
        "value": "568000"
      },
      {
        "name": "hyb_mgga_xc_tpss1kcis",
        "value": "569000"
      },
      {
        "name": "hyb_mgga_x_revscan0",
        "value": "583"
      },
      {
        "name": "hyb_mgga_xc_b98",
        "value": "598000"
      },
      {
        "name": "oep_x",
        "value": "901"
      },
      {
        "name": "slater_x",
        "value": "902"
      },
      {
        "name": "fbe_x",
        "value": "903"
      },
      {
        "name": "ks_inversion",
        "value": "904"
      },
      {
        "name": "rdmft_xc_m",
        "value": "601"
      },
      {
        "name": "xc_half_hartree",
        "value": "917"
      },
      {
        "name": "hyb_gga_xc_mvorb_hse06",
        "value": "921000"
      },
      {
        "name": "hyb_gga_xc_mvorb_pbeh",
        "value": "922000"
      },
      {
        "name": "vdw_c_vdwdf",
        "value": "918000"
      },
      {
        "name": "vdw_c_vdwdf2",
        "value": "919000"
      },
      {
        "name": "vdw_c_vdwdfcx",
        "value": "920000"
      },
      {
        "name": "none",
        "value": "0"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/xc/xcfunctional/"
  },
  "TDExternalFields": {
    "type": "block",
    "default": "",
    "section": "Time-Dependent",
    "description": "The block <tt>TDExternalFields</tt> describes the type and shape of time-dependent external perturbations that are applied to the system, in the form <math>f(x,y,z) \\cos(\\omega t + \\phi (t)) g(t)</math>, where <math>f(x,y,z)</math> is defined by by a field type and polarization or a scalar potential, as below; <math>\\omega</math> is defined by <tt>omega</tt>; <math>g(t)</math> is defined by <tt>envelope_function_name</tt>; and <math>\\phi(t)</math> is the (time-dependent) phase from <tt>phase</tt>. These perturbations are only applied for time-dependent runs. If you want the value of the perturbation at time zero to be applied for time-independent runs, use <tt>TimeZero = yes</tt>. Each line of the block describes an external field; this way you can actually have more than one laser (<i>e.g.</i> a \"pump\" and a \"probe\"). There are two ways to specify <math>f(x,y,z)</math> but both use the same <tt>omega | envelope_function_name [| phase]</tt> for the time-dependence. The float <tt>omega</tt> will be the carrier frequency of the pulse (in energy units). The envelope of the field is a time-dependent function whose definition must be given in a <tt>TDFunctions</tt> block. <tt>envelope_function_name</tt> is a string (and therefore it must be surrounded by quotation marks) that must match one of the function names given in the first column of the <tt>TDFunctions</tt> block. <tt>phase</tt> is optional and is taken to be zero if not provided, and is also a string specifying a time-dependent function. (A) type = <tt>electric field, magnetic field, vector_potential</tt> For these cases, the syntax is: <tt>%TDExternalFields <br>&nbsp;&nbsp; type | nx | ny | nz | omega | envelope_function_name | phase <br>%</tt> The <tt>vector_potential</tt> option (constant in space) permits us to describe an electric perturbation in the velocity gauge. The three (possibly complex) numbers (<tt>nx</tt>, <tt>ny</tt>, <tt>nz</tt>) mark the polarization direction of the field. By default, (<tt>nx</tt>, <tt>ny</tt>, <tt>nz</tt>) are defined in Cartesian space. However, it is possible for solids to define them using the Miller indices. This can be achieved by defining the block <tt>MillerIndicesBasis</tt>. (B) type = <tt>scalar_potential</tt> <tt>%TDExternalFields <br>&nbsp;&nbsp; scalar_potential | \"spatial_expression\" | omega | envelope_function_name | phase <br>%</tt> The scalar potential is any expression of the spatial coordinates given by the string \"spatial_expression\", allowing a field beyond the dipole approximation. For DFTB runs, only fields of type type = <tt>electric field</tt> are allowed for the moment, and the <tt>type</tt> keyword is omitted. A NOTE ON UNITS: It is very common to describe the strength of a laser field by its intensity, rather than using the electric-field amplitude. In atomic units (or, more precisely, in any Gaussian system of units), the relationship between instantaneous electric field and intensity is: <math> I(t) = \\frac{c}{8\\pi} E^2(t) </math>. It is common to read intensities in W/cm<math>^2</math>. The dimensions of intensities are [W]/(L<math>^2</math>T), where [W] are the dimensions of energy. The relevant conversion factors are: Hartree / (<math>a_0^2</math> atomic_time) = <math>6.4364086 \\times 10^{15} \\mathrm{W/cm}^2</math> eV / ( &Aring;<math>^2 (\\hbar</math>/eV) ) = <math>2.4341348 \\times 10^{12} \\mathrm{W/cm}^2</math> If, in atomic units, we set the electric-field amplitude to <math>E_0</math>, then the intensity is: <math> I_0 = 3.51 \\times 10^{16} \\mathrm{W/cm}^2 (E_0^2) </math> If, working with <tt>Units = ev_angstrom</tt>, we set <math>E_0</math>, then the intensity is: <math> I_0 = 1.327 \\times 10^{13} (E_0^2) \\mathrm{W/cm}^2 </math>",
    "options": [
      {
        "name": "electric_field",
        "value": "1"
      },
      {
        "name": "magnetic_field",
        "value": "2"
      },
      {
        "name": "vector_potential",
        "value": "3"
      },
      {
        "name": "scalar_potential",
        "value": "4"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/tdexternalfields/"
  },
  "MillerIndicesBasis": {
    "type": "block",
    "default": "",
    "section": "Time-Dependent",
    "description": "When this block is given, the polarisation of the TDExternalFields is understood to be defined in terms of Miller indices. This block define the corresponding basis, by defining the reduced coordinates of the X, Y, and Z high symmetry points, such that the code can do the corresponding transformation. For example, in an FCC crystal with the conventional primitive cell, the following input allows to define the polarization in terms of Miller indices <tt>%MillerIndicesBasis <br> 0.0 | 0.5 | 0.5 <br> 0.5 | 0.0 | 0.5 <br> 0.5 | 0.5 | 0.0 <br>%</tt> Indeed, in this case, the reciprocal lattice vectors are (-1, 1, 1), (1, -1, 1), and (1, 1, -1) in units of 2*pi/a. This directly gives that the [100] direction correspond to the x direction, [111] gives the vector (1,1,1), etc.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/millerindicesbasis/"
  },
  "EwaldAlpha": {
    "type": "float",
    "default": "0.21",
    "section": "Hamiltonian",
    "description": "The value 'Alpha' that controls the splitting of the Coulomb interaction in the Ewald sum used to calculation the ion-ion interaction for periodic systems. This value affects the speed of the calculation, normally users do not need to modify it.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/ewaldalpha/"
  },
  "MagneticConstrain": {
    "type": "integer",
    "default": "no",
    "section": "Hamiltonian",
    "description": "This variable selects which magnetic constrain expression is added to the Hamiltonian.",
    "options": [
      {
        "name": "constrain_none",
        "value": "0"
      },
      {
        "name": "constrain_dir",
        "value": "1"
      },
      {
        "name": "constrain_full",
        "value": "2"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/magneticconstrain/"
  },
  "MagneticConstrainStrength": {
    "type": "float",
    "default": "0.01",
    "section": "Hamiltonian",
    "description": "This variable determines the value of the Lagrange multiplier used for the constrain term.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/magneticconstrainstrength/"
  },
  "AbsorbingBoundaries": {
    "type": "flag",
    "default": "not_absorbing",
    "section": "Time-Dependent::Absorbing Boundaries",
    "description": "To improve the quality of the spectra by avoiding the formation of standing density waves, one can make the boundaries of the simulation box absorbing and use exterior complex scaling.",
    "options": [
      {
        "name": "not_absorbing",
        "value": "0"
      },
      {
        "name": "mask",
        "value": "1"
      },
      {
        "name": "cap",
        "value": "2"
      },
      {
        "name": "exterior",
        "value": "3"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/absorbing boundaries/absorbingboundaries/"
  },
  "ABCapHeight": {
    "type": "float",
    "default": "-0.2 a.u.",
    "section": "Time-Dependent::Absorbing Boundaries",
    "description": "When <tt>AbsorbingBoundaries = cap</tt>, this is the height of the imaginary potential.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/absorbing boundaries/abcapheight/"
  },
  "ABShape": {
    "type": "block",
    "default": "",
    "section": "Time-Dependent::Absorbing Boundaries",
    "description": "Set the shape of the absorbing boundaries. Here you can set the inner and outer bounds by setting the block as follows: <tt>%ABShape <br>&nbsp;&nbsp; inner | outer | \"user-defined\" <br>%</tt> The optional 3rd column is a user-defined expression for the absorbing boundaries. For example, <math>r</math> creates a spherical absorbing zone for coordinates with <math>{\\tt inner} < r < {\\tt outer}</math>, and <math>z</math> creates an absorbing plane. Note, values <tt>outer</tt> larger than the box size may lead in these cases to unexpected reflection behaviours. If no expression is given, the absorbing zone follows the edges of the box (not valid for user-defined box).",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/absorbing boundaries/abshape/"
  },
  "ABWidth": {
    "type": "float",
    "default": "",
    "section": "Time-Dependent::Absorbing Boundaries",
    "description": "Specifies the boundary width. For a finer control over the absorbing boundary shape use ABShape.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/absorbing boundaries/abwidth/"
  },
  "Xalpha": {
    "type": "float",
    "default": "1.0",
    "section": "Hamiltonian::XC",
    "description": "The parameter of the Slater X<math>\\alpha</math> functional. Applies only for <tt>XCFunctional = xc_lda_c_xalpha</tt>.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/xc/xalpha/"
  },
  "Interaction1D": {
    "type": "integer",
    "default": "interaction_soft_coulomb",
    "section": "Hamiltonian::XC",
    "description": "When running in 1D, one has to soften the Coulomb interaction. This softening is not unique, and several possibilities exist in the literature.",
    "options": [
      {
        "name": "interaction_exp_screened",
        "value": "0"
      },
      {
        "name": "interaction_soft_coulomb",
        "value": "1"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/xc/interaction1d/"
  },
  "Interaction1DScreening": {
    "type": "float",
    "default": "1.0",
    "section": "Hamiltonian::XC",
    "description": "Defines the screening parameter <math>\\alpha</math> of the softened Coulomb interaction when running in 1D.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/xc/interaction1dscreening/"
  },
  "MaximumIterBerry": {
    "type": "integer",
    "default": "10",
    "section": "SCF::Convergence",
    "description": "Maximum number of iterations for the Berry potential, within each SCF iteration. Only applies if a <tt>StaticElectricField</tt> is applied in a periodic direction. The code will move on to the next SCF iteration even if convergence has not been achieved. -1 means unlimited.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/scf/convergence/maximumiterberry/"
  },
  "PCMCalculation": {
    "type": "logical",
    "default": "no",
    "section": "Hamiltonian::PCM",
    "description": "If true, the calculation is performed accounting for solvation effects by using the Integral Equation Formalism Polarizable Continuum Model IEF-PCM formulated in real-space and real-time (<i>J. Chem. Phys.</i> <b>143</b>, 144111 (2015), <i>Chem. Rev.</i> <b>105</b>, 2999 (2005), <i>J. Chem. Phys.</i> <b>139</b>, 024105 (2013)). At the moment, this option is available only for <tt>TheoryLevel = DFT</tt>. PCM is tested for CalculationMode = gs, while still experimental for other values (in particular, CalculationMode = td).",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/pcm/pcmcalculation/"
  },
  "PCMVdWRadii": {
    "type": "integer",
    "default": "pcm_vdw_optimized",
    "section": "Hamiltonian::PCM",
    "description": "This variable selects which van der Waals radius will be used to generate the solvent cavity.",
    "options": [
      {
        "name": "pcm_vdw_optimized",
        "value": "1"
      },
      {
        "name": "pcm_vdw_species",
        "value": "2"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/pcm/pcmvdwradii/"
  },
  "PCMRadiusScaling": {
    "type": "float",
    "default": "",
    "section": "Hamiltonian::PCM",
    "description": "Scales the radii of the spheres used to build the solute cavity surface. The default value depends on the choice of <tt>PCMVdWRadii</tt>: 1.2 for <tt>pcm_vdw_optimized</tt> and 1.0 for <tt>pcm_vdw_species</tt>.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/pcm/pcmradiusscaling/"
  },
  "PCMTDLevel": {
    "type": "integer",
    "default": "eq",
    "section": "Hamiltonian::PCM",
    "description": "When CalculationMode=td, PCMTDLevel it sets the way the time-depenendent solvent polarization is propagated.",
    "options": [
      {
        "name": "eq",
        "value": "0"
      },
      {
        "name": "neq",
        "value": "1"
      },
      {
        "name": "eom",
        "value": "2"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/pcm/pcmtdlevel/"
  },
  "PCMStaticEpsilon": {
    "type": "float",
    "default": "1.0",
    "section": "Hamiltonian::PCM",
    "description": "Static dielectric constant of the solvent (<math>\\varepsilon_0</math>). 1.0 indicates gas phase.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/pcm/pcmstaticepsilon/"
  },
  "PCMDynamicEpsilon": {
    "type": "float",
    "default": "PCMStaticEpsilon",
    "section": "Hamiltonian::PCM",
    "description": "High-frequency dielectric constant of the solvent (<math>\\varepsilon_d</math>). <math>\\varepsilon_d=\\varepsilon_0</math> indicate equilibrium with solvent.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/pcm/pcmdynamicepsilon/"
  },
  "PCMEpsilonModel": {
    "type": "integer",
    "default": "pcm_debye",
    "section": "Hamiltonian::PCM",
    "description": "Define the dielectric function model.",
    "options": [
      {
        "name": "pcm_debye",
        "value": "1"
      },
      {
        "name": "pcm_drude",
        "value": "2"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/pcm/pcmepsilonmodel/"
  },
  "PCMEoMInitialCharges": {
    "type": "integer",
    "default": "0",
    "section": "Hamiltonian::PCM",
    "description": "If =0 the propagation of the solvent polarization charges starts from internally generated initial charges in equilibrium with the initial potential. For Debye EOM-PCM, if >0 the propagation of the solvent polarization charges starts from initial charges from input file. if =1, initial pol. charges due to solute electrons are read from input file. else if =2, initial pol. charges due to external potential are read from input file. else if =3, initial pol. charges due to solute electrons and external potential are read from input file. Files should be located in pcm directory and are called ASC_e.dat and ASC_ext.dat, respectively. The latter files are generated after any PCM run and contain the last values of the polarization charges.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/pcm/pcmeominitialcharges/"
  },
  "PCMDebyeRelaxTime": {
    "type": "float",
    "default": "0.0",
    "section": "Hamiltonian::PCM",
    "description": "Relaxation time of the solvent within Debye model (<math>\\tau</math>). Recall Debye dieletric function: <math>\\varepsilon(\\omega)=\\varepsilon_d+\\frac{\\varepsilon_0-\\varepsilon_d}{1-i\\omega\\tau}</math>",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/pcm/pcmdebyerelaxtime/"
  },
  "PCMDrudeLOmega": {
    "type": "float",
    "default": "values of <math>\\omega_0</math> guarantee to recover static dielectric constant.",
    "section": "Hamiltonian::PCM",
    "description": "Resonance frequency of the solvent within Drude-Lorentz model (<math>\\omega_0</math>). Recall Drude-Lorentz dielectric function: <math>\\varepsilon(\\omega)=1+\\frac{A}{\\omega_0^2-\\omega^2+i\\gamma\\omega}</math>",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/pcm/pcmdrudelomega/"
  },
  "PCMDrudeLDamping": {
    "type": "float",
    "default": "0.0",
    "section": "Hamiltonian::PCM",
    "description": "Damping factor of the solvent charges oscillations within Drude-Lorentz model (<math>\\gamma</math>). Recall Drude-Lorentz dielectric function: <math>\\varepsilon(\\omega)=1+\\frac{A}{\\omega_0^2-\\omega^2+i\\gamma\\omega}</math>",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/pcm/pcmdrudeldamping/"
  },
  "PCMLocalField": {
    "type": "logical",
    "default": "no",
    "section": "Hamiltonian::PCM",
    "description": "This variable is a flag for including local field effects when an external field is applied. The total field interacting with the molecule (also known as cavity field) is not the bare field in the solvent (the so-called Maxwell field), but it also include a contribution due to the polarization of the solvent. The latter is calculated here within the PCM framework. See [G. Gil, et al., J. Chem. Theory Comput., 2019, 15 (4), pp 23062319].",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/pcm/pcmlocalfield/"
  },
  "PCMSolute": {
    "type": "logical",
    "default": "yes",
    "section": "Hamiltonian::PCM",
    "description": "This variable is a flag for including polarization effects of the solvent due to the solute. (Useful for analysis) When external fields are applied, turning off the solvent-molecule interaction (PCMSolute=no) and activating the solvent polarization due to the applied field (PCMLocalField=yes) allows to include only local field effects.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/pcm/pcmsolute/"
  },
  "PCMKick": {
    "type": "logical",
    "default": "no",
    "section": "Hamiltonian::PCM",
    "description": "This variable controls the effect the kick has on the polarization of the solvent. If .true.  ONLY the FAST degrees-of-freedom of the solvent follow the kick. The potential due to polarization charges behaves as another kick, i.e., it is a delta-perturbation. If .false. ALL           degrees-of-freedom of the solvent follow the kick. The potential due to polarization charges evolves following an equation of motion. When Debye dielectric model is used, just a part of the potential behaves as another kick.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/pcm/pcmkick/"
  },
  "PCMUpdateIter": {
    "type": "integer",
    "default": "1",
    "section": "Hamiltonian::PCM",
    "description": "Defines how often the PCM potential is updated during time propagation.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/pcm/pcmupdateiter/"
  },
  "PCMGamessBenchmark": {
    "type": "logical",
    "default": ".false.",
    "section": "Hamiltonian::PCM",
    "description": "If PCMGamessBenchmark is set to \"yes\", the pcm_matrix is also written in a Gamess format. for benchamarking purposes.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/pcm/pcmgamessbenchmark/"
  },
  "PCMRenormCharges": {
    "type": "logical",
    "default": ".false.",
    "section": "Hamiltonian::PCM",
    "description": "If .true. renormalization of the polarization charges is performed to enforce fulfillment of the Gauss law, <math>\\sum_i q_i^{e/n} = -[(\\epsilon-1)/\\epsilon] Q_M^{e/n}</math> where <math>q_i^{e/n}</math> are the polarization charges induced by the electrons/nuclei of the molecule and <math>Q_M^{e/n}</math> is the nominal electronic/nuclear charge of the system. This can be needed to treat molecules in weakly polar solvents.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/pcm/pcmrenormcharges/"
  },
  "PCMQtotTol": {
    "type": "float",
    "default": "0.5",
    "section": "Hamiltonian::PCM",
    "description": "If <tt>PCMRenormCharges=.true.</tt> and  <math>\\delta Q = |[\\sum_i q_i| - ((\\epsilon-1)/\\epsilon)*|Q_M]|>PCMQtotTol</math> the polarization charges will be normalized as <math>q_i^\\prime=q_i + signfunction(e, n, \\delta Q) (q_i/q_{tot})*\\delta Q</math> with <math>q_{tot} = \\sum_i q_i</math>. For values of <math>\\delta Q > 0.5</math> (printed by the code in the file pcm/pcm_info.out) even, if polarization charges are renormalized, the calculated results might be inaccurate or erroneous.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/pcm/pcmqtottol/"
  },
  "PCMSmearingFactor": {
    "type": "float",
    "default": "1.0",
    "section": "Hamiltonian::PCM",
    "description": "Parameter used to control the width (area of each tessera) of the Gaussians used to distribute the polarization charges on each tessera (arXiv:1507.05471). If set to zero, the solvent reaction potential in real-space is defined by using point charges.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/pcm/pcmsmearingfactor/"
  },
  "PCMCavity": {
    "type": "string",
    "default": "",
    "section": "Hamiltonian::PCM",
    "description": "Name of the file containing the geometry of the cavity hosting the solute molecule. The data must be in atomic units and the file must contain the following information sequentially: T               < Number of tesserae s_x(1:T)        < coordinates x of the tesserae s_y(1:T)        < coordinates y of the tesserae s_z(1:T)        < coordinates z of the tesserae A(1:T)          < areas of the tesserae R_sph(1:T)      < Radii of the spheres to which the tesserae belong normal(1:T,1:3) < Outgoing unitary vectors at the tesserae surfaces",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/pcm/pcmcavity/"
  },
  "PCMSpheresOnH": {
    "type": "logical",
    "default": "no",
    "section": "Hamiltonian::PCM",
    "description": "If true, spheres centered at the Hydrogens atoms are included to build the solute cavity surface.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/pcm/pcmspheresonh/"
  },
  "PCMTessSubdivider": {
    "type": "integer",
    "default": "1",
    "section": "Hamiltonian::PCM",
    "description": "Allows to subdivide further each tessera refining the discretization of the cavity tesselation. Can take only two values, 1 or 4. 1 corresponds to 60 tesserae per sphere, while 4 corresponds to 240 tesserae per sphere.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/pcm/pcmtesssubdivider/"
  },
  "PCMTessMinDistance": {
    "type": "float",
    "default": "0.1",
    "section": "Hamiltonian::PCM",
    "description": "Minimum distance between tesserae. Any two tesserae having smaller distance in the starting tesselation will be merged together.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/pcm/pcmtessmindistance/"
  },
  "PCMCalcMethod": {
    "type": "integer",
    "default": "pcm_direct",
    "section": "Hamiltonian::PCM",
    "description": "Defines the method to be used to obtain the PCM potential.",
    "options": [
      {
        "name": "pcm_direct",
        "value": "1"
      },
      {
        "name": "pcm_poisson",
        "value": "2"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/pcm/pcmcalcmethod/"
  },
  "PCMChargeSmearNN": {
    "type": "integer",
    "default": "2 * max_area * PCMSmearingFactor",
    "section": "Hamiltonian::PCM",
    "description": "Defines the number of nearest neighbor mesh-points to be taken around each cavity tessera in order to smear the charge when PCMCalcMethod = pcm_poisson. Setting PCMChargeSmearNN = 1 means first nearest neighbors, PCMChargeSmearNN = 2 second nearest neighbors, and so on. The default value is such that the neighbor mesh contains points in a radius equal to the width used for the gaussian smearing.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/pcm/pcmchargesmearnn/"
  },
  "FilterPotentials": {
    "type": "integer",
    "default": "filter_ts",
    "section": "Hamiltonian",
    "description": "<tt>Octopus</tt> can filter the pseudopotentials so that they no longer contain Fourier components larger than the mesh itself. This is very useful to decrease the egg-box effect, and so should be used in all instances where atoms move (<i>e.g.</i> geometry optimization, molecular dynamics, and vibrational modes).",
    "options": [
      {
        "name": "filter_none",
        "value": "0"
      },
      {
        "name": "filter_TS",
        "value": "2"
      },
      {
        "name": "filter_BSB",
        "value": "3"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/filterpotentials/"
  },
  "GyromagneticRatio": {
    "type": "float",
    "default": "2.0023193043768",
    "section": "Hamiltonian",
    "description": "The gyromagnetic ratio of the electron. This is of course a physical constant, and the default value is the exact one that you should not touch, unless: (i)  You want to disconnect the anomalous Zeeman term in the Hamiltonian (then set it to zero; this number only affects that term); (ii) You are using an effective Hamiltonian, as is the case when you calculate a 2D electron gas, in which case you have an effective gyromagnetic factor that depends on the material.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/gyromagneticratio/"
  },
  "RelativisticCorrection": {
    "type": "integer",
    "default": "non_relativistic",
    "section": "Hamiltonian",
    "description": "The default value means that <i>no</i> relativistic correction is used. To include spin-orbit coupling turn <tt>RelativisticCorrection</tt> to <tt>spin_orbit</tt> (this will only work if <tt>SpinComponents</tt> has been set to <tt>non_collinear</tt>, which ensures the use of spinors).",
    "options": [
      {
        "name": "non_relativistic",
        "value": "0"
      },
      {
        "name": "spin_orbit",
        "value": "1"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/relativisticcorrection/"
  },
  "SOStrength": {
    "type": "float",
    "default": "1.0",
    "section": "Hamiltonian",
    "description": "Tuning of the spin-orbit coupling strength: setting this value to zero turns off spin-orbit terms in the Hamiltonian, and setting it to one corresponds to full spin-orbit.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/sostrength/"
  },
  "GaugeFieldDynamics": {
    "type": "integer",
    "default": "polarization",
    "section": "Hamiltonian",
    "description": "This variable select the dynamics of the gauge field used to apply a finite electric field to periodic systems in time-dependent runs.",
    "options": [
      {
        "name": "none",
        "value": "0"
      },
      {
        "name": "polarization",
        "value": "1"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/gaugefielddynamics/"
  },
  "GaugeFieldPropagate": {
    "type": "logical",
    "default": "no",
    "section": "Hamiltonian",
    "description": "Propagate the gauge field with initial condition set by GaugeVectorField or zero if not specified",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/gaugefieldpropagate/"
  },
  "GaugeVectorField": {
    "type": "block",
    "default": "",
    "section": "Hamiltonian",
    "description": "The gauge vector field is used to include a uniform (but time-dependent) external electric field in a time-dependent run for a periodic system. An optional second row specifies the initial value for the time derivative of the gauge field (which is set to zero by default). By default this field is not included. If <tt>KPointsUseSymmetries = yes</tt>, then <tt>SymmetryBreakDir</tt> must be set in the same direction. This is used with utility <tt>oct-dielectric_function</tt> according to GF Bertsch, J-I Iwata, A Rubio, and K Yabana, <i>Phys. Rev. B</i> <b>62</b>, 7998-8002 (2000).",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/gaugevectorfield/"
  },
  "GaugeFieldDelay": {
    "type": "float",
    "default": "0.",
    "section": "Hamiltonian",
    "description": "The application of the gauge field acts as a probe of the system. For dynamical systems one can apply this probe with a delay relative to the start of the simulation.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/gaugefielddelay/"
  },
  "HFSingularity": {
    "type": "integer",
    "default": "general",
    "section": "Hamiltonian::XC",
    "description": "(Experimental) This variable selects the method used for the treatment of the singularity of the Coulomb potential in Hatree-Fock and hybrid-functional DFT calculations. This shoulbe be only applied for periodic systems and is only used for FFT kernels of the Poisson solvers.",
    "options": [
      {
        "name": "none",
        "value": "0"
      },
      {
        "name": "general",
        "value": "1"
      },
      {
        "name": "fcc",
        "value": "2"
      },
      {
        "name": "spherical_bz",
        "value": "3"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/xc/hfsingularity/"
  },
  "HFSingularityNk": {
    "type": "integer",
    "default": "60 in 3D, 1200 in 1D",
    "section": "Hamiltonian::XC",
    "description": "Number of k-point used (total number of k-points) is (2*Nk+1)^3) in the numerical integration of the auxiliary function f(q). See PRB 75, 205126 (2007) for more details. Only for HFSingularity=general. Also used in 1D.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/xc/hfsingularitynk/"
  },
  "HFSingularityNsteps": {
    "type": "integer",
    "default": "7 in 3D, 15 in 1D",
    "section": "Hamiltonian::XC",
    "description": "Number of grid refinement steps in the numerical integration of the auxiliary function f(q). See PRB 75, 205126 (2007) for more details. Only for HFSingularity=general. Also used in 1D.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/xc/hfsingularitynsteps/"
  },
  "XCUseGaugeIndependentKED": {
    "type": "logical",
    "default": "yes",
    "section": "Hamiltonian::XC",
    "description": "If true, when evaluating the XC functional, a term including the (paramagnetic or total) current is added to the kinetic-energy density such as to make it gauge-independent. Applies only to meta-GGA (and hybrid meta-GGA) functionals.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/xc/xcusegaugeindependentked/"
  },
  "XCKernelLRCAlpha": {
    "type": "float",
    "default": "0.0",
    "section": "Hamiltonian::XC",
    "description": "Set to a non-zero value to add a long-range correction for solids to the kernel. This is the <math>\\alpha</math> parameter defined in S. Botti <i>et al.</i>, <i>Phys. Rev. B</i> 69, 155112 (2004). The <math>\\Gamma = \\Gamma` = 0</math> term <math>-\\alpha/q^2</math> is taken into account by introducing an additional pole to the polarizability (see R. Stubner <i>et al.</i>, <i>Phys. Rev. B</i> 70, 245119 (2004)). The rest of the terms are included by multiplying the Hartree term by <math>1 - \\alpha / 4 \\pi</math>. The use of non-zero <math>\\alpha</math> in combination with <tt>HamiltonianVariation</tt> = <tt>V_ext_only</tt> corresponds to account of only the <math>\\Gamma = \\Gamma` = 0</math> term. Applicable only to isotropic systems. (Experimental)",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/xc/xckernellrcalpha/"
  },
  "XCDensityCorrection": {
    "type": "integer",
    "default": "none",
    "section": "Hamiltonian::XC::DensityCorrection",
    "description": "This variable controls the long-range correction of the XC potential using the <a href=http://arxiv.org/abs/1107.4339>XC density representation</a>.",
    "options": [
      {
        "name": "none",
        "value": "0"
      },
      {
        "name": "long_range_x",
        "value": "1"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/xc/densitycorrection/xcdensitycorrection/"
  },
  "XCDensityCorrectionOptimize": {
    "type": "logical",
    "default": "true",
    "section": "Hamiltonian::XC::DensityCorrection",
    "description": "When enabled, the density cutoff will be optimized to replicate the boundary conditions of the exact XC potential. If the variable is set to no, the value of the cutoff must be given by the <tt>XCDensityCorrectionCutoff</tt> variable.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/xc/densitycorrection/xcdensitycorrectionoptimize/"
  },
  "XCDensityCorrectionCutoff": {
    "type": "float",
    "default": "0.0",
    "section": "Hamiltonian::XC::DensityCorrection",
    "description": "The value of the cutoff applied to the XC density.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/xc/densitycorrection/xcdensitycorrectioncutoff/"
  },
  "XCDensityCorrectionMinimum": {
    "type": "logical",
    "default": "true",
    "section": "Hamiltonian::XC::DensityCorrection",
    "description": "When enabled, the cutoff optimization will return the first minimum of the <math>q_{xc}</math> function if it does not find a value of -1 (<a href=http://arxiv.org/abs/1107.4339>details</a>). This is required for atoms or small molecules, but may cause numerical problems.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/xc/densitycorrection/xcdensitycorrectionminimum/"
  },
  "XCDensityCorrectionNormalize": {
    "type": "logical",
    "default": "true",
    "section": "Hamiltonian::XC::DensityCorrection",
    "description": "When enabled, the correction will be normalized to reproduce the exact boundary conditions of the XC potential.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/xc/densitycorrection/xcdensitycorrectionnormalize/"
  },
  "ParallelXC": {
    "type": "logical",
    "default": "true",
    "section": "Execution::Parallelization",
    "description": "When enabled, additional parallelization will be used for the calculation of the XC functional.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/parallelization/parallelxc/"
  },
  "LRMaximumIter": {
    "type": "integer",
    "default": "200",
    "section": "Linear Response::SCF in LR calculations",
    "description": "The maximum number of SCF iterations to calculate response.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/linear response/scf in lr calculations/lrmaximumiter/"
  },
  "LRConvAbsDens": {
    "type": "float",
    "default": "1e-5",
    "section": "Linear Response::SCF in LR calculations",
    "description": "The tolerance in the absolute variation of the density response, to determine if the SCF for linear response is converged. <math>\\varepsilon = \\int {\\rm d}^3r \\left| \\rho^{out}(\\bf r) -\\rho^{inp}(\\bf r) \\right|</math>. A zero value means do not use this criterion.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/linear response/scf in lr calculations/lrconvabsdens/"
  },
  "LRConvRelDens": {
    "type": "float",
    "default": "0.0",
    "section": "Linear Response::SCF in LR calculations",
    "description": "The tolerance in the relative variation of the density response, to determine if the SCF for linear response is converged. <math>\\varepsilon = \\frac{1}{N_{\\rm elec}}</math> <tt>LRConvAbsDens</tt>. A zero value means do not use this criterion.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/linear response/scf in lr calculations/lrconvreldens/"
  },
  "LRTolScheme": {
    "type": "integer",
    "default": "tol_adaptive",
    "section": "Linear Response::SCF in LR calculations",
    "description": "The scheme used to adjust the tolerance of the solver during the SCF iteration. For <tt>kdotp</tt> and magnetic <tt>em_resp</tt> modes, or whenever <tt>HamiltonianVariation = V_ext_only</tt>, the scheme is set to <tt>tol_fixed</tt>, and this variable is ignored.",
    "options": [
      {
        "name": "tol_fixed",
        "value": "0"
      },
      {
        "name": "tol_adaptive",
        "value": "1"
      },
      {
        "name": "tol_linear",
        "value": "2"
      },
      {
        "name": "tol_exp",
        "value": "3"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/linear response/scf in lr calculations/lrtolscheme/"
  },
  "LRTolInitTol": {
    "type": "float",
    "default": "1e-2",
    "section": "Linear Response::Solver",
    "description": "This is the tolerance to determine that the linear solver has converged, for the first SCF iteration. Ignored if <tt>LRTolScheme = fixed</tt>.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/linear response/solver/lrtolinittol/"
  },
  "LRTolFinalTol": {
    "type": "float",
    "default": "1e-6",
    "section": "Linear Response::Solver",
    "description": "This is the tolerance to determine that the linear solver has converged.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/linear response/solver/lrtolfinaltol/"
  },
  "LRTolAdaptiveFactor": {
    "type": "float",
    "default": "0.1",
    "section": "Linear Response::SCF in LR calculations",
    "description": "This factor controls how much the tolerance is decreased during the self-consistency process. Smaller values mean that tolerance is decreased faster.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/linear response/scf in lr calculations/lrtoladaptivefactor/"
  },
  "LRTolIterWindow": {
    "type": "float",
    "default": "10",
    "section": "Linear Response::SCF in LR calculations",
    "description": "Number of iterations necessary to reach the final tolerance.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/linear response/scf in lr calculations/lrtoliterwindow/"
  },
  "PoissonSolverMaxMultipole": {
    "type": "integer",
    "default": "is 4 for <tt>PoissonSolver = cg_corrected</tt> and <tt>multigrid</tt>, and 2",
    "section": "Hamiltonian::Poisson",
    "description": "Order of the multipolar expansion for boundary corrections. The Poisson solvers <tt>multigrid</tt>, <tt>cg</tt>, and <tt>cg_corrected</tt> (and <tt>fft</tt> with <tt>PoissonFFTKernel = multipole_correction</tt>) do a multipolar expansion of the given charge density, such that <math>\\rho = \\rho_{multip.expansion}+\\Delta \\rho</math>. The Hartree potential due to the <math>\\rho_{multip.expansion}</math> is calculated analytically, while the Hartree potential due to <math>\\Delta \\rho</math> is calculated with either a multigrid or cg solver. The order of the multipolar expansion is set by this variable. for <tt>fft</tt> with <tt>PoissonFFTKernel = multipole_correction</tt>.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/poisson/poissonsolvermaxmultipole/"
  },
  "PoissonSolverMaxIter": {
    "type": "integer",
    "default": "500",
    "section": "Hamiltonian::Poisson",
    "description": "The maximum number of iterations for conjugate-gradient Poisson solvers.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/poisson/poissonsolvermaxiter/"
  },
  "PoissonSolverThreshold": {
    "type": "float",
    "default": "1e-6",
    "section": "Hamiltonian::Poisson",
    "description": "The tolerance for the Poisson solution, used by the <tt>cg</tt>, <tt>cg_corrected</tt>, and <tt>multigrid</tt> solvers.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/poisson/poissonsolverthreshold/"
  },
  "Poisson1DSoftCoulombParam": {
    "type": "float",
    "default": "1.0 bohr",
    "section": "Hamiltonian::Poisson",
    "description": "When <tt>Dimensions = 1</tt>, to prevent divergence, the Coulomb interaction treated by the Poisson solver is not <math>1/r</math> but <math>1/\\sqrt{a^2 + r^2}</math>, where this variable sets the value of <math>a</math>.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/poisson/poisson1dsoftcoulombparam/"
  },
  "PhotonmodesFilename": {
    "type": "string",
    "default": "\"photonmodes\"",
    "section": "Linear Response::Casida",
    "description": "Filename for photon modes in text format - first line contains 2 integers: number of photon modes and number of columns - each further line contains the given number of floats for one photon mode",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/linear response/casida/photonmodesfilename/"
  },
  "PhotonModes": {
    "type": "block",
    "default": "",
    "section": "Hamiltonian::XC",
    "description": "Each line of the block should specify one photon mode. The syntax is the following: %PhotonModes omega1 | lambda1| PolX1 | PolY1 | PolZ1 ... % The first column is the mode frequency, in units of energy. The second column is the coupling strength, in units of energy. The remaining columns specify the polarization direction of the mode. If the polarization vector should be normalized to one. If that is not the case the code will normalize it.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/xc/photonmodes/"
  },
  "TDPhotonicTimeScale": {
    "type": "float",
    "default": "1.0",
    "section": "Time-Dependent::Propagation",
    "description": "This variable defines the factor between the timescale of photonic and electronic movement. for more details see the documentation of TDIonicTimeScale If you also use TDIonicTimeScale, we advise to set TDPhotonicTimeScale = TDIonicTimeScale, in the case the photon frequency is in a vibrational energy range. Important: The electronic time step will be the value of <tt>TDTimeStep</tt> divided by this variable, so if you have determined an optimal electronic time step (that we can call <i>dte</i>), it is recommended that you define your time step as: <tt>TDTimeStep</tt> = <i>dte</i> * <tt>TDPhotonicTimeScale</tt> so you will always use the optimal electronic time step (<a href=http://arxiv.org/abs/0710.3321>more details</a>).",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/propagation/tdphotonictimescale/"
  },
  "DressedOrbitals": {
    "type": "logical",
    "default": "false",
    "section": "Hamiltonian::Poisson",
    "description": "Allows for the calculation of coupled elecron-photon problems by applying the dressed orbital approach. Details can be found in https://arxiv.org/abs/1812.05562 At the moment, N electrons in d (<=3) spatial dimensions, coupled to one photon mode can be described. The photon mode is included by raising the orbital dimension to d+1 and changing the particle interaction kernel and the local potential, where the former is included automatically, but the latter needs to by added by hand as a user_defined_potential! Coordinate 1-d: electron; coordinate d+1: photon.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/poisson/dressedorbitals/"
  },
  "ParallelizationPoissonAllNodes": {
    "type": "logical",
    "default": "true",
    "section": "Execution::Parallelization",
    "description": "When running in parallel, this variable selects whether the Poisson solver should divide the work among all nodes or only among the parallelization-in-domains groups.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/parallelization/parallelizationpoissonallnodes/"
  },
  "PoissonSolver": {
    "type": "integer",
    "default": "",
    "section": "Hamiltonian::Poisson",
    "description": "Defines which method to use to solve the Poisson equation. Some incompatibilities apply depending on dimensionality, periodicity, etc. For a comparison of the accuracy and performance of the methods in Octopus, see P Garcia-Risue&ntilde;o, J Alberdi-Rodriguez <i>et al.</i>, <i>J. Comp. Chem.</i> <b>35</b>, 427-444 (2014) or <a href=http://arxiv.org/abs/1211.2092>arXiV</a>. Defaults: <br> 1D and 2D: <tt>fft</tt>. <br> 3D: <tt>cg_corrected</tt> if curvilinear, <tt>isf</tt> if not periodic, <tt>fft</tt> if periodic. <br> Dressed orbitals: <tt>direct_sum</tt>.",
    "options": [
      {
        "name": "fft",
        "value": "0"
      },
      {
        "name": "cg",
        "value": "5"
      },
      {
        "name": "cg_corrected",
        "value": "6"
      },
      {
        "name": "multigrid",
        "value": "7"
      },
      {
        "name": "isf",
        "value": "8"
      },
      {
        "name": "psolver",
        "value": "10"
      },
      {
        "name": "poke",
        "value": "11"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/poisson/poissonsolver/"
  },
  "PoissonFFTKernel": {
    "type": "integer",
    "default": "",
    "section": "Hamiltonian::Poisson",
    "description": "Defines which kernel is used to impose the correct boundary conditions when using FFTs to solve the Poisson equation. The default is selected depending on the dimensionality and periodicity of the system: <br>In 1D, <tt>spherical</tt> if finite, <tt>fft_nocut</tt> if periodic. <br>In 2D, <tt>spherical</tt> if finite, <tt>cylindrical</tt> if 1D-periodic, <tt>fft_nocut</tt> if 2D-periodic. <br>In 3D, <tt>spherical</tt> if finite, <tt>cylindrical</tt> if 1D-periodic, <tt>planar</tt> if 2D-periodic, <tt>fft_nocut</tt> if 3D-periodic. See C. A. Rozzi et al., <i>Phys. Rev. B</i> <b>73</b>, 205119 (2006) for 3D implementation and A. Castro et al., <i>Phys. Rev. B</i> <b>80</b>, 033102 (2009) for 2D implementation.",
    "options": [
      {
        "name": "spherical",
        "value": "0"
      },
      {
        "name": "cylindrical",
        "value": "1"
      },
      {
        "name": "planar",
        "value": "2"
      },
      {
        "name": "fft_nocut",
        "value": "3"
      },
      {
        "name": "multipole_correction",
        "value": "4"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/poisson/poissonfftkernel/"
  },
  "DoubleFFTParameter": {
    "type": "float",
    "default": "2.0",
    "section": "Mesh::FFTs",
    "description": "For solving the Poisson equation in Fourier space, and for applying the local potential in Fourier space, an auxiliary cubic mesh is built. This mesh will be larger than the circumscribed cube of the usual mesh by a factor <tt>DoubleFFTParameter</tt>. See the section that refers to Poisson equation, and to the local potential for details [the default value of two is typically good].",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/mesh/ffts/doublefftparameter/"
  },
  "PoissonTestPeriodicThreshold": {
    "type": "float",
    "default": "1e-5",
    "section": "Hamiltonian::Poisson",
    "description": "This threshold determines the accuracy of the periodic copies of the Gaussian charge distribution that are taken into account when computing the analytical solution for periodic systems. Be aware that the default leads to good results for systems that are periodic in 1D - for 3D it is very costly because of the large number of copies needed.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/poisson/poissontestperiodicthreshold/"
  },
  "PoissonSolverPSolverParallelData": {
    "type": "logical",
    "default": "yes",
    "section": "Hamiltonian::Poisson::PSolver",
    "description": "Indicates whether data is partitioned within the PSolver library. If data is distributed among processes, Octopus uses parallel data-structures and, thus, less memory. If \"yes\", data is parallelized. The <i>z</i>-axis of the input vector is split among the MPI processes. If \"no\", entire input and output vector is saved in all the MPI processes. If k-points parallelization is used, \"no\" must be selected.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/poisson/psolver/poissonsolverpsolverparalleldata/"
  },
  "DeltaEFMM": {
    "type": "float",
    "default": "0.0001",
    "section": "Hamiltonian::Poisson",
    "description": "Dimensionless parameter for relative convergence of <tt>PoissonSolver = FMM</tt>. Sets energy error bound. Strong inhomogeneous systems may violate the error bound. For inhomogeneous systems we have an error-controlled sequential version available (from Ivo Kabadshow). Our implementation of FMM (based on H. Dachsel, <i>J. Chem. Phys.</i> <b>131</b>, 244102 (2009)) can keep the error of the Hartree energy below an arbitrary bound. The quotient of the value chosen for the maximum error in the Hartree energy and the value of the Hartree energy is <tt>DeltaEFMM</tt>.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/poisson/deltaefmm/"
  },
  "AlphaFMM": {
    "type": "float",
    "default": "0.291262136",
    "section": "Hamiltonian::Poisson",
    "description": "Dimensionless parameter for the correction of the self-interaction of the electrostatic Hartree potential, when using <tt>PoissonSolver = FMM</tt>. Octopus represents charge density on a real-space grid, each point containing a value <math>\\rho</math> corresponding to the charge density in the cell centered in such point. Therefore, the integral for the Hartree potential at point <math>i</math>, <math>V_H(i)</math>, can be reduced to a summation: <math>V_H(i) = \\frac{\\Omega}{4\\pi\\varepsilon_0} \\sum_{i \\neq j} \\frac{\\rho(\\vec{r}(j))}{|\\vec{r}(j) - \\vec{r}(i)|} + V_{self.int.}(i)</math> where <math>\\Omega</math> is the volume element of the mesh, and <math>\\vec{r}(j)</math> is the position of the point <math>j</math>. The <math>V_{self.int.}(i)</math> corresponds to the integral over the cell centered on the point <math>i</math> that is necessary to calculate the Hartree potential at point <math>i</math>: <math>V_{self.int.}(i)=\\frac{1}{4\\pi\\varepsilon_0} \\int_{\\Omega(i)}d\\vec{r} \\frac{\\rho(\\vec{r}(i))}{|\\vec{r}-\\vec{r}(i)|}</math> In the FMM version implemented into Octopus, a correction method for <math>V_H(i)</math> is used (see Garc&iacute;a-Risue&ntilde;o <i>et al.</i>, <i>J. Comp. Chem.</i> <b>35</b>, 427 (2014)). This method defines cells neighbouring cell <math>i</math>, which have volume <math>\\Omega(i)/8</math> (in 3D) and charge density obtained by interpolation. In the calculation of <math>V_H(i)</math>, in order to avoid double counting of charge, and to cancel part of the errors arising from considering the distances constant in the summation above, a term <math>-\\alpha_{FMM}V_{self.int.}(i)</math> is added to the summation (see the paper for the explicit formulae).",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/poisson/alphafmm/"
  },
  "PoissonCutoffRadius": {
    "type": "float",
    "default": "",
    "section": "Hamiltonian::Poisson",
    "description": "When <tt>PoissonSolver = fft</tt> and <tt>PoissonFFTKernel</tt> is neither <tt>multipole_corrections</tt> nor <tt>fft_nocut</tt>, this variable controls the distance after which the electron-electron interaction goes to zero. A warning will be written if the value is too large and will cause spurious interactions between images. The default is half of the FFT box max dimension in a finite direction.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/poisson/poissoncutoffradius/"
  },
  "PoissonSolverBoundaries": {
    "type": "integer",
    "default": "multipole",
    "section": "Hamiltonian::Poisson",
    "description": "For finite systems, some Poisson solvers (<tt>multigrid</tt>, <tt>cg_corrected</tt>, and <tt>fft</tt> with <tt>PoissonFFTKernel = multipole_correction</tt>) require the calculation of the boundary conditions with an auxiliary method. This variable selects that method.",
    "options": [
      {
        "name": "multipole",
        "value": "1"
      },
      {
        "name": "exact",
        "value": "3"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/poisson/poissonsolverboundaries/"
  },
  "PoissonSolverMGPresmoothingSteps": {
    "type": "integer",
    "default": "1",
    "section": "Hamiltonian::Poisson::Multigrid",
    "description": "Number of Gauss-Seidel smoothing steps before coarse-level correction in the multigrid Poisson solver.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/poisson/multigrid/poissonsolvermgpresmoothingsteps/"
  },
  "PoissonSolverMGPostsmoothingSteps": {
    "type": "integer",
    "default": "4",
    "section": "Hamiltonian::Poisson::Multigrid",
    "description": "Number of Gauss-Seidel smoothing steps after coarse-level correction in the multigrid Poisson solver.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/poisson/multigrid/poissonsolvermgpostsmoothingsteps/"
  },
  "PoissonSolverMGMaxCycles": {
    "type": "integer",
    "default": "60",
    "section": "Hamiltonian::Poisson::Multigrid",
    "description": "Maximum number of multigrid cycles that are performed if convergence is not achieved.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/poisson/multigrid/poissonsolvermgmaxcycles/"
  },
  "PoissonSolverMGRestrictionMethod": {
    "type": "integer",
    "default": "fullweight",
    "section": "Hamiltonian::Poisson::Multigrid",
    "description": "Method used from fine-to-coarse grid transfer.",
    "options": [
      {
        "name": "injection",
        "value": "1"
      },
      {
        "name": "fullweight",
        "value": "2"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/poisson/multigrid/poissonsolvermgrestrictionmethod/"
  },
  "PoissonSolverMGRelaxationMethod": {
    "type": "integer",
    "default": "",
    "section": "Hamiltonian::Poisson::Multigrid",
    "description": "Method used to solve the linear system approximately in each grid for the multigrid procedure that solves Poisson equation. Default is <tt>gauss_seidel</tt>, unless curvilinear coordinates are used, in which case the default is <tt>gauss_jacobi</tt>.",
    "options": [
      {
        "name": "gauss_seidel",
        "value": "1"
      },
      {
        "name": "gauss_jacobi",
        "value": "2"
      },
      {
        "name": "gauss_jacobi2",
        "value": "3"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/poisson/multigrid/poissonsolvermgrelaxationmethod/"
  },
  "PoissonSolverMGRelaxationFactor": {
    "type": "float",
    "default": "",
    "section": "Hamiltonian::Poisson::Multigrid",
    "description": "Relaxation factor of the relaxation operator used for the multigrid method. This is mainly for debugging, since overrelaxation does not help in a multigrid scheme. The default is 1.0, except 0.6666 for the <tt>gauss_jacobi</tt> method.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/poisson/multigrid/poissonsolvermgrelaxationfactor/"
  },
  "PoissonSolverNodes": {
    "type": "integer",
    "default": "0",
    "section": "Hamiltonian::Poisson",
    "description": "How many nodes to use to solve the Poisson equation. A value of 0, the default, implies that all available nodes are used.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/poisson/poissonsolvernodes/"
  },
  "TDIonicTimeScale": {
    "type": "float",
    "default": "1.0",
    "section": "Time-Dependent::Propagation",
    "description": "This variable defines the factor between the timescale of ionic and electronic movement. It allows reasonably fast Born-Oppenheimer molecular-dynamics simulations based on Ehrenfest dynamics. The value of this variable is equivalent to the role of <math>\\mu</math> in Car-Parrinello. Increasing it linearly accelerates the time step of the ion dynamics, but also increases the deviation of the system from the Born-Oppenheimer surface. The default is 1, which means that both timescales are the same. Note that a value different than 1 implies that the electrons will not follow physical behaviour. According to our tests, values around 10 are reasonable, but it will depend on your system, mainly on the width of the gap. Important: The electronic time step will be the value of <tt>TDTimeStep</tt> divided by this variable, so if you have determined an optimal electronic time step (that we can call <i>dte</i>), it is recommended that you define your time step as: <tt>TDTimeStep</tt> = <i>dte</i> * <tt>TDIonicTimeScale</tt> so you will always use the optimal electronic time step (<a href=http://arxiv.org/abs/0710.3321>more details</a>).",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/propagation/tdionictimescale/"
  },
  "IonsConstantVelocity": {
    "type": "logical",
    "default": "no",
    "section": "Time-Dependent::Propagation",
    "description": "(Experimental) If this variable is set to yes, the ions will move with a constant velocity given by the initial conditions. They will not be affected by any forces.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/propagation/ionsconstantvelocity/"
  },
  "IonsTimeDependentDisplacements": {
    "type": "block",
    "default": "",
    "section": "Time-Dependent::Propagation",
    "description": "(Experimental) This variable allows you to specify a time-dependent function describing the displacement of the ions from their equilibrium position: <math>r(t) = r_0 + \\Delta r(t)</math>.  Specify the displacements dx(t), dy(t), dz(t) as follows, for some or all of the atoms: <tt>%IonsTimeDependentDisplacements <br>&nbsp;&nbsp; atom_index | \"dx(t)\" | \"dy(t)\" | \"dz(t)\" <br>%</tt> The displacement functions are time-dependent functions and should match one of the function names given in the first column of the <tt>TDFunctions</tt> block. If this block is set, the ions will not be affected by any forces.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/propagation/ionstimedependentdisplacements/"
  },
  "Thermostat": {
    "type": "integer",
    "default": "none",
    "section": "Time-Dependent::Propagation",
    "description": "This variable selects the type of thermostat applied to control the ionic temperature.",
    "options": [
      {
        "name": "none",
        "value": "0"
      },
      {
        "name": "velocity_scaling",
        "value": "1"
      },
      {
        "name": "nose_hoover",
        "value": "2"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/propagation/thermostat/"
  },
  "TemperatureFunction": {
    "type": "integer",
    "default": "\"temperature\"",
    "section": "Time-Dependent::Propagation",
    "description": "If a thermostat is used, this variable indicates the name of the function in the <tt>TDFunctions</tt> block that will be used to control the temperature. The values of the temperature are given in degrees Kelvin.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/propagation/temperaturefunction/"
  },
  "ThermostatMass": {
    "type": "float",
    "default": "1.0",
    "section": "Time-Dependent::Propagation",
    "description": "This variable sets the fictitious mass for the Nose-Hoover thermostat.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/propagation/thermostatmass/"
  },
  "RandomVelocityTemp": {
    "type": "float",
    "default": "0.0",
    "section": "System::Velocities",
    "description": "If this variable is present, <tt>Octopus</tt> will assign random velocities to the atoms following a Boltzmann distribution with temperature given by <tt>RandomVelocityTemp</tt> (in degrees Kelvin). The seed for the random number generator can be modified by setting <tt>GSL_RNG_SEED</tt> environment variable.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/system/velocities/randomvelocitytemp/"
  },
  "XYZVelocities": {
    "type": "string",
    "default": "",
    "section": "System::Velocities",
    "description": "<tt>Octopus</tt> will try to read the starting velocities of the atoms from the XYZ file specified by the variable <tt>XYZVelocities</tt>. Note that you do not need to specify initial velocities if you are not going to perform ion dynamics; if you are going to allow the ions to move but the velocities are not specified, they are considered to be null. Note: It is important for the velocities to maintain the ordering in which the atoms were defined in the coordinates specifications.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/system/velocities/xyzvelocities/"
  },
  "XSFVelocities": {
    "type": "string",
    "default": "",
    "section": "System::Velocities",
    "description": "Like <tt>XYZVelocities</tt> but in XCrySDen format, as in <tt>XSFCoordinates</tt>.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/system/velocities/xsfvelocities/"
  },
  "PDBVelocities": {
    "type": "string",
    "default": "",
    "section": "System::Velocities",
    "description": "Like <tt>XYZVelocities</tt> but in PDB format, as in <tt>PDBCoordinates</tt>.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/system/velocities/pdbvelocities/"
  },
  "Velocities": {
    "type": "block",
    "default": "",
    "section": "System::Velocities",
    "description": "If <tt>XYZVelocities</tt>, <tt>PDBVelocities</tt>, and <tt>XSFVelocities</tt> are not present, <tt>Octopus</tt> will try to fetch the initial atomic velocities from this block. If this block is not present, <tt>Octopus</tt> will set the initial velocities to zero. The format of this block can be illustrated by this example: <tt>%Velocities <br>&nbsp;&nbsp;'C'  |      -1.7 | 0.0 | 0.0 <br>&nbsp;&nbsp;'O'  | &nbsp;1.7 | 0.0 | 0.0 <br>%</tt> It describes one carbon and one oxygen moving at the relative velocity of 3.4 velocity units. Note: It is important for the velocities to maintain the ordering in which the atoms were defined in the coordinates specifications.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/system/velocities/velocities/"
  },
  "MoveIons": {
    "type": "logical",
    "default": "",
    "section": "Time-Dependent::Propagation",
    "description": "This variable controls whether atoms are moved during a time propagation run. The default is yes when the ion velocity is set explicitly or implicitly, otherwise is no.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/propagation/moveions/"
  },
  "PDBCoordinates": {
    "type": "string",
    "default": "",
    "section": "System::Coordinates",
    "description": "If this variable is present, the program tries to read the atomic coordinates from the file specified by its value. The PDB (<a href=http://www.rcsb.org/pdb>Protein Data Bank</a>) format is quite complicated, and it goes well beyond the scope of this manual. You can find a comprehensive description <a href=http://www.wwpdb.org/docs.html>here</a>. From the plethora of instructions defined in the PDB standard, <tt>Octopus</tt> only reads two, <tt>ATOM</tt> and <tt>HETATOM</tt>. From these fields, it reads: <ul> <li> columns 13-16: The species; in fact <tt>Octopus</tt> only cares about the first letter - <tt>CA</tt> and <tt>CB</tt> will both refer to carbon - so elements whose chemical symbol has more than one letter cannot be represented in this way. So, if you want to run mercury (Hg), please use one of the other methods to input the coordinates. <li> columns 18-21: The residue. Ignored. <li> columns 31-54: The Cartesian coordinates. The Fortran format is <tt>(3f8.3)</tt>.</li> <li> columns 61-65: Classical charge of the atom. Required if reading classical atoms, ignored otherwise. The Fortran format is <tt>(f6.2)</tt>.</li> </ul> NOTE: The coordinates are treated in the units specified by <tt>Units</tt> and/or <tt>UnitsInput</tt>.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/system/coordinates/pdbcoordinates/"
  },
  "XYZCoordinates": {
    "type": "string",
    "default": "",
    "section": "System::Coordinates",
    "description": "If <tt>PDBCoordinates</tt> is not present, the program reads the atomic coordinates from the XYZ file specified by the variable <tt>XYZCoordinates</tt> -- in case this variable is present. The XYZ format is very simple: The first line of the file has an integer indicating the number of atoms. The second can contain comments that are simply ignored by <tt>Octopus</tt>. Then there follows one line per atom, containing the chemical species and the Cartesian coordinates of the atom. If you want to specify the unit of the XYZ file, you can use the variable <tt>UnitsXYZFiles</tt>.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/system/coordinates/xyzcoordinates/"
  },
  "XSFCoordinates": {
    "type": "string",
    "default": "",
    "section": "System::Coordinates",
    "description": "Another option besides PDB and XYZ coordinates formats is XSF, as <a href=http://www.xcrysden.org/doc/XSF.html>defined</a> by the XCrySDen visualization program. Specify the filename with this variable. The lattice vectors will also be read from this file and the value of <tt>PeriodicDimensions</tt> needs to be compatible with the first line (<tt>CRYSTAL</tt>, <tt>SLAB</tt>, <tt>POLYMER</tt>, or <tt>MOLECULE</tt>). The file should not contain <tt>ATOMS</tt>, <tt>CONVVEC</tt>, or <tt>PRIMCOORD</tt>. NOTE: The coordinates are treated in the units specified by <tt>Units</tt> and/or <tt>UnitsInput</tt>.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/system/coordinates/xsfcoordinates/"
  },
  "XSFCoordinatesAnimStep": {
    "type": "integer",
    "default": "1",
    "section": "System::Coordinates",
    "description": "If an animated file is given with <tt>XSFCoordinates</tt>, this variable selects which animation step will be used. The <tt>PRIMVEC</tt> block must be written for each step.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/system/coordinates/xsfcoordinatesanimstep/"
  },
  "Coordinates": {
    "type": "block",
    "default": "",
    "section": "System::Coordinates",
    "description": "If <tt>XYZCoordinates</tt>, <tt>PDBCoordinates</tt>, and <tt>XSFCoordinates</tt> were not found, <tt>Octopus</tt> tries to read the coordinates for the atoms from the block <tt>Coordinates</tt>. The format is quite straightforward: <tt>%Coordinates <br>&nbsp;&nbsp;'C' |      -0.56415 | 0.0 | 0.0 | no <br>&nbsp;&nbsp;'O' | &nbsp;0.56415 | 0.0 | 0.0 | no <br>%</tt> The first line defines a carbon atom at coordinates (-0.56415, 0.0, 0.0), that is <b>not</b> allowed to move during dynamical simulations. The second line has a similar meaning. This block obviously defines a carbon monoxide molecule, if the input units are <tt>eV_Angstrom</tt>. The number of coordinates for each species must be equal to the dimension of your space (generally 3). Note that in this way it is possible to fix some of the atoms (this is not possible when specifying the coordinates through a <tt>PDBCoordinates</tt> or <tt>XYZCoordinates</tt> file). The last column is optional, and the default is yes. It is always possible to fix <b>all</b> atoms using the <tt>MoveIons</tt> directive.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/system/coordinates/coordinates/"
  },
  "ReducedCoordinates": {
    "type": "block",
    "default": "",
    "section": "System::Coordinates",
    "description": "This block gives the atomic coordinates relative to the real space unit cell. The format is the same as the <tt>Coordinates</tt> block. Note that in Octopus the origin of coordinates is in the center of the cell, so the coordinates inside the cell are in the range [-0.5, 0.5). This block cannot be used with the <tt>minimum</tt> box shape.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/system/coordinates/reducedcoordinates/"
  },
  "SymmetriesCompute": {
    "type": "logical",
    "default": "",
    "section": "Execution::Symmetries",
    "description": "If disabled, <tt>Octopus</tt> will not compute nor print the symmetries. By default, symmetries are computed when running in 3 dimensions for systems with less than 100 atoms. For periodic systems, the default is always true, irrespective of the number of atoms.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/symmetries/symmetriescompute/"
  },
  "SymmetriesTolerance": {
    "type": "float",
    "default": "",
    "section": "Execution::Symmetries",
    "description": "For periodic systems, this variable controls the tolerance used by the symmetry finder (spglib) to find the spacegroup and symmetries of the crystal.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/execution/symmetries/symmetriestolerance/"
  },
  "SymmetryBreakDir": {
    "type": "block",
    "default": "",
    "section": "Mesh::Simulation Box",
    "description": "This variable specifies a direction in which the symmetry of the system will be broken. This is useful for generating <i>k</i>-point grids when an external perturbation is applied.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/mesh/simulation box/symmetrybreakdir/"
  },
  "BornChargeSumRuleCorrection": {
    "type": "logical",
    "default": "true",
    "section": "Linear Response::Polarizabilities",
    "description": "Enforce the acoustic sum rule by distributing the excess sum of Born charges equally among the atoms. Sum rule: <math>\\sum_{\\alpha} Z^{*}_{\\alpha, i, j} = Z_{\\rm tot} \\delta_{ij}</math>. Violation of the sum rule may be caused by inadequate spacing, box size (in finite directions), or <i>k</i>-point sampling (in periodic directions).",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/linear response/polarizabilities/bornchargesumrulecorrection/"
  },
  "ForceTotalEnforce": {
    "type": "logical",
    "default": "no",
    "section": "Hamiltonian",
    "description": "(Experimental) If this variable is set to \"yes\", then the sum of the total forces will be enforced to be zero.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/forcetotalenforce/"
  },
  "TDGlobalForce": {
    "type": "string",
    "default": "",
    "section": "Time-Dependent",
    "description": "If this variable is set, a global time-dependent force will be applied to the ions in the x direction during a time-dependent run. This variable defines the base name of the force, that should be defined in the <tt>TDFunctions</tt> block. This force does not affect the electrons directly.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/tdglobalforce/"
  },
  "SpeciesTimeDependent": {
    "type": "logical",
    "default": "no",
    "section": "System::Species",
    "description": "When this variable is set, the potential defined in the block <tt>Species</tt> is calculated and applied to the Hamiltonian at each time step. You must have at least one <tt>species_user_defined</tt> type of species to use this.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/system/species/speciestimedependent/"
  },
  "DOSEnergyMin": {
    "type": "float",
    "default": "",
    "section": "Output",
    "description": "Lower bound for the energy mesh of the DOS. The default is the lowest eigenvalue, minus a quarter of the total range of eigenvalues.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/output/dosenergymin/"
  },
  "DOSEnergyMax": {
    "type": "float",
    "default": "",
    "section": "Output",
    "description": "Upper bound for the energy mesh of the DOS. The default is the highest eigenvalue, plus a quarter of the total range of eigenvalues.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/output/dosenergymax/"
  },
  "DOSEnergyPoints": {
    "type": "integer",
    "default": "500",
    "section": "Output",
    "description": "Determines how many energy points <tt>Octopus</tt> should use for the DOS energy grid.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/output/dosenergypoints/"
  },
  "DOSGamma": {
    "type": "float",
    "default": "0.008 Ha",
    "section": "Output",
    "description": "Determines the width of the Lorentzian which is used for the DOS sum.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/output/dosgamma/"
  },
  "DOSComputePDOS": {
    "type": "logical",
    "default": "false",
    "section": "Output",
    "description": "Determines if projected dos are computed or not. At the moment, the PDOS is computed from the bare pseudo-atomic orbitals, directly taken from the pseudopotentials. The orbitals are not orthonormalized, in order to preserve their atomic orbitals character. As a consequence, the sum of the different PDOS does not integrate to the total DOS. The radii of the orbitals are controled by the threshold defined by <tt>AOThreshold</tt>, and the fact that they are normalized or not by <tt>AONormalize</tt>.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/output/doscomputepdos/"
  },
  "CurrentDensity": {
    "type": "integer",
    "default": "gradient_corrected",
    "section": "Hamiltonian",
    "description": "This variable selects the method used to calculate the current density. For the moment this variable is for development purposes and users should not need to use it.",
    "options": [
      {
        "name": "gradient",
        "value": "1"
      },
      {
        "name": "gradient_corrected",
        "value": "2"
      },
      {
        "name": "hamiltonian",
        "value": "3"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/currentdensity/"
  },
  "Eigensolver": {
    "type": "integer",
    "default": "",
    "section": "SCF::Eigensolver",
    "description": "Which eigensolver to use to obtain the lowest eigenvalues and eigenfunctions of the Kohn-Sham Hamiltonian. The default is conjugate gradients (<tt>cg</tt>), except that when parallelization in states is enabled, the default is <tt>rmmdiis</tt>.",
    "options": [
      {
        "name": "cg",
        "value": "5"
      },
      {
        "name": "plan",
        "value": "11"
      },
      {
        "name": "cg_new",
        "value": "6"
      },
      {
        "name": "evolution",
        "value": "9"
      },
      {
        "name": "rmmdiis",
        "value": "10"
      },
      {
        "name": "chebyshev_filter",
        "value": "12"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/scf/eigensolver/eigensolver/"
  },
  "CGOrthogonalizeAll": {
    "type": "logical",
    "default": "no",
    "section": "SCF::Eigensolver",
    "description": "Used by the cg solver only. During the cg iterations, the current band can be orthogonalized against all other bands or only against the lower bands. Orthogonalizing against all other bands can improve convergence properties, whereas orthogonalizing against lower bands needs less operations. Moreover, orthogonalizing against all bands can make converging the highest band or unoccupied bands more difficult.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/scf/eigensolver/cgorthogonalizeall/"
  },
  "CGDirection": {
    "type": "integer",
    "default": "",
    "section": "SCF::Eigensolver",
    "description": "Used by the cg solver only. The conjugate direction is updated using a certain coefficient to the previous direction. This coeffiction can be computed in different ways. The default is to use Fletcher-Reeves (FR), an alternative is Polak-Ribiere (PR).",
    "options": [
      {
        "name": "fletcher",
        "value": "1"
      },
      {
        "name": "polak",
        "value": "2"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/scf/eigensolver/cgdirection/"
  },
  "CGAdditionalTerms": {
    "type": "logical",
    "default": "no",
    "section": "SCF::Eigensolver",
    "description": "Used by the cg solver only. Add additional terms during the line minimization, see PTA92, eq. 5.31ff. These terms can improve convergence for some systems, but they are quite costly. If you experience convergence problems, you might try out this option. This feature is still experimental.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/scf/eigensolver/cgadditionalterms/"
  },
  "CGEnergyChangeThreshold": {
    "type": "float",
    "default": "0.1",
    "section": "SCF::Eigensolver",
    "description": "Used by the cg solver only. For each band, the CG iterations are stopped when the change in energy is smaller than the change in the first iteration multiplied by this factor. This limits the number of CG iterations for each band, while still showing good convergence for the SCF cycle. The criterion is discussed in Sec. V.B.6 of Payne et al. (1992), Rev. Mod. Phys. 64, 4. The default value is 0.1, which is usually a good choice for LDA and GGA potentials. If you are solving the OEP equation, you might want to set this value to 1e-3 or smaller. In general, smaller values might help if you experience convergence problems. For very small convergence tolerances, choose 0 to disable this criterion.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/scf/eigensolver/cgenergychangethreshold/"
  },
  "EigensolverImaginaryTime": {
    "type": "float",
    "default": "0.1",
    "section": "SCF::Eigensolver",
    "description": "The imaginary-time step that is used in the imaginary-time evolution method (<tt>Eigensolver = evolution</tt>) to obtain the lowest eigenvalues/eigenvectors. It must satisfy <tt>EigensolverImaginaryTime > 0</tt>. Increasing this value can make the propagation faster, but could lead to unstable propagations.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/scf/eigensolver/eigensolverimaginarytime/"
  },
  "EigensolverMinimizationIter": {
    "type": "integer",
    "default": "0",
    "section": "SCF::Eigensolver",
    "description": "During the first iterations, the RMMDIIS eigensolver requires some steepest-descent minimizations to improve convergence. This variable determines the number of those minimizations.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/scf/eigensolver/eigensolverminimizationiter/"
  },
  "ChebyshevFilterLanczosOrder": {
    "type": "integer",
    "default": "5",
    "section": "SCF::Eigensolver",
    "description": "Used by the Chebyshev filter only. The number of Lanczos iterations used to construct the tridiagonal matrix, from which the upper bound of H is estimated. A value in the range 4 <= ChebyshevFilterLanczosOrder <= 10 is reasonable. Values greater than 10 will raise an assertion.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/scf/eigensolver/chebyshevfilterlanczosorder/"
  },
  "ChebyshevFilterDegree": {
    "type": "integer",
    "default": "10",
    "section": "SCF::Eigensolver",
    "description": "Used by the Chebyshev filter only. The degree of the Chebyshev polynomial used to dampen the interval of eigenstates one is not interested in. The larger the polynomial, the fewer SCF steps should be required to reach convergence, however this directly defines the number of matrix-vector products performed on the Hamiltonian per SCF step. A value in the range 8 <= ChebyshevFilterDegree <= 20 is reasonable.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/scf/eigensolver/chebyshevfilterdegree/"
  },
  "ChebyshevFilterBoundMixing": {
    "type": "float",
    "default": "0.5",
    "section": "SCF::Eigensolver",
    "description": "In the first application of the filter, for the first SCF step, the initial lower bound estimate is defined as a linear combination of the smallest and largest eigenvalues of the Hamiltonian. The bound mixing determines the proportion of linear mixing, beta: $b_{lower} = beta min{\\lambda} + (\\beta - 1) max{\\lambda}$ of the smallest and largest eigenvalues.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/scf/eigensolver/chebyshevfilterboundmixing/"
  },
  "ChebyshevFilterNIter": {
    "type": "integer",
    "default": "5",
    "section": "SCF::Eigensolver",
    "description": "The max number of iterations in the first SCF step of the Chebyshev solver. In practice this does not need to exceed 10, as the eigenstates will vary alot between the first and second SCF steps.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/scf/eigensolver/chebyshevfilterniter/"
  },
  "EigensolverTolerance": {
    "type": "float",
    "default": "",
    "section": "SCF::Eigensolver",
    "description": "This is the tolerance for the eigenvectors. The default is 1e-7.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/scf/eigensolver/eigensolvertolerance/"
  },
  "EigensolverMaxIter": {
    "type": "integer",
    "default": "",
    "section": "SCF::Eigensolver",
    "description": "Determines the maximum number of iterations that the eigensolver will perform if the desired tolerance is not achieved. The default is 25 iterations for all eigensolvers except for <tt>rmdiis</tt>, which performs only 5 iterations. Increasing this value for <tt>rmdiis</tt> increases the convergence speed, at the cost of an increased memory footprint. In the case of imaginary time propatation, this variable controls the number of iterations for which the Hxc potential is frozen. Default is 1 for the imaginary time evolution.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/scf/eigensolver/eigensolvermaxiter/"
  },
  "MagneticGaugeCorrection": {
    "type": "integer",
    "default": "gipaw",
    "section": "Linear Response",
    "description": "For magnetic linear response: how to handle gauge-invariance in the description of the coupling of electrons to the magnetic field.",
    "options": [
      {
        "name": "none",
        "value": "0"
      },
      {
        "name": "gipaw",
        "value": "1"
      },
      {
        "name": "icl",
        "value": "2"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/linear response/magneticgaugecorrection/"
  },
  "SubspaceDiagonalization": {
    "type": "integer",
    "default": "standard",
    "section": "SCF::Eigensolver",
    "description": "Selects the method to perform subspace diagonalization. The default is <tt>standard</tt>, unless states parallelization is used, when the default is <tt>scalapack</tt>. Note that this variable is not parsed in the case of the evolution eigensolver.",
    "options": [
      {
        "name": "none",
        "value": "0"
      },
      {
        "name": "standard",
        "value": "1"
      },
      {
        "name": "scalapack",
        "value": "3"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/scf/eigensolver/subspacediagonalization/"
  },
  "ELFWithCurrentTerm": {
    "type": "logical",
    "default": "true",
    "section": "Output",
    "description": "The ELF, when calculated for complex wavefunctions, should contain a term dependent on the current. This term is properly calculated by default; however, for research purposes it may be useful not to add it. If this feature proves to be useless, this option should go away.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/output/elfwithcurrentterm/"
  },
  "TDExponentialMethod": {
    "type": "integer",
    "default": "taylor",
    "section": "Time-Dependent::Propagation",
    "description": "Method used to numerically calculate the exponential of the Hamiltonian, a core part of the full algorithm used to approximate the evolution operator, specified through the variable <tt>TDPropagator</tt>. In the case of using the Magnus method, described below, the action of the exponential of the Magnus operator is also calculated through the algorithm specified by this variable.",
    "options": [
      {
        "name": "lanczos",
        "value": "2"
      },
      {
        "name": "taylor",
        "value": "3"
      },
      {
        "name": "chebyshev",
        "value": "4"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/propagation/tdexponentialmethod/"
  },
  "TDLanczosTol": {
    "type": "float",
    "default": "1e-5",
    "section": "Time-Dependent::Propagation",
    "description": "An internal tolerance variable for the Lanczos method. The smaller, the more precisely the exponential is calculated, and also the bigger the dimension of the Krylov subspace needed to perform the algorithm. One should carefully make sure that this value is not too big, or else the evolution will be wrong.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/propagation/tdlanczostol/"
  },
  "TDExpOrder": {
    "type": "integer",
    "default": "4",
    "section": "Time-Dependent::Propagation",
    "description": "For <tt>TDExponentialMethod</tt> = <tt>standard</tt> or <tt>chebyshev</tt>, the order to which the exponential is expanded. For the Lanczos approximation, it is the Lanczos-subspace dimension.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/propagation/tdexporder/"
  },
  "ArnoldiOrthogonalization": {
    "type": "integer",
    "default": "",
    "section": "Time-Dependent::Propagation",
    "description": "The orthogonalization method used for the Arnoldi procedure. Only for TDExponentialMethod = lanczos.",
    "options": [
      {
        "name": "cgs",
        "value": "3"
      },
      {
        "name": "drcgs",
        "value": "5"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/propagation/arnoldiorthogonalization/"
  },
  "KdotPUseNonLocalPseudopotential": {
    "type": "logical",
    "default": "true",
    "section": "Linear Response::KdotP",
    "description": "For testing purposes, set to false to ignore the term <math>-i \\left[\\vec{r}, V\\right]</math> in the <math>\\vec{k} \\cdot \\vec{p}</math> perturbation, which is due to non-local pseudopotentials.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/linear response/kdotp/kdotpusenonlocalpseudopotential/"
  },
  "KdotPVelMethod": {
    "type": "integer",
    "default": "grad_vel",
    "section": "Linear Response::KdotP",
    "description": "Method of velocity calculation.",
    "options": [
      {
        "name": "grad_vel",
        "value": "0"
      },
      {
        "name": "hcom_vel",
        "value": "1"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/linear response/kdotp/kdotpvelmethod/"
  },
  "LinearSolver": {
    "type": "integer",
    "default": "qmr_symmetric",
    "section": "Linear Response::Solver",
    "description": "Method for solving linear equations, which occur for Sternheimer linear response and OEP. The solvers vary in speed, reliability (ability to converge), and domain of applicability. QMR solvers are most reliable.",
    "options": [
      {
        "name": "bicgstab",
        "value": "4"
      },
      {
        "name": "cg",
        "value": "5"
      },
      {
        "name": "multigrid",
        "value": "7"
      },
      {
        "name": "qmr_symmetric",
        "value": "81"
      },
      {
        "name": "qmr_symmetrized",
        "value": "82"
      },
      {
        "name": "qmr_dotp",
        "value": "83"
      },
      {
        "name": "qmr_general",
        "value": "84"
      },
      {
        "name": "sos",
        "value": "9"
      },
      {
        "name": "idrs",
        "value": "11"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/linear response/solver/linearsolver/"
  },
  "LinearSolverMaxIter": {
    "type": "integer",
    "default": "1000",
    "section": "Linear Response::Solver",
    "description": "Maximum number of iterations the linear solver does, even if convergence is not achieved.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/linear response/solver/linearsolvermaxiter/"
  },
  "SICCorrection": {
    "type": "integer",
    "default": "sic_none",
    "section": "Hamiltonian::XC",
    "description": "This variable controls which form of self-interaction correction to use. Note that this correction will be applied to the functional chosen by <tt>XCFunctional</tt>.",
    "options": [
      {
        "name": "sic_none",
        "value": "1"
      },
      {
        "name": "sic_pz",
        "value": "2"
      },
      {
        "name": "sic_amaldi",
        "value": "3"
      },
      {
        "name": "sic_adsic",
        "value": "4"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/xc/siccorrection/"
  },
  "KPointsUseSymmetries": {
    "type": "logical",
    "default": "no",
    "section": "Mesh::KPoints",
    "description": "This variable defines whether symmetries are taken into account or not for the choice of <i>k</i>-points. If it is set to no, the <i>k</i>-point sampling will range over the full Brillouin zone. When a perturbation is applied to the system, the full symmetries of the system cannot be used. In this case you must not use symmetries or use the <tt>SymmetryBreakDir</tt> to tell Octopus the direction of the perturbation (for the moment this has to be done by hand by the user, in the future it will be automatic).",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/mesh/kpoints/kpointsusesymmetries/"
  },
  "KPointsUseTimeReversal": {
    "type": "logical",
    "default": "",
    "section": "Mesh::KPoints",
    "description": "If symmetries are used to reduce the number of <i>k</i>-points, this variable defines whether time-reversal symmetry is taken into account or not. If it is set to no, the <i>k</i>-point sampling will not be reduced according to time-reversal symmetry. The default is yes, unless symmetries are broken in one direction by the <tt>SymmetryBreakDir</tt> block. Warning: For time propagation runs with an external field, time-reversal symmetry should not be used.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/mesh/kpoints/kpointsusetimereversal/"
  },
  "KPointsGrid": {
    "type": "block",
    "default": "<math>\\Gamma</math>-point only",
    "section": "Mesh::KPoints",
    "description": "When this block is given (and the <tt>KPoints</tt> block is not present), <i>k</i>-points are distributed in a uniform grid, according to a modified version of the Monkhorst-Pack scheme. For the original MP scheme, see James D. Pack and Hendrik J. Monkhorst, <i>Phys. Rev. B</i> <b>13</b>, 5188 (1976) and <i>Phys. Rev. B</i> <b>16</b>, 1748 (1977). The first row of the block is a set of integers defining the number of <i>k</i>-points to be used along each direction in reciprocal space. The numbers refer to the whole Brillouin zone, and the actual number of <i>k</i>-points is usually reduced exploiting the symmetries of the system.  By default the grid will always include the <math>\\Gamma</math>-point. Optional rows can be added to specify multiple shifts in the <i>k</i>-points (between 0.0 and 1.0), in units of the Brillouin zone divided by the number in the first row. The number of columns should be equal to <tt>Dimensions</tt>, but the grid and shift numbers should be 1 and zero in finite directions. For example, the following input samples the BZ with 100 points in the <i>xy</i>-plane of reciprocal space: <tt>%KPointsGrid <br>&nbsp;&nbsp;10 | 10 | 1 <br>%</tt>",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/mesh/kpoints/kpointsgrid/"
  },
  "QPointsGrid": {
    "type": "block",
    "default": "KPointsGrid",
    "section": "Mesh::KPoints",
    "description": "This block allows to define a q-point grid used for the calculation of the Fock operator with k-points. The <i>q</i>-points are distributed in a uniform grid, as done for the <tt>KPointsGrid</tt> variable. See J. Chem Phys. 124, 154709 (2006) for details For each dimension, the number of q point must be a divider of the number of  k point <tt>%QPointsGrid <br>&nbsp;&nbsp;2 | 2 | 1 <br>%</tt> At the moment, this is not compatible with k-point symmetries.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/mesh/kpoints/qpointsgrid/"
  },
  "KPointsPath": {
    "type": "block",
    "default": "",
    "section": "Mesh::KPoints",
    "description": "When this block is given, <i>k</i>-points are generated along a path defined by the points of the list. The points must be given in reduced coordinates. The first row of the block is a set of integers defining the number of <i>k</i>-points for each segments of the path. The number of columns should be equal to <tt>Dimensions</tt>, and the k-points coordinate should be zero in finite directions. For example, the following input samples the BZ with 15 points: <tt>%KPointsPath <br>&nbsp;&nbsp;10 | 5 <br>&nbsp;&nbsp; 0 | 0 | 0 <br>&nbsp;&nbsp; 0.5 | 0 | 0 <br>&nbsp;&nbsp; 0.5 | 0.5 | 0.5 <br>%</tt>",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/mesh/kpoints/kpointspath/"
  },
  "KPoints": {
    "type": "block",
    "default": "",
    "section": "Mesh::KPoints",
    "description": "This block defines an explicit set of <i>k</i>-points and their weights for a periodic-system calculation. The first column is the weight of each <i>k</i>-point and the following are the components of the <i>k</i>-point vector. You only need to specify the components for the periodic directions. Note that the <i>k</i>-points should be given in Cartesian coordinates (not in reduced coordinates), in the units of inverse length. The weights will be renormalized so they sum to 1 (and must be rational numbers). For example, if you want to include only the Gamma point, you can use: <tt>%KPoints <br>&nbsp;&nbsp;1.0 | 0 | 0 | 0 <br>%</tt>",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/mesh/kpoints/kpoints/"
  },
  "KPointsReduced": {
    "type": "block",
    "default": "",
    "section": "Mesh::KPoints",
    "description": "Same as the block <tt>KPoints</tt> but this time the input is given in reduced coordinates, <i>i.e.</i> what <tt>Octopus</tt> writes in a line in the ground-state standard output as <tt>#k =   1, k = (    0.154000,    0.154000,    0.154000)</tt>.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/mesh/kpoints/kpointsreduced/"
  },
  "OEPLevel": {
    "type": "integer",
    "default": "oep_kli",
    "section": "Hamiltonian::XC",
    "description": "At what level shall <tt>Octopus</tt> handle the optimized effective potential (OEP) equation.",
    "options": [
      {
        "name": "oep_none",
        "value": "1"
      },
      {
        "name": "oep_kli",
        "value": "3"
      },
      {
        "name": "oep_full",
        "value": "5"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/xc/oeplevel/"
  },
  "OEPMixing": {
    "type": "float",
    "default": "1.0",
    "section": "Hamiltonian::XC",
    "description": "The linear mixing factor used to solve the Sternheimer equation in the full OEP procedure.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/xc/oepmixing/"
  },
  "OEPMixingScheme": {
    "type": "integer",
    "default": "oep_mixing_scheme_const",
    "section": "Hamiltonian::XC",
    "description": "Different Mixing Schemes are possible",
    "options": [
      {
        "name": "oep_mixing_scheme_const",
        "value": "1"
      },
      {
        "name": "oep_mixing_scheme_bb",
        "value": "2"
      },
      {
        "name": "oep_mixing_scheme_dens",
        "value": "3"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/xc/oepmixingscheme/"
  },
  "KLIPhotonCOC": {
    "type": "logical",
    "default": ".false.",
    "section": "Hamiltonian::XC",
    "description": "Activate the center of charge translation of the electric dipole operator which should avoid the dependence of the photon KLI on an permanent dipole.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/xc/kliphotoncoc/"
  },
  "InvertKSmethod": {
    "type": "integer",
    "default": "iterative",
    "section": "Calculation Modes::Invert KS",
    "description": "Selects whether the exact two-particle method or the iterative scheme is used to invert the density to get the KS potential.",
    "options": [
      {
        "name": "two_particle",
        "value": "1"
      },
      {
        "name": "iterative",
        "value": "2"
      },
      {
        "name": "iter_stella",
        "value": "3"
      },
      {
        "name": "iter_godby",
        "value": "4"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/invert ks/invertksmethod/"
  },
  "KSInversionLevel": {
    "type": "integer",
    "default": "ks_inversion_adiabatic",
    "section": "Calculation Modes::Invert KS",
    "description": "At what level <tt>Octopus</tt> shall handle the KS inversion.",
    "options": [
      {
        "name": "ks_inversion_none",
        "value": "1"
      },
      {
        "name": "ks_inversion_adiabatic",
        "value": "2"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/invert ks/ksinversionlevel/"
  },
  "KSInversionAsymptotics": {
    "type": "integer",
    "default": "xc_asymptotics_none",
    "section": "Calculation Modes::Invert KS",
    "description": "Asymptotic correction applied to <math>v_{xc}</math>.",
    "options": [
      {
        "name": "xc_asymptotics_none",
        "value": "1"
      },
      {
        "name": "xc_asymptotics_sc",
        "value": "2"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/invert ks/ksinversionasymptotics/"
  },
  "InvertKSConvAbsDens": {
    "type": "float",
    "default": "1e-5",
    "section": "Calculation Modes::Invert KS",
    "description": "Absolute difference between the calculated and the target density in the KS inversion. Has to be larger than the convergence of the density in the SCF run.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/invert ks/invertksconvabsdens/"
  },
  "InvertKSStellaBeta": {
    "type": "float",
    "default": "1.0",
    "section": "Calculation Modes::Invert KS",
    "description": "residual term in Stella iterative scheme to avoid 0 denominators",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/invert ks/invertksstellabeta/"
  },
  "InvertKSStellaAlpha": {
    "type": "float",
    "default": "0.05",
    "section": "Calculation Modes::Invert KS",
    "description": "prefactor term in iterative scheme from L Stella",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/invert ks/invertksstellaalpha/"
  },
  "InvertKSGodbyMu": {
    "type": "float",
    "default": "1.0",
    "section": "Calculation Modes::Invert KS",
    "description": "prefactor for iterative KS inversion convergence scheme from Godby based on van Leeuwen scheme",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/invert ks/invertksgodbymu/"
  },
  "InvertKSGodbyPower": {
    "type": "float",
    "default": "0.05",
    "section": "Calculation Modes::Invert KS",
    "description": "power to which density is elevated for iterative KS inversion convergence scheme from Godby based on van Leeuwen scheme",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/invert ks/invertksgodbypower/"
  },
  "InvertKSVerbosity": {
    "type": "integer",
    "default": "0",
    "section": "Calculation Modes::Invert KS",
    "description": "Selects what is output during the calculation of the KS potential.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/invert ks/invertksverbosity/"
  },
  "InvertKSMaxIter": {
    "type": "integer",
    "default": "200",
    "section": "Calculation Modes::Invert KS",
    "description": "Selects how many iterations of inversion will be done in the iterative scheme",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/calculation modes/invert ks/invertksmaxiter/"
  },
  "TheoryLevel": {
    "type": "integer",
    "default": "",
    "section": "Hamiltonian",
    "description": "The calculations can be run with different \"theory levels\" that control how electrons are simulated. The default is <tt>dft</tt>. When hybrid functionals are requested, through the <tt>XCFunctional</tt> variable, the default is <tt>hartree_fock</tt>.",
    "options": [
      {
        "name": "independent_particles",
        "value": "2"
      },
      {
        "name": "hartree",
        "value": "1"
      },
      {
        "name": "hartree_fock",
        "value": "3"
      },
      {
        "name": "kohn_sham",
        "value": "4"
      },
      {
        "name": "generalized_kohn_sham",
        "value": "5"
      },
      {
        "name": "rdmft",
        "value": "7"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/theorylevel/"
  },
  "XCKernel": {
    "type": "integer",
    "default": "",
    "section": "Hamiltonian::XC",
    "description": "Defines the exchange-correlation kernel. Only LDA kernels are available currently. The options are the same as <tt>XCFunctional</tt>. Note: the kernel is only needed for Casida, Sternheimer, or optimal-control calculations. Defaults: <br>1D: <tt>lda_x_1d + lda_c_1d_csc</tt> <br>2D: <tt>lda_x_2d + lda_c_2d_amgb</tt> <br>3D: <tt>lda_x + lda_c_pz_mod</tt>",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/xc/xckernel/"
  },
  "EnablePhotons": {
    "type": "logical",
    "default": "no",
    "section": "Hamiltonian",
    "description": "This variable can be used to enable photons in several types of calculations. It can be used to activate the one-photon OEP formalism. In the case of CalculationMode = casida, it enables photon modes as described in ACS Photonics 2019, 6, 11, 2757-2778. Finally, if set to yes when solving the ferquency-dependent Sternheimer equation, the photons are coupled to the electronic subsystem.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/enablephotons/"
  },
  "VDWCorrection": {
    "type": "integer",
    "default": "no",
    "section": "Hamiltonian::XC",
    "description": "(Experimental) This variable selects which van der Waals correction to apply to the correlation functional.",
    "options": [
      {
        "name": "none",
        "value": "0"
      },
      {
        "name": "vdw_ts",
        "value": "1"
      },
      {
        "name": "vdw_d3",
        "value": "3"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/xc/vdwcorrection/"
  },
  "VDWSelfConsistent": {
    "type": "logical",
    "default": "yes",
    "section": "Hamiltonian::XC",
    "description": "This variable controls whether the VDW correction is applied self-consistently, the default, or just as a correction to the total energy. This option only works with vdw_ts.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/xc/vdwselfconsistent/"
  },
  "VDWD3Functional": {
    "type": "string",
    "default": "",
    "section": "Hamiltonian::XC",
    "description": "(Experimental) You can use this variable to override the parametrization used by the DFT-D3 van deer Waals correction. Normally you need not set this variable, as the proper value will be selected by Octopus (if available). This variable takes a string value, the valid values can be found in the source file 'external_libs/dftd3/core.f90'. For example you can use: VDWD3Functional = 'pbe'",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/hamiltonian/xc/vdwd3functional/"
  },
  "Preconditioner": {
    "type": "integer",
    "default": "",
    "section": "SCF::Eigensolver",
    "description": "Which preconditioner to use in order to solve the Kohn-Sham equations or the linear-response equations. The default is pre_filter, except for curvilinear coordinates, where no preconditioner is applied by default.",
    "options": [
      {
        "name": "no",
        "value": "0"
      },
      {
        "name": "pre_filter",
        "value": "1"
      },
      {
        "name": "pre_jacobi",
        "value": "2"
      },
      {
        "name": "pre_poisson",
        "value": "3"
      },
      {
        "name": "pre_multigrid",
        "value": "7"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/scf/eigensolver/preconditioner/"
  },
  "PreconditionerFilterFactor": {
    "type": "float",
    "default": "",
    "section": "SCF::Eigensolver",
    "description": "This variable controls how much filter preconditioner is applied. A value of 1.0 means no preconditioning, 0.5 is the standard. The default is 0.5, except for periodic systems where the default is 0.6. If you observe that the first eigenvectors are not converging properly, especially for periodic systems, you should increment this value. The allowed range for this parameter is between 0.5 and 1.0. For other values, the SCF may converge to wrong results.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/scf/eigensolver/preconditionerfilterfactor/"
  },
  "PreconditionerIterationsPre": {
    "type": "integer",
    "default": "",
    "section": "SCF::Eigensolver",
    "description": "This variable is the number of pre-smoothing iterations for the multigrid preconditioner. The default is 1.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/scf/eigensolver/preconditioneriterationspre/"
  },
  "PreconditionerIterationsMiddle": {
    "type": "integer",
    "default": "",
    "section": "SCF::Eigensolver",
    "description": "This variable is the number of smoothing iterations on the coarsest grid for the multigrid preconditioner. The default is 1.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/scf/eigensolver/preconditioneriterationsmiddle/"
  },
  "PreconditionerIterationsPost": {
    "type": "integer",
    "default": "",
    "section": "SCF::Eigensolver",
    "description": "This variable is the number of post-smoothing iterations for the multigrid preconditioner. The default is 2.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/scf/eigensolver/preconditioneriterationspost/"
  },
  "BoxShape": {
    "type": "integer",
    "default": "",
    "section": "Mesh::Simulation Box",
    "description": "This variable decides the shape of the simulation box. The default is <tt>minimum</tt> for finite systems and <tt>parallelepiped</tt> for periodic systems. Note that some incompatibilities apply: <ul><li>Spherical or minimum mesh is not allowed for periodic systems. <li>Cylindrical mesh is not allowed for systems that are periodic in more than one dimension. <li><tt>box_image</tt> is only allowed in 2D.</ul>",
    "options": [
      {
        "name": "sphere",
        "value": "1"
      },
      {
        "name": "cylinder",
        "value": "2"
      },
      {
        "name": "minimum",
        "value": "3"
      },
      {
        "name": "parallelepiped",
        "value": "4"
      },
      {
        "name": "box_image",
        "value": "5"
      },
      {
        "name": "box_cgal",
        "value": "6"
      },
      {
        "name": "user_defined",
        "value": "77"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/mesh/simulation box/boxshape/"
  },
  "Radius": {
    "type": "float",
    "default": "",
    "section": "Mesh::Simulation Box",
    "description": "Defines the radius for <tt>BoxShape</tt> = <tt>sphere</tt>, <tt>cylinder</tt>, or <tt>minimum</tt>. Must be a positive number.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/mesh/simulation box/radius/"
  },
  "Xlength": {
    "type": "float",
    "default": "<tt>Radius</tt>",
    "section": "Mesh::Simulation Box",
    "description": "If <tt>BoxShape</tt> is <tt>cylinder</tt>, the total length of the cylinder is twice <tt>Xlength</tt>. Note that when PeriodicDimensions = 1, then the length of the cylinder is determined from the lattice vectors.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/mesh/simulation box/xlength/"
  },
  "Lsize": {
    "type": "block",
    "default": "",
    "section": "Mesh::Simulation Box",
    "description": "If <tt>BoxShape</tt> is <tt>parallelepiped</tt>, <tt>box_image</tt>, or <tt>user_defined</tt>, this is a block of the form: <tt>%Lsize <br>&nbsp;&nbsp;sizex | sizey | sizez | ... <br>%</tt> where the <tt>size*</tt> are half the lengths of the box in each direction. The number of columns must match the dimensionality of the calculation. If you want a cube you can also set <tt>Lsize</tt> as a single variable.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/mesh/simulation box/lsize/"
  },
  "BoxShapeImage": {
    "type": "string",
    "default": "",
    "section": "Mesh::Simulation Box",
    "description": "Name of the file that contains the image that defines the simulation box when <tt>BoxShape = box_image</tt>. No default. Will search in current directory and <tt>OCTOPUS-HOME/share/</tt>.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/mesh/simulation box/boxshapeimage/"
  },
  "BoxShapeUsDef": {
    "type": "string",
    "default": "",
    "section": "Mesh::Simulation Box",
    "description": "Boolean expression that defines the interior of the simulation box. For example, <tt>BoxShapeUsDef = \"(sqrt(x^2+y^2) <= 4) && z>-2 && z<2\"</tt> defines a cylinder with axis parallel to the <i>z</i>-axis.",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/mesh/simulation box/boxshapeusdef/"
  },
  "BoxCgalFile": {
    "type": "string",
    "default": "",
    "section": "Mesh::Simulation Box",
    "description": "Filename to be read in by the cgal library. It should describe a shape that is used for the simulation box",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/mesh/simulation box/boxcgalfile/"
  },
  "BoxCenter": {
    "type": "float",
    "default": "",
    "section": "Mesh::Simulation Box",
    "description": "This block defines the coordinate center of the simulation box",
    "options": [],
    "docUrl": "https://octopus-code.org/documentation/14/variables/mesh/simulation box/boxcenter/"
  },
  "TDSystemPropagator": {
    "type": "integer",
    "default": "static",
    "section": "Time-Dependent::Propagation",
    "description": "A variable to set the propagator in the multisystem framework. This is a temporary solution, and should be replaced by the TDPropagator variable.",
    "options": [
      {
        "name": "static",
        "value": "0"
      },
      {
        "name": "verlet",
        "value": "1"
      },
      {
        "name": "beeman",
        "value": "2"
      },
      {
        "name": "beeman_scf",
        "value": "3"
      },
      {
        "name": "exp_mid_2step",
        "value": "4"
      },
      {
        "name": "exp_mid_2step_scf",
        "value": "5"
      },
      {
        "name": "prop_aetrs",
        "value": "6"
      },
      {
        "name": "prop_rk4",
        "value": "7"
      },
      {
        "name": "prop_expmid",
        "value": "8"
      },
      {
        "name": "prop_leapfrog",
        "value": "9"
      },
      {
        "name": "prop_bomd",
        "value": "10"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/propagation/tdsystempropagator/"
  },
  "InteractionTiming": {
    "type": "integer",
    "default": "timing_exact",
    "section": "Time-Dependent::Propagation",
    "description": "A parameter to determine if interactions should use the quantities at the exact time or if retardation is allowed.",
    "options": [
      {
        "name": "timing_exact",
        "value": "1"
      },
      {
        "name": "timing_retarded",
        "value": "2"
      }
    ],
    "docUrl": "https://octopus-code.org/documentation/14/variables/time-dependent/propagation/interactiontiming/"
  }
}